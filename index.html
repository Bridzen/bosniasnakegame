<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bosnia Snake: Kingdom Update (AI Fix)</title>
    <!-- PeerJS for Multiplayer Networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <style>
        /* --- GLOBAL STYLES --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #080b12;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI LAYER WRAPPER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        /* --- HEADS UP DISPLAY (HUD) --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 240px;
            height: 60px;
            background: rgba(0, 15, 60, 0.7);
            border: 2px solid #0055A4;
            border-radius: 10px;
            display: none; /* Hidden on start */
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 85, 164, 0.4);
        }

        #hud-size { 
            font-weight: bold; 
            font-size: 22px; 
            text-shadow: 1px 1px 2px black;
        }

        #hud-kills { 
            font-weight: bold; 
            font-size: 16px; 
            color: #FECB00; 
            text-shadow: 1px 1px 2px black;
        }

        /* --- ABILITY INDICATOR --- */
        #ability-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(0,0,0,0.6);
            border-radius: 50%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 4px solid #555;
            transition: border-color 0.3s;
        }
        #ability-text {
            font-weight: bold;
            font-size: 14px;
            color: white;
        }
        #ability-sub {
            font-size: 10px;
            color: #ddd;
        }

        /* --- SPECTATOR LABEL --- */
        #spectator-label {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 0px 0px 5px black;
            display: none;
            color: cyan;
            letter-spacing: 2px;
        }

        /* --- MENU SYSTEM --- */
        #menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 15px;
            height: 700px;
            pointer-events: auto;
            z-index: 20;
        }

        .panel {
            background: rgba(0, 15, 60, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid #FECB00;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(0, 47, 108, 0.5);
            display: flex;
            flex-direction: column;
            padding: 25px;
        }

        #stats-panel {
            width: 240px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #leaderboard-panel {
            width: 250px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #main-menu {
            width: 520px;
            overflow-y: auto;
            position: relative;
        }

        h1 {
            font-size: 50px;
            font-weight: 900;
            text-align: center;
            margin: 0 0 30px 0;
            color: #fff;
            text-shadow: 2px 2px 0px #002F6C, 0 0 15px #FECB00;
        }

        .header-text {
            color: #FECB00;
            font-size: 18px;
            font-weight: 900;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-bottom: 2px solid #002F6C;
            padding-bottom: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* --- FORM ELEMENTS --- */
        input[type="text"], input[type="password"] {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: white;
            font-size: 16px;
            width: 100%;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 15px;
            outline: none;
            box-sizing: border-box;
            transition: background 0.2s, border 0.2s;
        }
        input[type="text"]:focus, input[type="password"]:focus {
            background: rgba(255,255,255,0.2);
            border-color: #FECB00;
        }

        button {
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn-primary {
            width: 100%;
            padding: 18px;
            background: linear-gradient(to right, #002F6C, #0055A4);
            color: white;
            font-size: 16px;
            margin-top: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        }
        .btn-primary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0,0,0,0.3);
        }

        .btn-redeem {
            width: 100%;
            padding: 10px;
            background: linear-gradient(to right, #C6363C, #800000);
            color: white;
            font-size: 12px;
            margin-top: 5px;
        }

        .btn-toggle {
            flex: 1;
            padding: 12px;
            background: #222;
            color: #888;
        }
        .btn-toggle.active {
            background: #FECB00;
            color: black;
            box-shadow: 0 0 10px #FECB00;
        }

        /* --- SKIN GRID --- */
        #skin-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            overflow-y: auto;
            flex: 1;
            margin-bottom: 20px;
            min-height: 250px;
            padding-right: 5px;
        }

        .skin-tile {
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
        }
        .skin-tile:hover {
            background: rgba(255,255,255,0.1);
        }
        .skin-tile.selected {
            background: rgba(254, 203, 0, 0.2);
            border-color: #FECB00;
            box-shadow: 0 0 10px rgba(254, 203, 0, 0.2);
        }
        .skin-tile.locked {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .skin-color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.8);
            margin-bottom: 8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .lock-text {
            font-size: 9px;
            color: #ff5555;
            font-weight: bold;
            margin-top: 5px;
            text-align: center;
            text-transform: uppercase;
        }

        /* --- CHAT SYSTEM --- */
        #chat-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 320px;
            height: 250px;
            display: none;
            flex-direction: column;
            pointer-events: auto;
            z-index: 100;
        }
        #chat-messages {
            flex: 1;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
            padding-right: 5px;
        }
        .chat-line {
            font-size: 14px;
            margin-bottom: 4px;
            background: rgba(0,0,0,0.4);
            padding: 4px 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }
        #chat-input {
            background: rgba(0,0,0,0.6);
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 4px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
        }

        /* --- SPECTATE LIST --- */
        #spectate-list {
            max-height: 140px;
            overflow-y: auto;
        }
        .spectate-row {
            padding: 12px;
            background: #222;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        .spectate-row:hover { background: #333; }
        
        /* --- DEATH SCREEN --- */
        #death-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            pointer-events: none;
            z-index: 50;
        }
        .death-title {
            font-size: 60px;
            font-weight: 900;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
        }
        .death-sub {
            font-size: 24px;
            color: #ccc;
            text-shadow: 1px 1px 0 #000;
        }

        /* --- OWNER / CHEAT PANELS --- */
        #owner-login-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: black;
            padding: 15px;
            border: 2px solid red;
            z-index: 999;
            display: none;
        }
        #owner-control-panel {
            position: absolute;
            top: 60px;
            left: 10px;
            width: 150px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border: 2px solid red;
            color: white;
            z-index: 999;
            display: none;
            box-shadow: 0 0 20px red;
        }
        .cheat-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background: #330000;
            color: red;
            border: 1px solid red;
            font-size: 11px;
        }
        .cheat-btn:hover {
            background: red;
            color: black;
        }
        #cheat-msg {
            text-align: center;
            color: cyan;
            font-weight: bold;
            margin-top: 10px;
            font-size: 12px;
            height: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        ::-webkit-scrollbar-thumb { background: #FECB00; border-radius: 3px; }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer">
        
        <!-- GAME HUD -->
        <div id="hud">
            <div id="hud-size">Size: 18.0</div>
            <div id="hud-kills">Kills: 0</div>
        </div>

        <!-- ABILITY HUD -->
        <div id="ability-indicator">
            <div id="ability-text">READY</div>
            <div id="ability-sub">ABILITY</div>
        </div>

        <div id="spectator-label">SPECTATOR MODE</div>

        <!-- MENU CONTAINER -->
        <div id="menu-container">
            <!-- Left Stats -->
            <div id="stats-panel" class="panel">
                <div class="header-text">Stats</div>
                <div class="row"><span>KILLS</span><span id="stat-kills" style="color: #FECB00">0</span></div>
                <div class="row"><span>DEATHS</span><span id="stat-deaths" style="color: #FECB00">0</span></div>
                <div class="row"><span>BEST SIZE</span><span id="stat-best-size" style="color: #FECB00">18.0</span></div>
                <div class="row"><span>GAMES</span><span id="stat-games" style="color: #FECB00">0</span></div>
                <div class="row"><span>MAX MINES</span><span id="stat-mines" style="color: #FECB00">0</span></div>
                <div class="row"><span>MAX LENGTH</span><span id="stat-length" style="color: #FECB00">140</span></div>
                
                <div style="margin-top: auto; padding-top: 15px; border-top: 1px solid #333;">
                    <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">SECRET CODE</div>
                    <input type="text" id="redeem-input" style="font-size: 12px; padding: 10px; margin-bottom: 8px;" placeholder="Enter Code...">
                    <button id="btn-redeem" class="btn-redeem">REDEEM CODE</button>
                </div>
            </div>

            <!-- Main Menu Center -->
            <div id="main-menu" class="panel">
                <h1>BOSNIA SNAKE</h1>

                <!-- Control Mode -->
                <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                    <button id="btn-mouse" class="btn-toggle active">MOUSE CONTROL</button>
                    <button id="btn-keyboard" class="btn-toggle">KEYBOARD CONTROL</button>
                </div>

                <!-- Skin Selection -->
                <div style="font-size: 12px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">SELECT SKIN</div>
                <div style="display: flex; margin-bottom: 10px; gap: 5px;">
                    <button id="cat-normal" class="btn-toggle active" style="padding: 8px; font-size: 12px;">NATIONAL</button>
                    <button id="cat-special" class="btn-toggle" style="padding: 8px; font-size: 12px;">SPECIAL / SECRET</button>
                </div>

                <div id="skin-grid"></div>

                <input type="text" id="nickname-input" placeholder="ENTER NICKNAME">
                <button id="btn-play" class="btn-primary">PLAY SOLO</button>

                <!-- Spectate List -->
                <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;">
                    <div style="color: #FECB00; font-weight: bold; margin-bottom: 10px; font-size: 14px;">
                        LIVE GAMES <span id="scan-status" style="font-size: 10px; color: #666; font-weight: normal;">(Scanning...)</span>
                    </div>
                    <div id="spectate-list">
                        <div style="color: #666; font-size: 12px; font-style: italic; padding: 10px;">Initializing scanner...</div>
                    </div>
                </div>
            </div>

            <!-- Leaderboard -->
            <div id="leaderboard-panel" class="panel">
                <div class="header-text">Top 5</div>
                <div id="leaderboard-content">
                    <div style="text-align: center; color: #888; margin-top: 20px;">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Chat -->
        <div id="chat-container">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Type to chat (Enter to send)...">
        </div>

        <!-- Death Screen -->
        <div id="death-screen">
            <div class="death-title">YOU DIED</div>
            <div class="death-sub">Press 'R' to Restart</div>
        </div>

        <!-- OWNER / CHEAT PANELS -->
        <div id="owner-login-panel">
            <div style="color:red; font-size:12px; margin-bottom:5px;">OWNER ACCESS</div>
            <input type="password" id="owner-password" placeholder="Password">
            <button id="btn-owner-login" style="width:100%; background:red; color:white; padding:5px;">LOGIN</button>
        </div>

        <div id="owner-control-panel">
            <div style="text-align:center; margin-bottom:10px; border-bottom:1px solid red;">CHEATS</div>
            <button class="cheat-btn" id="cheat-god">God Mode: OFF</button>
            <button class="cheat-btn" id="cheat-speed">Speed Hack: OFF</button>
            <button class="cheat-btn" id="cheat-size">Set Size 50</button>
            <button class="cheat-btn" id="cheat-killbots">Kill All Bots</button>
            <button class="cheat-btn" id="cheat-reset">Reset World</button>
            <div id="cheat-msg"></div>
        </div>

    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        // -------------------------------------------------------------------------
        // IMPORTS (Firebase)
        // -------------------------------------------------------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { 
            getFirestore, collection, query, orderBy, limit, onSnapshot, 
            addDoc, serverTimestamp, where, getDocs, updateDoc, doc, setDoc, deleteDoc 
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // -------------------------------------------------------------------------
        // FIREBASE CONFIGURATION
        // -------------------------------------------------------------------------
        const firebaseConfig = {
            apiKey: "AIzaSyDFtRTloB37SCPGacQSxjmcuSPOHTHutNk",
            authDomain: "bosniasnake.firebaseapp.com",
            projectId: "bosniasnake",
            storageBucket: "bosniasnake.firebasestorage.app",
            messagingSenderId: "246754109806",
            appId: "1:246754109806:web:c58a4820f26478b69ab97f",
            measurementId: "G-FFQ2PJ3X5W"
        };

        let app, db, auth;
        let authReady = false;

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            signInAnonymously(auth).then(() => {
                console.log("Connected to Firebase (Anonymous)");
                authReady = true;
                startScanner();
            }).catch(err => {
                console.error("Auth Error:", err);
            });
        } catch(e) {
            console.error("Firebase Init Failed", e);
        }

        // -------------------------------------------------------------------------
        // GAME CONFIGURATION CONSTANTS
        // -------------------------------------------------------------------------
        const OWNER_PASSWORD = "Roblox13_isme";
        const CELL = 150;
        const GRID = 80;
        const WORLD_SIZE = CELL * GRID;
        const MIN_LENGTH = 140;
        const SPRINT_COST = 0.5;
        
        // Tuning
        const BASE_SPEED = 4.2;
        const TURN_SPEED = 0.09;
        const MAX_ENEMIES = 8; 
        
        const SIZE_GAIN_PER_LEVEL = 0.15;
        const FOOD_RADIUS_BASE = 6;
        const LENGTH_GAIN = 8;
        const BROADCAST_RATE = 50; 
        const INTERPOLATION_SPEED = 0.2;

        // Skin Lists
        const SKINS_NORMAL = [
            "bosnia", "russia", "germany", "france", "canada", "ukraine", 
            "usa", "uk", "italy", "poland", "sweden", "denmark"
        ];
        const SKINS_SPECIAL = ["ireland", "soviet", "golden_maple", "bosnian_kingdom"];

        const SKIN_BODY_COLORS = {
            bosnia: "#002F6C", russia: "#FFFFFF", germany: "#000000", france: "#0055A4", 
            canada: "#FF0000", ukraine: "#0057B8", ireland: "#169B62", soviet: "#CC0000", 
            golden_maple: "#DAA520", bosnian_kingdom: "#002395", 
            usa: "#3C3B6E", uk: "#012169", italy: "#008C45", 
            poland: "#DC143C", sweden: "#006AA7", denmark: "#C60C30", serbia: "#C6363C",
            croatia: "#CC0000"
        };

        const UNLOCK_CRITERIA = {
            bosnia: { type: "default", label: "Default" },
            russia: { type: "scale", val: 50, label: "Reach Size 50" },
            germany: { type: "scale", val: 40, label: "Reach Size 40" },
            france: { type: "deaths", val: 5, label: "Die 5 Times" },
            canada: { type: "length", val: 1000, label: "Reach Length 1k" },
            ukraine: { type: "games", val: 5, label: "Play 5 Games" },
            usa: { type: "scale", val: 75, label: "Reach Size 75" },
            uk: { type: "length", val: 800, label: "Reach Length 800" },
            italy: { type: "default", label: "Default" },
            poland: { type: "deaths", val: 15, label: "Die 15 Times" },
            sweden: { type: "kills", val: 10, label: "Get 10 Kills" },
            denmark: { type: "kills", val: 25, label: "Get 25 Kills" },
            ireland: { type: "code", label: "Secret Code" },
            soviet: { type: "custom_soviet", label: "Russia + Size 500 + 50 Kills" },
            golden_maple: { type: "custom_maple", label: "Canada + Size 250 + 150 Kills" },
            bosnian_kingdom: { type: "custom_kingdom", label: "Bosnia + Size 271 + 40 Kills + 20 Mines (1 Game)" },
        };

        // -------------------------------------------------------------------------
        // AUDIO ENGINE
        // -------------------------------------------------------------------------
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (!audioCtx) return;
            if (audioCtx.state === "suspended") audioCtx.resume();

            const now = audioCtx.currentTime;
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            if (type === "eat") {
                const osc = audioCtx.createOscillator();
                osc.type = "sine";
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === "soviet_boom") {
                const bufferSize = audioCtx.sampleRate * 1.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = "lowpass";
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.exponentialRampToValueAtTime(10, now + 1);
                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.gain.setValueAtTime(0.8, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1);
                noise.start(now);
                noise.stop(now + 1.5);
            } else if (type === "angelic") {
                const freqs = [523.25, 659.25, 783.99];
                freqs.forEach((f, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = "triangle";
                    osc.frequency.value = f;
                    if (i === 1) osc.detune.value = 5;
                    if (i === 2) osc.detune.value = -5;
                    osc.connect(gainNode);
                    osc.start(now);
                    osc.stop(now + 2.5);
                });
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.08, now + 0.5);
                gainNode.gain.linearRampToValueAtTime(0, now + 2.5);
            } else if (type === "chat") {
                const osc = audioCtx.createOscillator();
                osc.type = "sine";
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        // -------------------------------------------------------------------------
        // GLOBAL STATE VARIABLES
        // -------------------------------------------------------------------------
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let currentState = {
            menu: 'start',
            controlMode: 'mouse',
            skinCategory: 'normal',
            selectedSkin: 'bosnia',
            playerName: localStorage.getItem('bosnia_snake_username') || "Player" + Math.floor(Math.random() * 999),
            isHost: false,
            isSpectating: false,
            myId: null,
            myPlayerIndex: 0
        };

        // Persistent Stats
        let userStats = {
            totalKills: 0,
            totalDeaths: 0,
            bestScale: 18,
            bestLength: 140,
            gamesPlayed: 0,
            maxMinesInGame: 0,
            unlockedSecrets: []
        };
        try {
            const loaded = localStorage.getItem('bosnia_snake_stats_v2');
            if(loaded) userStats = JSON.parse(loaded);
        } catch(e) { console.warn("Failed to load stats"); }

        // Cheats
        const cheats = { godMode: false, speedHack: false };
        let showOwnerLogin = false;
        let showOwnerPanel = false;

        // Networking
        let peer = null;
        let connections = [];
        let hostConn = null;
        let lastSentTime = 0;
        let serverState = null;

        // Input
        const mouse = { x: 0, y: 0 };
        const keys = {};

        // Game World Data
        let gameData = {
            mode: null,
            players: [],
            enemies: [], // Bots
            food: [],
            mines: [],
            explosions: [],
            syrupZones: [],
            shakeIntensity: 0,
            gameOver: false
        };

        // -------------------------------------------------------------------------
        // HELPER FUNCTIONS
        // -------------------------------------------------------------------------
        function randPosCell() { return Math.floor(Math.random() * GRID) * CELL - WORLD_SIZE / 2; }
        function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
        function coll(a, b, r) { return dist(a, b) < r; }
        function normalizeAngle(angle) { return Math.atan2(Math.sin(angle), Math.cos(angle)); }
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function lerpAngle(a, b, t) {
            const da = (b - a) % (2 * Math.PI);
            const twoD = ((2 * da) % (2 * Math.PI)) - da;
            return a + twoD * t;
        }

        // -------------------------------------------------------------------------
        // STATS & UNLOCK LOGIC
        // -------------------------------------------------------------------------
        function updateStatsUI() {
            document.getElementById('stat-kills').innerText = userStats.totalKills;
            document.getElementById('stat-deaths').innerText = userStats.totalDeaths;
            document.getElementById('stat-best-size').innerText = userStats.bestScale.toFixed(1);
            document.getElementById('stat-games').innerText = userStats.gamesPlayed;
            document.getElementById('stat-mines').innerText = userStats.maxMinesInGame || 0;
            document.getElementById('stat-length').innerText = Math.round(userStats.bestLength);
        }

        function isSkinUnlocked(skin) {
            if (userStats.unlockedSecrets.includes("MASTER_UNLOCK")) return true;

            const req = UNLOCK_CRITERIA[skin];
            if (!req) return true;
            if (skin === "soviet") return isSkinUnlocked("russia") && userStats.bestScale >= 500 && userStats.totalKills >= 50;
            if (skin === "golden_maple") return isSkinUnlocked("canada") && userStats.bestScale >= 250 && userStats.totalKills >= 150;
            if (skin === "bosnian_kingdom") return isSkinUnlocked("bosnia") && userStats.bestScale >= 271 && userStats.totalKills >= 40 && userStats.maxMinesInGame >= 20;

            if (req.type === "default") return true;
            if (req.type === "code") return userStats.unlockedSecrets.includes(skin);
            if (req.type === "kills") return userStats.totalKills >= req.val;
            if (req.type === "deaths") return userStats.totalDeaths >= req.val;
            if (req.type === "scale") return userStats.bestScale >= req.val;
            if (req.type === "length") return userStats.bestLength >= req.val;
            if (req.type === "games") return userStats.gamesPlayed >= req.val;
            return false;
        }

        function updateStats(updates) {
            let changed = false;
            if (updates.kill) { userStats.totalKills++; changed = true; }
            if (updates.death) { userStats.totalDeaths++; changed = true; }
            if (updates.game) { userStats.gamesPlayed++; changed = true; }
            if (updates.unlockSecret && !userStats.unlockedSecrets.includes(updates.unlockSecret)) {
                userStats.unlockedSecrets.push(updates.unlockSecret);
                changed = true;
            }
            if (updates.scale && updates.scale > userStats.bestScale) { userStats.bestScale = updates.scale; changed = true; }
            if (updates.length && updates.length > userStats.bestLength) { userStats.bestLength = updates.length; changed = true; }
            if (updates.minesExploded && updates.minesExploded > userStats.maxMinesInGame) { userStats.maxMinesInGame = updates.minesExploded; changed = true; }

            if (changed) {
                localStorage.setItem('bosnia_snake_stats_v2', JSON.stringify(userStats));
                updateStatsUI();
                renderSkinGrid();
            }
        }

        // -------------------------------------------------------------------------
        // GAME INITIALIZATION
        // -------------------------------------------------------------------------
        function initSinglePlayer() {
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', (id) => {
                currentState.myId = id;
                currentState.isHost = true;
                currentState.isSpectating = false;
                currentState.myPlayerIndex = 0;
                currentState.menu = 'playing';

                if(authReady) {
                    const docRef = doc(db, "active_games", id);
                    const publish = () => setDoc(docRef, { host: currentState.playerName, lastBeat: serverTimestamp() }).catch(e => console.warn("Presence err", e));
                    publish();
                    const hb = setInterval(publish, 5000);
                    peer.on('disconnected', () => clearInterval(hb));
                }

                updateStats({ game: true });

                gameData.mode = "single";
                gameData.players = [{
                    id: 0,
                    active: true,
                    x: 0,
                    y: 0,
                    angle: -Math.PI / 2,
                    body: [],
                    length: 140,
                    dead: false,
                    country: currentState.selectedSkin,
                    colorBody: SKIN_BODY_COLORS[currentState.selectedSkin],
                    scale: 18,
                    kills: 0,
                    deaths: 0,
                    frozenUntil: 0,
                    abilityActive: false,
                    lastAbilityTime: 0,
                    maplePhase: null,
                    kingdomPhase: null,
                    minesExplodedCurrentGame: 0,
                    name: currentState.playerName
                }];
                
                resetWorld(true);
                toggleUI('playing');
                addChatMessage("System", "Welcome to Single Player! Room ID: " + id, "lime");

                peer.on('connection', (conn) => {
                    connections.push(conn);
                    conn.on('data', (data) => {
                        if (data.type === "CHAT") {
                            const msg = { name: data.name, text: data.text, color: "#aaa" };
                            addChatMessage(msg.name, msg.text, msg.color);
                            broadcastChat(msg);
                            playSound("chat");
                        }
                    });
                    conn.on('close', () => {
                        connections = connections.filter(c => c !== conn);
                    });
                });
            });
        }

        function initSpectate(idToJoin) {
            if (!idToJoin) return;
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', () => {
                const conn = peer.connect(idToJoin);
                hostConn = conn;
                currentState.isHost = false;
                currentState.isSpectating = true;

                conn.on('open', () => {
                    currentState.menu = 'playing';
                    toggleUI('playing');
                    addChatMessage("System", "Connected to Host.", "cyan");
                });

                conn.on('data', (data) => {
                    if (data.type === "STATE") {
                        serverState = data.state;
                        if (gameData.players.length === 0 && serverState) {
                            gameData = JSON.parse(JSON.stringify(serverState));
                            gameData.players.forEach(p => p.body = p.body || []);
                            gameData.enemies.forEach(e => e.body = e.body || []);
                        }
                    }
                    if (data.type === "CHAT_MSG") {
                        addChatMessage(data.msg.name, data.msg.text, data.msg.color);
                        playSound("chat");
                    }
                });

                conn.on('close', () => {
                    alert("Host Disconnected");
                    location.reload();
                });
            });
        }

        function broadcastChat(msg) {
            connections.forEach(c => { if (c.open) c.send({ type: "CHAT_MSG", msg }); });
        }

        // -------------------------------------------------------------------------
        // GAME LOGIC CORE
        // -------------------------------------------------------------------------
        function resetWorld(spawnBots) {
            const s = gameData;
            s.food = [];
            s.mines = [];
            s.explosions = [];
            s.syrupZones = [];
            s.shakeIntensity = 0;
            s.gameOver = false;

            for (let i = 0; i < 400; i++) {
                let level = 1;
                while (level < 100 && Math.random() < 0.5) level++;
                s.food.push({ x: randPosCell(), y: randPosCell(), level: level });
            }

            for (let i = 0; i < 80; i++) {
                s.mines.push({
                    x: randPosCell(),
                    y: randPosCell(),
                    state: "idle",
                    timer: 3.0,
                    lastTick: Date.now()
                });
            }

            s.players.forEach((p) => {
                p.x = randPosCell();
                p.y = randPosCell();
                p.body = [];
                p.length = 140;
                p.scale = 18;
                p.dead = false;
                p.frozenUntil = 0;
                p.abilityActive = false;
                p.lastAbilityTime = 0;
                p.maplePhase = null;
                p.kingdomPhase = null;
                p.minesExplodedCurrentGame = 0;
                p.barrageActive = false;
            });

            s.enemies = [];
            if (spawnBots) {
                for (let i = 0; i < MAX_ENEMIES; i++) spawnOneEnemy();
            }
        }

        function spawnOneEnemy() {
            const startLen = 140 + Math.random() * 100; 
            const startWidth = 14;
            const player = gameData.players[0];
            let isCroatia = false;
            if (player && player.scale > 100 && Math.random() < 0.08) isCroatia = true;
            
            gameData.enemies.push({
                x: randPosCell(),
                y: randPosCell(),
                angle: Math.random() * Math.PI * 2,
                body: [],
                length: startLen,
                width: startWidth,
                baseScale: startWidth,
                speed: (2.5 + Math.random()) * 1.1,
                boostSpeed: isCroatia ? 16.0 : 8.5, 
                turnSpeed: isCroatia ? 0.12 : 0.08, 
                alive: true,
                color: isCroatia ? "#CC0000" : "#C6363C", 
                country: isCroatia ? "croatia" : "serbia", 
                frozenUntil: 0,
                // AI BRAIN VARS (FOR COMPLEX AI)
                stuckTimer: 0,
                lastX: 0, 
                lastY: 0,
                lastStuckCheck: Date.now(),
                isPanicking: false,
                panicAngle: 0,
                panicEndTime: 0
            });
        }

        function getLocalInput() {
            if (currentState.isSpectating) return { targetAngle: null, sprint: false, triggerAbility: false, respawn: false };

            const sprint = keys['shift'] || keys['/'];
            const triggerAbility = keys['e'];
            const respawn = keys[' '];

            let targetAngle = null;
            if (currentState.controlMode === 'mouse') {
                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                targetAngle = Math.atan2(mouse.y - cy, mouse.x - cx);
            } else {
                let dx = 0, dy = 0;
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;
                if (dx !== 0 || dy !== 0) targetAngle = Math.atan2(dy, dx);
            }
            return { targetAngle, sprint, triggerAbility, respawn };
        }

        function updateHostLogic() {
            const p = gameData.players[0];
            const inp = getLocalInput();

            if (p && p.dead) {
                if (keys['r']) {
                     resetWorld(true);
                     toggleUI('playing');
                }
                return;
            }

            gameData.enemies = gameData.enemies.filter(e => e.alive);
            if (gameData.enemies.length < MAX_ENEMIES && Math.random() < 0.02) spawnOneEnemy();

            if (p) handlePhysics(p, inp);
            updateAI(); 
            if (p) updateEnvironment([p, ...gameData.enemies]);
        }

        function handlePhysics(p, inp) {
            const now = Date.now();
            if (p.frozenUntil > now) return;

            gameData.enemies.forEach(e => {
                if(e.alive) {
                    if (dist(p, e) < p.scale + e.width) killPlayer(p, null);
                    for(let i=0; i<e.body.length; i+=3) {
                        if(dist(p, e.body[i]) < p.scale + e.width - 5) {
                            killPlayer(p, null);
                            return; 
                        }
                    }
                }
            });

            // ABILITIES
            if (p.country === "soviet") {
                if (inp.sprint && !p.barrageActive && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000)) {
                    p.barrageActive = true;
                    p.barrageEndTime = now + 2000;
                    p.nextExplosionTime = now;
                    p.abilityActive = true;
                }
                if (p.barrageActive) {
                    if (now >= p.barrageEndTime) {
                        p.barrageActive = false;
                        p.abilityActive = false;
                        p.sovietBoost = false;
                        p.lastAbilityTime = now;
                    } else {
                        p.sovietBoost = true;
                        if (now >= p.nextExplosionTime) {
                            createExplosion(p.x, p.y, 3 * CELL);
                            gameData.shakeIntensity = Math.min(60, gameData.shakeIntensity + 10);
                            p.nextExplosionTime = now + 200;
                            playSound("soviet_boom");
                            gameData.enemies.forEach(e => {
                                if (e.alive && dist(e, p) < 3 * CELL) killEnemy(e, p);
                            });
                        }
                    }
                }
            }
            else if (p.country === "golden_maple") {
                if (inp.triggerAbility && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000) && !p.maplePhase) {
                    p.maplePhase = "harvest";
                    p.phaseEndTime = now + 2500;
                    p.lastAbilityTime = now;
                    playSound("angelic");
                }
                if (p.maplePhase === "harvest") {
                    if (now > p.phaseEndTime) {
                        p.maplePhase = "syrup";
                        p.phaseEndTime = now + 5000;
                        gameData.syrupZones.push({ x: p.x, y: p.y, radius: 6 * CELL, expiresAt: now + 5000, ownerId: p.id });
                    }
                } else if (p.maplePhase === "syrup") {
                    if (now > p.phaseEndTime) p.maplePhase = null;
                }
            }
            else if (p.country === "bosnian_kingdom") {
                if (inp.triggerAbility && (!p.lastAbilityTime || now - p.lastAbilityTime > 30000)) {
                    p.kingdomPhase = "active";
                    p.phaseEndTime = now + 1500;
                    p.lastAbilityTime = now;
                    playSound("soviet_boom");
                    
                    const radius = 300;
                    for (let i = gameData.food.length - 1; i >= 0; i--) {
                        if (dist(p, gameData.food[i]) < radius) {
                            gameData.food.splice(i, 1);
                            gameData.mines.push({
                                x: p.x + (Math.random()-0.5)*50,
                                y: p.y + (Math.random()-0.5)*50,
                                state: "idle",
                                type: "bosnian",
                                ownerId: p.id,
                                timer: 0.5,
                                lastTick: now
                            });
                        }
                    }

                    gameData.mines.forEach(m => {
                        if (dist(p, m) < radius && m.type !== "bosnian") {
                            m.type = "bosnian";
                            m.ownerId = p.id;
                            m.state = "idle";
                        }
                    });

                    for(let i=0; i<8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        gameData.mines.push({
                            x: p.x + Math.cos(angle) * 250,
                            y: p.y + Math.sin(angle) * 250,
                            state: "idle",
                            type: "bosnian",
                            ownerId: p.id,
                            timer: 0.5,
                            lastTick: now
                        });
                    }
                }
                
                if (p.kingdomPhase === "active" && now > p.phaseEndTime) {
                    p.kingdomPhase = null;
                }
            }

            let speedMult = 1.0;
            let turnMult = 1.0;
            gameData.syrupZones.forEach(zone => {
                if (dist(p, zone) < zone.radius && zone.ownerId !== p.id) {
                    speedMult = 0.4;
                    turnMult = 0.33;
                }
            });

            if (inp.targetAngle !== null) {
                let d = normalizeAngle(inp.targetAngle - p.angle);
                const effectiveTurnSpeed = TURN_SPEED * turnMult;
                if (Math.abs(d) < effectiveTurnSpeed) p.angle = inp.targetAngle;
                else p.angle += d > 0 ? effectiveTurnSpeed : -effectiveTurnSpeed;
                p.angle = normalizeAngle(p.angle);
            }

            let s = BASE_SPEED * speedMult;
            if (p.id === currentState.myPlayerIndex && cheats.speedHack) s = BASE_SPEED * 3;

            if (inp.sprint && p.length > MIN_LENGTH && (!p.abilityActive || p.country === "soviet")) {
                s *= 1.8;
                if (p.sovietBoost) s *= 2.0;
                p.length -= SPRINT_COST;
            }

            p.x += Math.cos(p.angle) * s;
            p.y += Math.sin(p.angle) * s;

            if (Math.abs(p.x) > WORLD_SIZE / 2 || Math.abs(p.y) > WORLD_SIZE / 2) {
                killPlayer(p, null);
            }

            p.body.unshift({ x: p.x, y: p.y });
            while (p.body.length > p.length) p.body.pop();
        }

        // -------------------------------------------------------------------------
        // COMPLEX AI SYSTEM (ANTI-LOOP & INTELLIGENCE)
        // -------------------------------------------------------------------------
        function updateAI() {
            const state = gameData;
            const now = Date.now();
            const AGGRO_RADIUS = 900; 

            state.enemies.forEach((enemy) => {
                if (!enemy.alive) return;
                if (enemy.frozenUntil && now < enemy.frozenUntil) return;

                // --- 1. STUCK DETECTION (Anti-Loop) ---
                if (now - enemy.lastStuckCheck > 1000) {
                    const d = dist(enemy, {x: enemy.lastX, y: enemy.lastY});
                    // If moved less than 100 units in 1 second, increase stuck counter
                    if (d < 100) enemy.stuckTimer++;
                    else enemy.stuckTimer = 0;

                    enemy.lastX = enemy.x;
                    enemy.lastY = enemy.y;
                    enemy.lastStuckCheck = now;

                    // If stuck for 3 seconds -> PANIC MODE
                    if (enemy.stuckTimer > 3) {
                        enemy.isPanicking = true;
                        enemy.panicAngle = Math.random() * Math.PI * 2;
                        enemy.panicEndTime = now + 2000; // Sprint for 2s
                        enemy.stuckTimer = 0;
                    }
                }

                // --- 2. SCALE LOGIC ---
                if (!enemy.baseScale) enemy.baseScale = 12;
                const currentCalculatedWidth = 12 + Math.min(60, (enemy.length - 140) / 4); 
                if (currentCalculatedWidth > enemy.baseScale) enemy.baseScale = currentCalculatedWidth;
                enemy.width = enemy.baseScale;

                let forceSprint = false;
                let finalX = 0;
                let finalY = 0;

                // --- 3. DECISION MAKING ---
                if (enemy.isPanicking) {
                    // PANIC BEHAVIOR
                    if (now > enemy.panicEndTime) enemy.isPanicking = false;
                    
                    // Force movement in panic angle
                    finalX = Math.cos(enemy.panicAngle) * 1000;
                    finalY = Math.sin(enemy.panicAngle) * 1000;
                    forceSprint = true;

                    // Only avoid walls if CRITICALLY close (Panic override)
                    if (Math.abs(enemy.x) > WORLD_SIZE/2 - 200) finalX -= enemy.x * 5;
                    if (Math.abs(enemy.y) > WORLD_SIZE/2 - 200) finalY -= enemy.y * 5;

                } else {
                    // NORMAL BEHAVIOR

                    // A. Gravity (Prevents hugging walls endlessly)
                    finalX -= enemy.x * 0.1;
                    finalY -= enemy.y * 0.1;

                    // B. Wall Avoidance
                    const distFromCenter = dist(enemy, {x:0, y:0});
                    const mapEdge = WORLD_SIZE / 2;
                    if (distFromCenter > mapEdge - 400) {
                        const push = 10000; 
                        finalX -= enemy.x * push;
                        finalY -= enemy.y * push;
                    }

                    // C. Entity Avoidance
                    const detectionRange = 250 + enemy.width;
                    
                    // Avoid Players
                    state.players.forEach(p => {
                        if(!p.dead) {
                            if (p.scale > enemy.width) {
                                const d = dist(enemy, p);
                                if (d < detectionRange + p.scale) {
                                    const push = 8000 / (d + 1);
                                    finalX -= (p.x - enemy.x) * push;
                                    finalY -= (p.y - enemy.y) * push;
                                }
                            }
                            for(let i=0; i < p.body.length; i+=2) {
                                const b = p.body[i];
                                if(dist(enemy, b) < detectionRange) {
                                    const push = 10000 / (dist(enemy, b) + 1);
                                    finalX -= (b.x - enemy.x) * push;
                                    finalY -= (b.y - enemy.y) * push;
                                }
                            }
                        }
                    });

                    // Avoid Other AI
                    state.enemies.forEach(other => {
                        if(other !== enemy && other.alive) {
                            if(dist(enemy, other) < detectionRange) {
                                const push = 5000 / (dist(enemy, other)+1);
                                finalX -= (other.x - enemy.x) * push;
                                finalY -= (other.y - enemy.y) * push;
                            }
                        }
                    });

                    // Avoid Mines
                    state.mines.forEach(m => {
                        if(dist(enemy, m) < detectionRange + 100) {
                            const push = 10000 / (dist(enemy, m)+1);
                            finalX -= (m.x - enemy.x) * push;
                            finalY -= (m.y - enemy.y) * push;
                        }
                    });

                    // D. Targeting
                    if (Math.abs(finalX) < 5000 && Math.abs(finalY) < 5000) {
                         let targetPlayer = null;
                         let distToPlayer = Infinity;
                         
                         state.players.forEach(p => {
                             if(!p.dead && p.active) {
                                 const d = dist(enemy, p);
                                 if(d < distToPlayer) { distToPlayer = d; targetPlayer = p; }
                             }
                         });

                         if (enemy.country === 'croatia' && targetPlayer) {
                             const leadX = (targetPlayer.x - enemy.x) + Math.cos(targetPlayer.angle)*distToPlayer*0.3;
                             const leadY = (targetPlayer.y - enemy.y) + Math.sin(targetPlayer.angle)*distToPlayer*0.3;
                             finalX += leadX * 8.0; 
                             finalY += leadY * 8.0;
                             forceSprint = true;
                         } else if (targetPlayer && distToPlayer < AGGRO_RADIUS && enemy.width > targetPlayer.scale) {
                             finalX += (targetPlayer.x - enemy.x) * 2.5;
                             finalY += (targetPlayer.y - enemy.y) * 2.5;
                             forceSprint = true;
                         } else {
                             // Seek Food
                             let bestFood = null;
                             let bestDist = Infinity;
                             for(let i=0; i<50; i++) {
                                 const f = state.food[Math.floor(Math.random()*state.food.length)];
                                 if(!f) continue;
                                 const d = dist(enemy, f);
                                 if(d < bestDist && d < 600) { bestDist = d; bestFood = f; }
                             }
                             if(bestFood) {
                                 finalX += (bestFood.x - enemy.x) * 2.0;
                                 finalY += (bestFood.y - enemy.y) * 2.0;
                             } else {
                                 // Wander momentum
                                 finalX += Math.cos(enemy.angle) * 300;
                                 finalY += Math.sin(enemy.angle) * 300;
                             }
                         }
                    }
                }

                // --- 4. EXECUTION ---
                const targetAngle = Math.atan2(finalY, finalX);
                let diff = normalizeAngle(targetAngle - enemy.angle);
                
                let dynamicTurn = enemy.turnSpeed;
                if (enemy.isPanicking) dynamicTurn *= 2.0;
                else if (enemy.width > 30) dynamicTurn *= 0.7;

                if (Math.abs(diff) < dynamicTurn) enemy.angle = targetAngle;
                else if (diff > 0) enemy.angle += dynamicTurn;
                else enemy.angle -= dynamicTurn;
                enemy.angle = normalizeAngle(enemy.angle);

                let spd = enemy.speed;
                if (forceSprint && enemy.length > 145) {
                    spd = enemy.boostSpeed;
                    enemy.length -= 0.15;
                }
                
                state.syrupZones.forEach(z => { if(dist(enemy, z) < z.radius) spd *= 0.4; });

                enemy.x += Math.cos(enemy.angle) * spd;
                enemy.y += Math.sin(enemy.angle) * spd;

                // Bounds kill
                if(Math.abs(enemy.x) > WORLD_SIZE/2 || Math.abs(enemy.y) > WORLD_SIZE/2) {
                    killEnemy(enemy, null);
                    return;
                }

                // Body & Interactions
                enemy.body.unshift({ x: enemy.x, y: enemy.y });
                while (enemy.body.length > enemy.length) enemy.body.pop();

                // Eat
                for (let i = state.food.length - 1; i >= 0; i--) {
                    if (coll(enemy, state.food[i], enemy.width + 10)) {
                        state.food.splice(i, 1);
                        enemy.length += 5; 
                        enemy.baseScale = Math.min(200, enemy.baseScale + 0.15); 
                    }
                }
                
                // Combat
                state.enemies.forEach(other => {
                    if(other !== enemy && other.alive) {
                        for(let b of other.body) {
                            if(coll(enemy, b, enemy.width + other.width - 5)) killEnemy(enemy, other);
                        }
                    }
                });
                state.players.forEach(p => {
                    if (!p.dead && p.active) {
                        if (coll(p, enemy, p.scale + enemy.width)) killPlayer(p, null);
                        for (let j = 0; j < p.body.length; j += 2)
                            if (coll(enemy, p.body[j], enemy.width + p.scale)) killEnemy(enemy, p);
                    }
                });
            });
        }

        // -------------------------------------------------------------------------
        // ENVIRONMENT & RENDER HELPERS
        // -------------------------------------------------------------------------
        function updateEnvironment(activeEntities) {
            const s = gameData;
            const now = Date.now();

            for (let i = s.syrupZones.length - 1; i >= 0; i--) {
                if (now > s.syrupZones[i].expiresAt) s.syrupZones.splice(i, 1);
            }

            for (let i = s.explosions.length - 1; i >= 0; i--) {
                s.explosions[i].radius += 15;
                s.explosions[i].alpha -= 0.05;
                if (s.explosions[i].alpha <= 0) s.explosions.splice(i, 1);
            }

            if (s.food.length < 400) {
                for (let k = 0; k < 10; k++) {
                    let level = 1;
                    while (level < 100 && Math.random() < 0.5) level++;
                    s.food.push({ x: randPosCell(), y: randPosCell(), level: level });
                }
            }

            activeEntities.forEach((p) => {
                if (p.country === "golden_maple" && p.maplePhase === "harvest") {
                    s.food.forEach((f) => { if (dist(p, f) < 5 * CELL) f.isGolden = true; });
                }
            });

            s.food.forEach((f, i) => {
                const foodLevel = f.level || 1;
                const rad = FOOD_RADIUS_BASE + foodLevel * 1.5;
                activeEntities.forEach((p) => {
                    if (!p.dead && coll(p, f, p.scale + rad)) {
                        if (p.id === currentState.myPlayerIndex) playSound("eat");
                        s.food.splice(i, 1);
                        const multiplier = f.isGolden ? 3 : 1;
                        p.length += LENGTH_GAIN * multiplier;
                        p.scale = Math.min(2000, p.scale + foodLevel * SIZE_GAIN_PER_LEVEL * multiplier);
                    }
                });
            });

            for (let i = s.mines.length - 1; i >= 0; i--) {
                let m = s.mines[i];
                const isBosnian = m.type === "bosnian";
                const explodeRadius = isBosnian ? 900 : 300; 
                const delay = isBosnian ? 500 : 3000;

                if (m.state === "idle") {
                    let triggered = false;
                    let triggerer = null;

                    activeEntities.forEach((p) => { 
                        if (!p.dead) {
                            if (isBosnian && p.id === m.ownerId) return;
                            if (dist(p, m) < 200) {
                                triggered = true;
                                triggerer = p;
                            }
                        }
                    });

                    if (triggered) { 
                        m.state = "triggered";
                        m.lastTick = now; 
                        
                        if (triggerer && triggerer.id === currentState.myPlayerIndex && !isBosnian) {
                            triggerer.minesExplodedCurrentGame = (triggerer.minesExplodedCurrentGame || 0) + 1;
                            updateStats({ minesExploded: triggerer.minesExplodedCurrentGame });
                        }
                    }
                } 
                else if (m.state === "triggered") {
                    if (now - m.lastTick > delay) {
                        createExplosion(m.x, m.y, isBosnian ? 200 : 10);
                        
                        activeEntities.forEach((p) => { 
                            if (!p.dead) {
                                if (isBosnian && p.id === m.ownerId) return;

                                if (dist(p, m) < explodeRadius) {
                                    if(p.id !== undefined) killPlayer(p, null);
                                    else killEnemy(p, null);
                                }
                            }
                        });
                        s.mines.splice(i, 1);
                    }
                }
            }
        }

        function createExplosion(x, y, radius = 10) {
            gameData.explosions.push({ x, y, radius: radius, alpha: 1.0 });
            const p = gameData.players[0];
            if (p && !p.dead && dist(p, {x, y}) < 1500) {
                gameData.shakeIntensity = Math.min(100, gameData.shakeIntensity + 30);
            }
        }

        function killPlayer(victim, killer) {
            if (victim.dead) return;
            if (victim.id === currentState.myPlayerIndex && cheats.godMode) return;
            
            victim.dead = true;
            victim.deaths++;
            victim.abilityActive = false;
            victim.maplePhase = null;
            victim.kingdomPhase = null;

            if (victim.id === currentState.myPlayerIndex) {
                updateStats({ death: true, scale: victim.scale, length: victim.length });
                submitScoreToLeaderboard(victim.scale);
                toggleUI('death');
            }

            if (killer && killer.id === currentState.myPlayerIndex) {
                updateStats({ kill: true });
            }

            createExplosion(victim.x, victim.y);
            const foodCount = Math.max(3, Math.floor((victim.length * 0.4) / LENGTH_GAIN));
            for (let k = 0; k < foodCount; k++) {
                const index = Math.floor(Math.random() * victim.body.length);
                if (victim.body[index]) {
                    gameData.food.push({ x: victim.body[index].x, y: victim.body[index].y, level: Math.floor(Math.random() * 3) + 1 });
                }
            }
        }

        function killEnemy(e, killer) {
            if (!e.alive) return;
            e.alive = false;
            if (killer && killer.id === currentState.myPlayerIndex) {
                updateStats({ kill: true });
            }
            createExplosion(e.x, e.y);
            const foodCount = Math.max(3, Math.floor((e.length * 0.4) / LENGTH_GAIN));
            const stepSize = Math.max(1, Math.floor(e.body.length / foodCount));
            for (let i = 0; i < e.body.length; i += stepSize) {
                const point = e.body[i];
                if(point) gameData.food.push({ x: point.x + (Math.random() - 0.5) * 20, y: point.y + (Math.random() - 0.5) * 20, level: Math.floor(Math.random() * 3) + 1 });
            }
        }

        function compressState(state) {
            return {
                mode: state.mode,
                shakeIntensity: Math.round(state.shakeIntensity),
                food: state.food.map((f) => ({ x: Math.round(f.x), y: Math.round(f.y), l: f.level, g: f.isGolden ? 1 : 0 })),
                mines: state.mines.map((m) => ({ x: Math.round(m.x), y: Math.round(m.y), state: m.state, type: m.type })),
                explosions: state.explosions.map((e) => ({
                    x: Math.round(e.x), y: Math.round(e.y), radius: Math.round(e.radius), alpha: Number(e.alpha.toFixed(2))
                })),
                syrupZones: state.syrupZones.map((s) => ({ x: Math.round(s.x), y: Math.round(s.y), radius: s.radius, oid: s.ownerId })),
                players: state.players.map((p) => ({
                    id: p.id, active: p.active, dead: p.dead, x: Math.round(p.x), y: Math.round(p.y),
                    angle: Number(p.angle.toFixed(2)), scale: Number(p.scale.toFixed(2)), length: Math.round(p.length),
                    country: p.country, colorBody: p.colorBody, kills: p.kills, deaths: p.deaths,
                    frozenUntil: p.frozenUntil || 0, abilityActive: p.abilityActive || false, maplePhase: p.maplePhase, kingdomPhase: p.kingdomPhase, name: p.name
                })),
                enemies: state.enemies.map((e) => ({
                    alive: e.alive, color: e.color, width: Math.round(e.width), x: Math.round(e.x), y: Math.round(e.y),
                    angle: Number(e.angle.toFixed(2)), frozenUntil: e.frozenUntil || 0
                })),
            };
        }

        // -------------------------------------------------------------------------
        // RENDER LOOP
        // -------------------------------------------------------------------------
        function loop(timestamp) {
            requestAnimationFrame(loop);

            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            if (currentState.menu !== 'playing' && currentState.menu !== 'death') {
                ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "rgba(0, 47, 108, 0.2)"; ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
                for (let j = 0; j < canvas.height; j += 50) { ctx.beginPath(); ctx.moveTo(0, j); ctx.lineTo(canvas.width, j); ctx.stroke(); }
                return;
            }

            // Logic Updates
            if (currentState.isHost) {
                if (timestamp % 1000 < 16 && gameData.players[0] && !gameData.players[0].dead) {
                    updateStats({ scale: gameData.players[0].scale, length: gameData.players[0].length });
                }
                updateHostLogic();
                if (timestamp - lastSentTime > BROADCAST_RATE) {
                    const payload = { type: "STATE", state: compressState(gameData) };
                    connections.forEach(c => { if (c.open) c.send(payload); });
                    lastSentTime = timestamp;
                }
            } else if (currentState.isSpectating && serverState) {
                const t = INTERPOLATION_SPEED;
                const cur = gameData; 
                const tar = serverState;
                
                cur.food = tar.food.map(f => ({x:f.x, y:f.y, level:f.l, isGolden: f.g===1}));
                cur.mines = tar.mines;
                cur.explosions = tar.explosions;
                cur.syrupZones = (tar.syrupZones||[]).map(s => ({x:s.x, y:s.y, radius:s.radius, ownerId:s.oid}));
                cur.shakeIntensity = tar.shakeIntensity;

                cur.players.forEach((p, i) => {
                    const tp = tar.players[i];
                    if (tp) {
                        p.x = lerp(p.x, tp.x, t); p.y = lerp(p.y, tp.y, t);
                        p.angle = lerpAngle(p.angle, tp.angle, t);
                        p.scale = tp.scale; p.country = tp.country; p.dead = tp.dead;
                        p.name = tp.name; p.abilityActive = tp.abilityActive; p.maplePhase = tp.maplePhase; p.kingdomPhase = tp.kingdomPhase;
                        if (!p.body) p.body = [];
                        p.body.unshift({ x: p.x, y: p.y });
                        while (p.body.length > tp.length) p.body.pop();
                    }
                });

                if (cur.enemies.length !== tar.enemies.length) cur.enemies = tar.enemies.map((e) => ({ ...e, body: [] }));
                cur.enemies.forEach((e, i) => {
                     const te = tar.enemies[i];
                     if(te) {
                         e.x = lerp(e.x, te.x, t); e.y = lerp(e.y, te.y, t);
                         e.alive = te.alive; e.width = te.width; e.color = te.color;
                         if (e.alive) {
                            e.body.unshift({ x: e.x, y: e.y });
                            while (e.body.length > 140) e.body.pop();
                         }
                     }
                 });
            }

            const me = gameData.players[0] || {};
            if(!currentState.isSpectating) {
                document.getElementById('hud-size').innerText = "Size: " + (me.scale || 18).toFixed(1);
                document.getElementById('hud-kills').innerText = "Kills: " + (me.kills || 0);
            }

            // Ability HUD
            const abInd = document.getElementById('ability-indicator');
            const abTxt = document.getElementById('ability-text');
            if(me.country === 'soviet' || me.country === 'golden_maple' || me.country === 'bosnian_kingdom') {
                abInd.style.display = 'flex';
                let cooldown = 60000;
                if (me.country === 'bosnian_kingdom') cooldown = 30000;

                const timeSince = Date.now() - (me.lastAbilityTime || 0);
                const isActive = me.barrageActive || !!me.maplePhase || (me.kingdomPhase === "active");
                
                if (isActive) {
                    abTxt.innerText = "ACTIVE";
                    abInd.style.borderColor = (Math.floor(Date.now()/200)%2===0) ? "#fff" : "#0f0";
                    abTxt.style.color = "#0f0";
                } else if (timeSince < cooldown) {
                    abTxt.innerText = Math.ceil((cooldown - timeSince)/1000) + "s";
                    abInd.style.borderColor = "#555";
                    abTxt.style.color = "#aaa";
                } else {
                    abTxt.innerText = "READY";
                    abInd.style.borderColor = "#FFD700";
                    abTxt.style.color = "#FFD700";
                }
            } else {
                abInd.style.display = 'none';
            }

            // --- DRAWING ---
            ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "rgba(0, 47, 108, 0.2)"; ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
            for (let j = 0; j < canvas.height; j += 50) { ctx.beginPath(); ctx.moveTo(0, j); ctx.lineTo(canvas.width, j); ctx.stroke(); }

            let sx = 0, sy = 0;
            if (gameData.shakeIntensity > 0) {
                sx = (Math.random() - 0.5) * gameData.shakeIntensity;
                sy = (Math.random() - 0.5) * gameData.shakeIntensity;
                gameData.shakeIntensity *= 0.9;
            }

            ctx.save();
            ctx.translate(canvas.width / 2 + sx, canvas.height / 2 + sy);
            const focus = currentState.isSpectating ? (gameData.players[0] || {x:0, y:0, scale:18}) : me;
            const startScale = 18;
            const zoom = Math.max(0.1, 0.6 * (30 / (30 + ((focus.scale || 18) - startScale) * 0.4)));
            ctx.scale(zoom, zoom);
            ctx.translate(-focus.x, -focus.y);

            ctx.lineWidth = 12; ctx.strokeStyle = "rgba(255,0,0,0.9)";
            ctx.strokeRect(-WORLD_SIZE / 2, -WORLD_SIZE / 2, WORLD_SIZE, WORLD_SIZE);

            if (me.country === "ireland" && !me.dead) {
                 ctx.save();
                 ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
                 ctx.lineWidth = 2;
                 ctx.setLineDash([10, 10]);
                 gameData.enemies.forEach(e => {
                     if (e.alive) {
                         ctx.beginPath();
                         ctx.moveTo(me.x, me.y);
                         ctx.lineTo(e.x, e.y);
                         ctx.stroke();
                     }
                 });
                 ctx.restore();
            }

            gameData.syrupZones.forEach((z) => {
                ctx.fillStyle = "rgba(184, 134, 11, 0.5)"; ctx.beginPath(); ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = "#DAA520"; ctx.lineWidth = 4; ctx.stroke();
            });

            gameData.food.forEach((f) => {
                const level = f.level || 1;
                const size = FOOD_RADIUS_BASE + level * 1.5;
                if (f.isGolden) { ctx.fillStyle = "#FFD700"; ctx.shadowColor = "#FFD700"; ctx.shadowBlur = 10; }
                else { ctx.fillStyle = "orange"; ctx.shadowBlur = 0; }
                ctx.beginPath(); ctx.arc(f.x, f.y, size, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                if (level > 8) {
                    ctx.globalAlpha = 0.3; ctx.fillStyle = "white"; ctx.beginPath();
                    ctx.arc(f.x, f.y, size + 3, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0;
                }
            });

            // MINES RENDER (FIXED WITH TRANSLATE)
            gameData.mines.forEach((m) => {
                if (m.state === "triggered" && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.beginPath(); ctx.arc(m.x, m.y, 200, 0, Math.PI * 2); ctx.fill();
                }
                const r = 25; const d = r * 2;
                
                if (m.type === "bosnian") {
                    ctx.save();
                    ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.clip();
                    ctx.fillStyle = "#002395"; ctx.fillRect(m.x-r, m.y-r, r*2, r*2);
                    ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(m.x, m.y, r/2, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                    ctx.strokeStyle = m.state === "triggered" ? "red" : "#FFD700"; 
                    ctx.lineWidth = 3; 
                    ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.stroke();
                } else {
                    // TRANSLATE FIX FOR HOLE GLITCH
                    ctx.save(); 
                    ctx.translate(m.x, m.y); // Center grid on mine
                    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.clip();
                    
                    // Flag
                    ctx.fillStyle = "#C6363C"; ctx.fillRect(-r, -r, d, d / 3);
                    ctx.fillStyle = "#0C4076"; ctx.fillRect(-r, -r + d / 3, d, d / 3);
                    ctx.fillStyle = "#FFFFFF"; ctx.fillRect(-r, -r + (2 * d) / 3, d, d / 3);
                    
                    // Skull (Relative to 0,0)
                    ctx.fillStyle = "white"; ctx.beginPath();
                    ctx.moveTo(-10, -10); ctx.lineTo(0, -10); ctx.lineTo(0, 5);
                    ctx.lineTo(-5, 12); ctx.lineTo(-10, 5); ctx.fill();
                    
                    ctx.restore();
                    ctx.strokeStyle = m.state === "triggered" ? "red" : "#333"; 
                    ctx.lineWidth = 2; 
                    ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.stroke();
                }
            });

            const allEntities = [...gameData.players, ...gameData.enemies];
            allEntities.forEach((p) => {
                if (p.dead || p.alive === false) return;

                if (p.frozenUntil && Date.now() < p.frozenUntil) { ctx.shadowBlur = 15; ctx.shadowColor = "cyan"; }
                else if (p.country === "soviet" && p.abilityActive) { ctx.shadowBlur = 30; ctx.shadowColor = "#FF0000"; }
                else if (p.country === "golden_maple" && p.maplePhase === "harvest") {
                    ctx.shadowBlur = 40; ctx.shadowColor = "#DAA520";
                    ctx.strokeStyle = "rgba(218, 165, 32, 0.4)"; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(p.x, p.y, 5 * CELL, 0, Math.PI * 2); ctx.stroke();
                }

                if (p.country === "bosnian_kingdom" && p.kingdomPhase === "active") {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 300, 0, Math.PI*2);
                    ctx.strokeStyle = "rgba(0, 35, 149, 0.6)";
                    ctx.lineWidth = 10;
                    ctx.stroke();
                    ctx.fillStyle = "rgba(0, 35, 149, 0.2)";
                    ctx.fill();
                    ctx.restore();
                }

                const bodyW = p.scale || p.width || 12;
                ctx.lineWidth = bodyW * 1.2;
                ctx.strokeStyle = (p.frozenUntil && Date.now() < p.frozenUntil) ? "cyan" : (p.colorBody || p.color || "white");
                ctx.lineCap = "round"; ctx.lineJoin = "round";
                ctx.beginPath();
                if (p.body.length) {
                    ctx.moveTo(p.body[0].x, p.body[0].y);
                    p.body.forEach(b => ctx.lineTo(b.x, b.y));
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                const r = bodyW * 0.65;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle + Math.PI / 2);
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.clip();

                drawFlag(ctx, p.country, r, p.color);

                ctx.restore();
                
                if(p.name && zoom > 0.3) {
                     ctx.fillStyle = "white"; 
                     ctx.font = `bold ${Math.max(12, r)}px Arial`; 
                     ctx.textAlign = "center";
                     ctx.fillText(p.name, p.x, p.y - r - 10);
                }
            });

            gameData.explosions.forEach((ex) => {
                ctx.fillStyle = `rgba(255,69,0,${ex.alpha})`; ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2); ctx.fill();
            });

            ctx.restore();
        }

        // -------------------------------------------------------------------------
        // FLAG DRAWING
        // -------------------------------------------------------------------------
        function drawFlag(ctx, country, r, fallbackColor) {
            const rect = (x, y, w, h, c) => { ctx.fillStyle = c; ctx.fillRect(x, y, w, h); };

            if (!country) { ctx.fillStyle = fallbackColor || "white"; ctx.fillRect(-r, -r, r * 2, r * 2); return; }

            if (country === 'bosnia') {
                rect(-r, -r, r * 2, r * 2, "#002F6C");
                ctx.fillStyle = "#FECB00"; ctx.beginPath(); ctx.moveTo(r * 0.2, -r); ctx.lineTo(r * 0.2, r); ctx.lineTo(r, -r * 0.5); ctx.fill();
                ctx.fillStyle = "white";
                for (let i = 0; i < 5; i++) { ctx.beginPath(); ctx.arc(-r * 0.2, -r * 0.6 + i * r * 0.4, r * 0.1, 0, Math.PI * 2); ctx.fill(); }
            }
            else if (country === 'bosnian_kingdom') {
                rect(-r, -r, r * 2, r * 2, "#002395");
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.moveTo(-r, -r); ctx.lineTo(r, r); 
                ctx.lineTo(r, r-r/2); ctx.lineTo(-r+r/2, -r); 
                ctx.fill();
                ctx.fillStyle = "#FFD700";
                ctx.beginPath(); ctx.arc(-r/2, r/2, r/4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(r/2, -r/2, r/4, 0, Math.PI*2); ctx.fill();
            }
            else if (country === 'russia') {
                rect(-r, -r, r * 2, (r * 2) / 3, "white");
                rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#0039A6");
                rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "#D52B1E");
            }
            else if (country === 'croatia') {
                rect(-r, -r, r*2, (r*2)/3, "red");
                rect(-r, -r+(r*2)/3, r*2, (r*2)/3, "white");
                rect(-r, -r+4*r/3, r*2, (r*2)/3, "blue");
                ctx.fillStyle = "red";
                ctx.fillRect(-r/2, -r/2, r, r);
                ctx.fillStyle = "white";
                for(let y=0; y<2; y++) for(let x=0; x<2; x++) {
                   if((x+y)%2===0) ctx.fillRect(-r/2 + x*(r/2), -r/2 + y*(r/2), r/2, r/2);
                }
            }
            else if (country === 'serbia') {
                rect(-r, -r, r * 2, (r * 2) / 3, "#C6363C"); 
                rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#0C4076"); 
                rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "white"); 
            }
            else if (country === 'germany') {
                rect(-r, -r, r * 2, (r * 2) / 3, "black");
                rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#DD0000");
                rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "#FFCC00");
            }
            else if (country === 'france') {
                rect(-r, -r, (r * 2) / 3, r * 2, "#0055A4");
                rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "white");
                rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#EF4135");
            }
            else if (country === 'italy') {
                rect(-r, -r, (r * 2) / 3, r * 2, "#008C45");
                rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "white");
                rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#CD212A");
            }
            else if (country === 'ireland') {
                rect(-r, -r, (r * 2) / 3, r * 2, "#169B62"); 
                rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "#FFFFFF"); 
                rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#FF883E"); 
            }
            else if (country === 'ukraine') {
                rect(-r, -r, r * 2, r, "#0057B8");
                rect(-r, 0, r * 2, r, "#FFD700");
            }
            else if (country === 'poland') {
                rect(-r, -r, r * 2, r, "white");
                rect(-r, 0, r * 2, r, "#DC143C");
            }
            else if (country === 'canada') {
                rect(-r, -r, (r * 2) / 4, r * 2, "#FF0000");
                rect(-r + (r * 2) / 4, -r, r, r * 2, "white");
                rect(r / 2, -r, (r * 2) / 4, r * 2, "#FF0000");
                ctx.fillStyle = "#FF0000"; ctx.beginPath(); ctx.moveTo(0, -r * 0.4); ctx.lineTo(r * 0.3, 0); ctx.lineTo(0, r * 0.4); ctx.lineTo(-r * 0.3, 0); ctx.fill();
            }
            else if (country === 'usa') {
                rect(-r, -r, r * 2, r * 2, "white");
                for (let i = 0; i < 7; i++) rect(-r, -r + (i * 2 * r / 7), r * 2, r / 7, "#B22234");
                rect(-r, -r, r, r * 0.8, "#3C3B6E");
                ctx.fillStyle = "white";
                for (let py = 0; py < 3; py++) for (let px = 0; px < 4; px++) {
                    ctx.beginPath(); ctx.arc(-r + 5 + px * (r / 4), -r + 5 + py * (r / 4), 2, 0, Math.PI * 2); ctx.fill();
                }
            }
            else if (country === 'soviet') {
                rect(-r, -r, r * 2, r * 2, "#CC0000");
                ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(-r * 0.4, -r * 0.4, r * 0.25, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = "#FFD700"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-r * 0.4, -r * 0.2, r * 0.2, 0, Math.PI); ctx.stroke();
            }
            else if (country === 'golden_maple') {
                rect(-r, -r, r*2, r*2, "white"); 
                rect(-r, -r, (r*2)/4, r*2, "#FFFF00"); 
                rect(r/2, -r, (r*2)/4, r*2, "#FFFF00"); 
                ctx.fillStyle = "#FFFF00"; 
                ctx.beginPath(); ctx.moveTo(0, -r * 0.4); ctx.lineTo(r * 0.3, 0); ctx.lineTo(0, r * 0.4); ctx.lineTo(-r * 0.3, 0); ctx.fill();
            }
            else if (country === 'sweden') {
                rect(-r, -r, r * 2, r * 2, "#006AA7");
                rect(-r, -r * 0.2, r * 2, r * 0.4, "#FECC00");
                rect(-r * 0.2, -r, r * 0.4, r * 2, "#FECC00");
            }
            else if (country === 'denmark') {
                rect(-r, -r, r * 2, r * 2, "#C60C30");
                rect(-r, -r * 0.2, r * 2, r * 0.4, "white");
                rect(-r * 0.2, -r, r * 0.4, r * 2, "white");
            }
            else if (country === 'uk') {
                rect(-r, -r, r * 2, r * 2, "#012169");
                rect(-r, -r * 0.3, r * 2, r * 0.6, "white");
                rect(-r * 0.3, -r, r * 0.6, r * 2, "white");
                rect(-r, -r * 0.15, r * 2, r * 0.3, "#C8102E");
                rect(-r * 0.15, -r, r * 0.3, r * 2, "#C8102E");
            }
            else {
                rect(-r, -r, r * 2, r * 2, fallbackColor || "#333");
            }
        }

        // -------------------------------------------------------------------------
        // UI & EVENT LISTENERS
        // -------------------------------------------------------------------------
        async function submitScoreToLeaderboard(scale) {
            const size = parseFloat(scale.toFixed(2));
            if (size < 20 || !authReady) return;
            try {
                const lbRef = collection(db, "leaderboard");
                const q = query(lbRef, where("name", "==", currentState.playerName));
                const snap = await getDocs(q);
                if (snap.empty) {
                    await addDoc(lbRef, { name: currentState.playerName, size: size, timestamp: serverTimestamp() });
                } else {
                    const d = snap.docs[0];
                    if (size > d.data().size) updateDoc(doc(db, "leaderboard", d.id), { size: size });
                }
            } catch (e) { console.error("Leaderboard Error", e); }
        }

        async function startScanner() {
            const scan = async () => {
                if(!authReady) return;
                try {
                    const q = query(collection(db, "active_games"), orderBy("lastBeat", "desc"), limit(20));
                    const snap = await getDocs(q);
                    const list = document.getElementById('spectate-list');
                    list.innerHTML = '';
                    document.getElementById('scan-status').innerText = "";
                    let found = 0;
                    const now = Date.now();

                    snap.docs.forEach(doc => {
                        const data = doc.data();
                        if (data.lastBeat && (now - data.lastBeat.toMillis() < 30000)) {
                            found++;
                            const row = document.createElement('div');
                            row.className = 'spectate-row';
                            row.innerHTML = `<div><b>${data.host}</b></div><div style="background:#28a745; padding:3px 6px; border-radius:3px; font-size:10px; color:white;">SPECTATE</div>`;
                            row.onclick = () => initSpectate(doc.id);
                            list.appendChild(row);
                        }
                    });
                    if (found === 0) list.innerHTML = '<div style="color:#666; font-size:12px; font-style:italic; padding:10px;">No active games found. Start one!</div>';
                } catch(e) { console.warn("Scanner error", e); }
            };
            scan();
            setInterval(scan, 10000);

            try {
                onSnapshot(query(collection(db, "leaderboard"), orderBy("size", "desc"), limit(5)), (snap) => {
                    const div = document.getElementById('leaderboard-content');
                    div.innerHTML = '';
                    snap.docs.forEach((d, i) => {
                        const r = document.createElement('div');
                        r.className = 'row';
                        r.innerHTML = `<span style="color:${i === 0 ? '#FECB00' : 'white'}">${i + 1}. ${d.data().name}</span> <span style="color:#4caf50">${Math.round(d.data().size)}</span>`;
                        div.appendChild(r);
                    });
                });
            } catch(e) { console.log("LB pending"); }
        }

        function addChatMessage(name, text, color) {
            const container = document.getElementById('chat-messages');
            const el = document.createElement('div');
            el.className = 'chat-line';
            el.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}: </span>${text}`;
            container.appendChild(el);
            if (container.children.length > 9) container.removeChild(container.firstChild);
        }

        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            keys[k] = true;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            if (document.activeElement === document.getElementById('chat-input') && k !== 'escape') return;

            if (e.key === '`' || e.key === '~') {
                e.preventDefault();
                if (showOwnerPanel) {
                    showOwnerPanel = false;
                    document.getElementById('owner-control-panel').style.display = 'none';
                } else {
                    showOwnerLogin = !showOwnerLogin;
                    document.getElementById('owner-login-panel').style.display = showOwnerLogin ? 'block' : 'none';
                    if(showOwnerLogin) document.getElementById('owner-password').focus();
                }
            }
        });

        window.addEventListener('keyup', e => {
            if (document.activeElement === document.getElementById('chat-input')) return;
            keys[e.key.toLowerCase()] = false;
        });
        
        window.addEventListener('mousemove', e => { 
            mouse.x = e.clientX; 
            mouse.y = e.clientY; 
        });

        window.addEventListener('resize', () => {
             canvas.width = window.innerWidth;
             canvas.height = window.innerHeight;
        });

        document.getElementById('btn-play').onclick = initSinglePlayer;
        document.getElementById('btn-mouse').onclick = () => {
            currentState.controlMode = 'mouse';
            document.getElementById('btn-mouse').classList.add('active');
            document.getElementById('btn-keyboard').classList.remove('active');
        };
        document.getElementById('btn-keyboard').onclick = () => {
            currentState.controlMode = 'keyboard';
            document.getElementById('btn-keyboard').classList.add('active');
            document.getElementById('btn-mouse').classList.remove('active');
        };
        document.getElementById('cat-normal').onclick = () => {
            currentState.skinCategory = 'normal';
            document.getElementById('cat-normal').classList.add('active');
            document.getElementById('cat-special').classList.remove('active');
            renderSkinGrid();
        };
        document.getElementById('cat-special').onclick = () => {
            currentState.skinCategory = 'special';
            document.getElementById('cat-special').classList.add('active');
            document.getElementById('cat-normal').classList.remove('active');
            renderSkinGrid();
        };
        document.getElementById('nickname-input').oninput = (e) => {
            currentState.playerName = e.target.value;
            localStorage.setItem('bosnia_snake_username', e.target.value);
        };
        document.getElementById('nickname-input').value = currentState.playerName;

        document.getElementById('btn-redeem').onclick = () => {
            const code = document.getElementById('redeem-input').value;
            if (code === "Ireland_isgreat") {
                if(!isSkinUnlocked('ireland')) {
                    updateStats({ unlockSecret: "ireland" });
                    alert("SUCCESS: Ireland Skin Unlocked!");
                    renderSkinGrid();
                } else alert("Already Unlocked");
            } 
            else alert("Invalid Code");
        };

        document.getElementById('chat-input').onkeydown = (e) => {
            if (e.key === 'Enter') {
                const text = e.target.value;
                if (text.trim()) {
                    if (currentState.isHost) {
                        const msg = { name: currentState.playerName, text: text, color: "#FECB00" };
                        addChatMessage(msg.name, msg.text, msg.color);
                        playSound("chat");
                        broadcastChat(msg);
                    } else if (hostConn && hostConn.open) {
                        hostConn.send({ type: "CHAT", name: currentState.playerName, text: text });
                        addChatMessage(currentState.playerName, text, "#fff");
                    }
                }
                e.target.value = '';
                document.getElementById('game-canvas').focus();
            }
        };

        document.getElementById('btn-owner-login').onclick = () => {
            const pass = document.getElementById('owner-password').value;
            if(pass === OWNER_PASSWORD) {
                showOwnerLogin = false;
                document.getElementById('owner-login-panel').style.display = 'none';
                showOwnerPanel = true;
                document.getElementById('owner-control-panel').style.display = 'block';
                document.getElementById('cheat-msg').innerText = "ACCESS GRANTED";
            } else {
                alert("ACCESS DENIED");
            }
        };
        
        const setCheatMsg = (txt) => {
            const el = document.getElementById('cheat-msg');
            el.innerText = txt;
            setTimeout(() => el.innerText = '', 2000);
        };

        document.getElementById('cheat-god').onclick = () => {
            cheats.godMode = !cheats.godMode;
            document.getElementById('cheat-god').innerText = "God Mode: " + (cheats.godMode ? "ON" : "OFF");
            setCheatMsg("God Mode " + (cheats.godMode ? "Enabled" : "Disabled"));
        };
        document.getElementById('cheat-speed').onclick = () => {
            cheats.speedHack = !cheats.speedHack;
            document.getElementById('cheat-speed').innerText = "Speed Hack: " + (cheats.speedHack ? "ON" : "OFF");
            setCheatMsg("Speed " + (cheats.speedHack ? "Boosted" : "Normal"));
        };
        document.getElementById('cheat-size').onclick = () => {
            if(gameData.players[0]) {
                gameData.players[0].scale = 50;
                gameData.players[0].length = 500;
                setCheatMsg("Size Set to 50");
            }
        };
        document.getElementById('cheat-killbots').onclick = () => {
            gameData.enemies.forEach(e => { if(e.alive) killEnemy(e, null); });
            setCheatMsg("Bots Cleared");
        };
        document.getElementById('cheat-reset').onclick = () => {
            resetWorld(true);
            setCheatMsg("World Reset");
        };

        function renderSkinGrid() {
            const grid = document.getElementById('skin-grid');
            grid.innerHTML = '';
            const list = currentState.skinCategory === 'normal' ? SKINS_NORMAL : SKINS_SPECIAL;

            list.forEach(skin => {
                const unlocked = isSkinUnlocked(skin);
                const req = UNLOCK_CRITERIA[skin] || { label: "Locked" };
                const div = document.createElement('div');
                div.className = `skin-tile ${currentState.selectedSkin === skin ? 'selected' : ''} ${!unlocked ? 'locked' : ''}`;
                div.innerHTML = `
                    <div class="skin-color-dot" style="background: ${SKIN_BODY_COLORS[skin]}"></div>
                    <div style="font-size: 11px; font-weight: bold; text-transform: uppercase; color: ${unlocked ? 'white' : '#888'}">${skin.replace('_', ' ')}</div>
                    ${!unlocked ? `<div class="lock-text"> ${req.label}</div>` : ''}
                `;
                div.onclick = () => {
                    if (unlocked) {
                        currentState.selectedSkin = skin;
                        renderSkinGrid();
                    }
                };
                grid.appendChild(div);
            });
        }

        // -------------------------------------------------------------------------
        // STARTUP
        // -------------------------------------------------------------------------
        updateStatsUI();
        renderSkinGrid();
        requestAnimationFrame(loop);

    </script>
</body>
</html>
