``html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bosnia Snake: Leveling Update</title>
    <!-- PeerJS for Multiplayer Networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <style>
        /* --- GLOBAL STYLES --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #080b12;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI LAYER WRAPPER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        /* --- HEADS UP DISPLAY (HUD) --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 240px;
            height: 95px; /* Taller for XP */
            background: rgba(0, 15, 60, 0.7);
            border: 2px solid #0055A4;
            border-radius: 10px;
            display: none; /* Hidden on start */
            flex-direction: column;
            justify-content: center;
            padding: 10px 15px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 85, 164, 0.4);
        }

        #hud-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
        }

        #hud-size { 
            font-weight: bold; 
            font-size: 22px; 
            text-shadow: 1px 1px 2px black;
        }

        #hud-kills { 
            font-weight: bold; 
            font-size: 16px; 
            color: #FECB00; 
            text-shadow: 1px 1px 2px black;
        }

        /* --- XP BAR --- */
        #xp-container {
            width: 100%;
            height: 10px;
            background: #222;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #555;
            position: relative;
        }
        #xp-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            transition: width 0.3s ease-out;
        }
        #xp-text {
            position: absolute;
            top: -2px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 8px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
            line-height: 12px;
        }
        #level-badge {
            font-size: 12px;
            color: cyan;
            font-weight: bold;
            margin-top: 4px;
            text-align: center;
            display: flex;
            justify-content: space-between;
        }
        #active-buffs {
            font-size: 9px;
            color: #0f0;
            text-align: right;
        }

        /* --- ABILITY INDICATOR (For Special Skins) --- */
        #ability-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(0,0,0,0.6);
            border-radius: 50%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 4px solid #555;
            transition: border-color 0.3s;
        }
        #ability-text {
            font-weight: bold;
            font-size: 14px;
            color: white;
        }
        #ability-sub {
            font-size: 10px;
            color: #ddd;
        }

        /* --- SPECTATOR LABEL --- */
        #spectator-label {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 0px 0px 5px black;
            display: none;
            color: cyan;
            letter-spacing: 2px;
        }

        /* --- MENU SYSTEM --- */
        #menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 15px;
            height: 700px;
            pointer-events: auto;
            z-index: 20;
        }

        .panel {
            background: rgba(0, 15, 60, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid #FECB00;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(0, 47, 108, 0.5);
            display: flex;
            flex-direction: column;
            padding: 25px;
        }

        #stats-panel {
            width: 240px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #leaderboard-panel {
            width: 250px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #main-menu {
            width: 520px;
            overflow-y: auto;
            position: relative;
        }

        h1 {
            font-size: 50px;
            font-weight: 900;
            text-align: center;
            margin: 0 0 30px 0;
            color: #fff;
            text-shadow: 2px 2px 0px #002F6C, 0 0 15px #FECB00;
        }

        .header-text {
            color: #FECB00;
            font-size: 18px;
            font-weight: 900;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-bottom: 2px solid #002F6C;
            padding-bottom: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* --- FORM ELEMENTS --- */
        input[type="text"], input[type="password"] {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: white;
            font-size: 16px;
            width: 100%;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 15px;
            outline: none;
            box-sizing: border-box;
            transition: background 0.2s, border 0.2s;
        }
        input[type="text"]:focus, input[type="password"]:focus {
            background: rgba(255,255,255,0.2);
            border-color: #FECB00;
        }

        button {
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn-primary {
            width: 100%;
            padding: 18px;
            background: linear-gradient(to right, #002F6C, #0055A4);
            color: white;
            font-size: 16px;
            margin-top: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        }
        .btn-primary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0,0,0,0.3);
        }

        .btn-redeem {
            width: 100%;
            padding: 10px;
            background: linear-gradient(to right, #C6363C, #800000);
            color: white;
            font-size: 12px;
            margin-top: 5px;
        }

        .btn-toggle {
            flex: 1;
            padding: 12px;
            background: #222;
            color: #888;
        }
        .btn-toggle.active {
            background: #FECB00;
            color: black;
            box-shadow: 0 0 10px #FECB00;
        }

        /* --- SKIN GRID --- */
        #skin-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            overflow-y: auto;
            flex: 1;
            margin-bottom: 20px;
            min-height: 250px;
            padding-right: 5px;
        }

        .skin-tile {
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
        }
        .skin-tile:hover {
            background: rgba(255,255,255,0.1);
        }
        .skin-tile.selected {
            background: rgba(254, 203, 0, 0.2);
            border-color: #FECB00;
            box-shadow: 0 0 10px rgba(254, 203, 0, 0.2);
        }
        .skin-tile.locked {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .skin-color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.8);
            margin-bottom: 8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .lock-text {
            font-size: 9px;
            color: #ff5555;
            font-weight: bold;
            margin-top: 5px;
            text-align: center;
            text-transform: uppercase;
        }

        /* --- CHAT SYSTEM --- */
        #chat-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 320px;
            height: 250px;
            display: none;
            flex-direction: column;
            pointer-events: auto;
            z-index: 100;
        }
        #chat-messages {
            flex: 1;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
            padding-right: 5px;
        }
        .chat-line {
            font-size: 14px;
            margin-bottom: 4px;
            background: rgba(0,0,0,0.4);
            padding: 4px 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }
        #chat-input {
            background: rgba(0,0,0,0.6);
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 4px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
            pointer-events: auto;
        }

        /* --- SPECTATE LIST --- */
        #spectate-list {
            max-height: 140px;
            overflow-y: auto;
        }
        .spectate-row {
            padding: 12px;
            background: #222;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        .spectate-row:hover { background: #333; }
        
        .server-official {
            border: 1px solid #FECB00;
            background: rgba(254, 203, 0, 0.1);
        }

        /* --- DEATH SCREEN --- */
        #death-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            pointer-events: none;
            z-index: 50;
        }
        .death-title {
            font-size: 60px;
            font-weight: 900;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
        }
        .death-sub {
            font-size: 24px;
            color: #ccc;
            text-shadow: 1px 1px 0 #000;
        }

        /* --- OWNER / CHEAT PANELS --- */
        #owner-login-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border: 2px solid red;
            z-index: 999;
            display: none;
            width: 300px;
            box-shadow: 0 0 50px red;
            text-align: center;
            pointer-events: auto;
        }
        #owner-control-panel {
            position: absolute;
            top: 60px;
            left: 10px;
            width: 180px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border: 2px solid red;
            color: white;
            z-index: 999;
            display: none;
            box-shadow: 0 0 20px red;
            pointer-events: auto;
        }
        .cheat-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: #330000;
            color: red;
            border: 1px solid red;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
        }
        .cheat-btn:hover {
            background: red;
            color: black;
        }
        #cheat-msg {
            text-align: center;
            color: cyan;
            font-weight: bold;
            margin-top: 10px;
            font-size: 12px;
            height: 20px;
        }

        #btn-admin-open {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 10px;
            padding: 5px 10px;
            background: #333;
            color: #555;
            border: 1px solid #444;
            cursor: pointer;
            pointer-events: auto;
        }
        #btn-admin-open:hover {
            color: red;
            border-color: red;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        ::-webkit-scrollbar-thumb { background: #FECB00; border-radius: 3px; }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer">
        
        <!-- GAME HUD -->
        <div id="hud">
            <div id="hud-top-row">
                <div id="hud-size">Size: 18.0</div>
                <div id="hud-kills">Kills: 0</div>
            </div>
            <!-- XP BAR -->
            <div id="xp-container">
                <div id="xp-fill"></div>
                <div id="xp-text">0 / 300 XP</div>
            </div>
            <div id="level-badge">
                <span>LEVEL 1</span>
                <span id="active-buffs"></span>
            </div>
        </div>

        <!-- ABILITY HUD -->
        <div id="ability-indicator">
            <div id="ability-text">READY</div>
            <div id="ability-sub">ABILITY</div>
        </div>

        <div id="spectator-label">SPECTATOR MODE</div>

        <!-- MENU CONTAINER -->
        <div id="menu-container">
            <!-- Left Stats -->
            <div id="stats-panel" class="panel">
                <div class="header-text">Stats</div>
                <div class="row"><span>LEVEL</span><span id="stat-level" style="color: cyan">1</span></div>
                <div class="row"><span>KILLS</span><span id="stat-kills" style="color: #FECB00">0</span></div>
                <div class="row"><span>DEATHS</span><span id="stat-deaths" style="color: #FECB00">0</span></div>
                <div class="row"><span>BEST SIZE</span><span id="stat-best-size" style="color: #FECB00">18.0</span></div>
                <div class="row"><span>GAMES</span><span id="stat-games" style="color: #FECB00">0</span></div>
                <div class="row"><span>MAX MINES</span><span id="stat-mines" style="color: #FECB00">0</span></div>
                <div class="row"><span>MAX LENGTH</span><span id="stat-length" style="color: #FECB00">140</span></div>
                
                <div style="margin-top: auto; padding-top: 15px; border-top: 1px solid #333;">
                    <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">SECRET CODE</div>
                    <input type="text" id="redeem-input" style="font-size: 12px; padding: 10px; margin-bottom: 8px;" placeholder="Enter Code...">
                    <button id="btn-redeem" class="btn-redeem">REDEEM CODE</button>
                </div>
            </div>

            <!-- Main Menu Center -->
            <div id="main-menu" class="panel">
                <h1>BOSNIA SNAKE</h1>

                <!-- Control Mode -->
                <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                    <button id="btn-mouse" class="btn-toggle active">MOUSE CONTROL</button>
                    <button id="btn-keyboard" class="btn-toggle">KEYBOARD CONTROL</button>
                </div>

                <!-- Skin Selection -->
                <div style="font-size: 12px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">SELECT SKIN</div>
                <div style="display: flex; margin-bottom: 10px; gap: 5px;">
                    <button id="cat-normal" class="btn-toggle active" style="padding: 8px; font-size: 12px;">NATIONAL</button>
                    <button id="cat-special" class="btn-toggle" style="padding: 8px; font-size: 12px;">SPECIAL / SECRET</button>
                </div>

                <div id="skin-grid"></div>

                <input type="text" id="nickname-input" placeholder="ENTER NICKNAME">
                <button id="btn-play" class="btn-primary">PLAY SOLO</button>

                <!-- Spectate List -->
                <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;">
                    <div style="color: #FECB00; font-weight: bold; margin-bottom: 10px; font-size: 14px;">
                        LIVE GAMES <span id="scan-status" style="font-size: 10px; color: #666; font-weight: normal;">(Scanning...)</span>
                    </div>
                    <div id="spectate-list">
                        <div style="color: #666; font-size: 12px; font-style: italic; padding: 10px;">Initializing scanner...</div>
                    </div>
                </div>
                
                <!-- Admin Button -->
                <button id="btn-admin-open">ADMIN LOGIN</button>
            </div>

            <!-- Leaderboard -->
            <div id="leaderboard-panel" class="panel">
                <div class="header-text">Top 5</div>
                <div id="leaderboard-content">
                    <div style="text-align: center; color: #888; margin-top: 20px;">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Chat -->
        <div id="chat-container">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Type to chat (Enter to send)...">
        </div>

        <!-- Death Screen -->
        <div id="death-screen">
            <div class="death-title">YOU DIED</div>
            <div class="death-sub">Press 'R' to Restart</div>
        </div>

        <!-- OWNER / CHEAT PANELS -->
        <div id="owner-login-panel">
            <div style="color:red; font-size:20px; font-weight:900; margin-bottom:15px; border-bottom:1px solid red; padding-bottom:10px;">ADMIN LOGIN</div>
            <input type="password" id="owner-password" placeholder="ENTER PASSWORD">
            <div style="display:flex; gap:10px;">
                <button id="btn-owner-close" style="width:50%; background:#222; color:#888; padding:10px;">CANCEL</button>
                <button id="btn-owner-login" style="width:50%; background:red; color:white; padding:10px;">LOGIN</button>
            </div>
        </div>

        <div id="owner-control-panel">
            <div style="text-align:center; margin-bottom:10px; border-bottom:1px solid red;">ADMIN CONTROLS</div>
            
            <button class="cheat-btn" id="cheat-host-server" style="background: gold; color: black; border-color: white;">HOST OFFICIAL SERVER</button>
            
            <div style="border-top: 1px solid #555; margin: 5px 0;"></div>
            
            <button class="cheat-btn" id="cheat-god">God Mode: OFF</button>
            <button class="cheat-btn" id="cheat-speed">Speed Hack: OFF</button>
            <button class="cheat-btn" id="cheat-size">Set Size 50</button>
            <button class="cheat-btn" id="cheat-killbots">Kill All Bots</button>
            <button class="cheat-btn" id="cheat-reset">Reset World</button>
            <div id="cheat-msg"></div>
        </div>

    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { 
            getFirestore, collection, query, orderBy, limit, onSnapshot, 
            addDoc, serverTimestamp, where, getDocs, updateDoc, doc, setDoc, deleteDoc 
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        const firebaseConfig = {
            apiKey: "AIzaSyDFtRTloB37SCPGacQSxjmcuSPOHTHutNk",
            authDomain: "bosniasnake.firebaseapp.com",
            projectId: "bosniasnake",
            storageBucket: "bosniasnake.firebasestorage.app",
            messagingSenderId: "246754109806",
            appId: "1:246754109806:web:c58a4820f26478b69ab97f",
            measurementId: "G-FFQ2PJ3X5W"
        };

        let app, db, auth;
        let authReady = false;

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            signInAnonymously(auth).then(() => {
                console.log("Connected to Firebase (Anonymous)");
                authReady = true;
                startScanner();
            }).catch(err => {
                console.error("Auth Error:", err);
                alert("Game Server Connection Failed: " + err.message);
            });
        } catch(e) {
            console.error("Firebase Init Failed", e);
        }

        const OWNER_PASSWORD = "Roblox13_isme";
        const CELL = 150;
        const GRID = 80;
        const WORLD_SIZE = CELL * GRID;
        const MIN_LENGTH = 140;
        const SPRINT_COST = 0.5;
        const BASE_SPEED = 4.2;
        const TURN_SPEED = 0.09;
        const MAX_ENEMIES = 8;
        const SIZE_GAIN_PER_LEVEL = 0.15;
        const FOOD_RADIUS_BASE = 6;
        const LENGTH_GAIN = 8;
        const BROADCAST_RATE = 45;
        const INTERPOLATION_SPEED = 0.35;
        const TWO_PI = Math.PI * 2; // Cached Math constant for lag reduction

        const SKINS_NORMAL = [
            "bosnia", "russia", "germany", "france", "canada", "ukraine", 
            "usa", "uk", "italy", "poland", "sweden", "denmark",
            "spain", "netherlands", "greece", "switzerland", "norway", "finland", "portugal",
            "turkey", "china" // Added new skins here
        ];
        const SKINS_SPECIAL = ["ireland", "soviet", "golden_maple", "bosnian_kingdom"];

        const SKIN_BODY_COLORS = {
            bosnia: "#002F6C", russia: "#FFFFFF", germany: "#000000", france: "#0055A4", 
            canada: "#FF0000", ukraine: "#0057B8", ireland: "#169B62", soviet: "#CC0000", 
            golden_maple: "#DAA520", bosnian_kingdom: "#002395",
            usa: "#3C3B6E", uk: "#012169", italy: "#008C45", 
            poland: "#DC143C", sweden: "#006AA7", denmark: "#C60C30", serbia: "#C6363C",
            croatia: "#CC0000",
            spain: "#AA151B", netherlands: "#FF8800", greece: "#0D5EAF",
            switzerland: "#FF0000", norway: "#BA0C2F", finland: "#FFFFFF", portugal: "#046A38",
            turkey: "#E30A17", china: "#DE2910" // Colors for Turkey and China
        };

        const UNLOCK_CRITERIA = {
            bosnia: { type: "default", label: "Default" },
            russia: { type: "scale", val: 100, label: "Size 100 (Motherland)" },
            germany: { type: "kills", val: 30, label: "Get 30 Kills" },
            france: { type: "deaths", val: 10, label: "Die 10 Times" },
            canada: { type: "length", val: 998, label: "Length 998 (Area)" },
            ukraine: { type: "kills", val: 15, label: "Get 15 Kills" },
            usa: { type: "scale", val: 76, label: "Size 76 (1776)" },
            uk: { type: "length", val: 1920, label: "Length 1920 (Empire)" },
            italy: { type: "length", val: 1000, label: "Eat 1k Food (Pasta)" },
            poland: { type: "deaths", val: 3, label: "Die 3 Times (Partitions)" },
            sweden: { type: "games", val: 20, label: "Play 20 Games" },
            denmark: { type: "length", val: 800, label: "Length 800 (Vikings)" },
            
            spain: { type: "scale", val: 80, label: "Size 80 (Empire)" },
            netherlands: { type: "length", val: 600, label: "Length 600 (Trade)" },
            greece: { type: "scale", val: 45, label: "Size 45 (History)" },
            switzerland: { type: "games", val: 10, label: "Play 10 Games (Neutral)" },
            norway: { type: "length", val: 1000, label: "Length 1000 (Vikings)" },
            finland: { type: "kills", val: 40, label: "Kills 40 (Sniper)" },
            portugal: { type: "length", val: 1143, label: "Length 1143 (Year)" },

            turkey: { type: "level", val: 4, label: "Reach Level 4" }, // LEVEL 4 REWARD
            china: { type: "level", val: 6, label: "Reach Level 6" },   // LEVEL 6 REWARD

            ireland: { type: "code", label: "Secret Code" },
            soviet: { type: "custom_soviet", label: "Russia + Size 500 + 50 Kills" },
            golden_maple: { type: "custom_maple", label: "Canada + Size 250 + 150 Kills" },
            bosnian_kingdom: { type: "custom_kingdom", label: "Bosnia + Size 271 + 40 Kills + 20 Mines (1 Game)" },
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (!audioCtx) return;
            if (audioCtx.state === "suspended") audioCtx.resume();
            const now = audioCtx.currentTime;
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);
            if (type === "eat") {
                const osc = audioCtx.createOscillator();
                osc.type = "sine"; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                osc.connect(gainNode); gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === "levelup") {
                const osc = audioCtx.createOscillator();
                osc.type = "square";
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.linearRampToValueAtTime(880, now + 0.3);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === "soviet_boom") {
                const bufferSize = audioCtx.sampleRate * 1.5; const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter(); filter.type = "lowpass"; filter.frequency.setValueAtTime(800, now); filter.frequency.exponentialRampToValueAtTime(10, now + 1);
                noise.connect(filter); filter.connect(gainNode); gainNode.gain.setValueAtTime(0.8, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1);
                noise.start(now); noise.stop(now + 1.5);
            } else if (type === "angelic") {
                const freqs = [523.25, 659.25, 783.99]; freqs.forEach((f, i) => { const osc = audioCtx.createOscillator(); osc.type = "triangle"; osc.frequency.value = f; if (i === 1) osc.detune.value = 5; if (i === 2) osc.detune.value = -5; osc.connect(gainNode); osc.start(now); osc.stop(now + 2.5); });
                gainNode.gain.setValueAtTime(0, now); gainNode.gain.linearRampToValueAtTime(0.08, now + 0.5); gainNode.gain.linearRampToValueAtTime(0, now + 2.5);
            } else if (type === "chat") {
                const osc = audioCtx.createOscillator(); osc.type = "sine"; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                osc.connect(gainNode); gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            }
        }

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let currentState = {
            menu: 'start',
            controlMode: 'mouse',
            skinCategory: 'normal',
            selectedSkin: 'bosnia',
            playerName: localStorage.getItem('bosnia_snake_username') || "Player" + Math.floor(Math.random() * 999),
            isHost: false,
            isSpectating: false,
            isPlayingClient: false,
            isDedicatedServer: false,
            myId: null,
            myPlayerIndex: 0
        };

        // --- UPDATED STATS FOR PROGRESSION ---
        let userStats = { 
            totalKills: 0, totalDeaths: 0, bestScale: 18, bestLength: 140, 
            gamesPlayed: 0, maxMinesInGame: 0, unlockedSecrets: [],
            level: 1, currentXP: 0, xpToNext: 300 // INCREASED STARTING XP TO MAKE IT HARDER
        };
        try { const loaded = localStorage.getItem('bosnia_snake_stats_v2'); if(loaded) userStats = {...userStats, ...JSON.parse(loaded)}; } catch(e) { console.warn("Failed to load stats"); }

        const cheats = { godMode: false, speedHack: false };
        let showOwnerLogin = false;
        let showOwnerPanel = false;
        let peer = null;
        let connections = [];
        let hostConn = null;
        let lastSentTime = 0;
        let serverState = null;
        const mouse = { x: 0, y: 0 };
        const keys = {};

        // FLOATING TEXTS SYSTEM
        let floatingTexts = [];

        let gameData = { mode: null, players: [], enemies: [], food: [], mines: [], explosions: [], syrupZones: [], shakeIntensity: 0, gameOver: false };

        function randPosCell() { return Math.floor(Math.random() * GRID) * CELL - WORLD_SIZE / 2; }
        // --- OPTIMIZATION: Distance Squared ---
        function distSq(a, b) { const dx = a.x - b.x; const dy = a.y - b.y; return dx * dx + dy * dy; }
        function dist(a, b) { return Math.sqrt(distSq(a, b)); }
        function coll(a, b, r) { return distSq(a, b) < r * r; }
        
        function normalizeAngle(angle) { return Math.atan2(Math.sin(angle), Math.cos(angle)); }
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function lerpAngle(a, b, t) { const da = (b - a) % TWO_PI; const twoD = ((2 * da) % TWO_PI) - da; return a + twoD * t; }

        function updateStatsUI() {
            document.getElementById('stat-level').innerText = userStats.level;
            document.getElementById('stat-kills').innerText = userStats.totalKills;
            document.getElementById('stat-deaths').innerText = userStats.totalDeaths;
            document.getElementById('stat-best-size').innerText = userStats.bestScale.toFixed(1);
            document.getElementById('stat-games').innerText = userStats.gamesPlayed;
            document.getElementById('stat-mines').innerText = userStats.maxMinesInGame || 0;
            document.getElementById('stat-length').innerText = Math.round(userStats.bestLength);
        }

        // --- NEW XP SYSTEM WITH HARDER LEVELING & REWARDS ---
        function gainXP(amount) {
            // LEVEL 9 REWARD: +0.1 XP Multiplier (10% Bonus)
            if (userStats.level >= 9) {
                amount = amount * 1.1;
            }

            userStats.currentXP += amount;
            if (userStats.currentXP >= userStats.xpToNext) {
                userStats.currentXP -= userStats.xpToNext;
                userStats.level++;
                // HARDER LEVELING CURVE: Increased multiplier to 1.3 from 1.2
                userStats.xpToNext = Math.floor(userStats.xpToNext * 1.3);
                playSound("levelup");
                addFloatingText(canvas.width/2, canvas.height/2 - 100, `LEVEL UP! ${userStats.level}`, "#00FFFF", 40);
                
                // Alert player of rewards
                if(userStats.level === 4) addFloatingText(canvas.width/2, canvas.height/2, "REWARD: TURKEY SKIN UNLOCKED!", "#E30A17", 30);
                if(userStats.level === 5) addFloatingText(canvas.width/2, canvas.height/2, "REWARD: SPAWN SIZE +5!", "#00FF00", 30);
                if(userStats.level === 6) addFloatingText(canvas.width/2, canvas.height/2, "REWARD: CHINA SKIN UNLOCKED!", "#DE2910", 30);
                if(userStats.level === 9) addFloatingText(canvas.width/2, canvas.height/2, "REWARD: +10% XP GAIN!", "#FFFF00", 30);
                if(userStats.level === 10) addFloatingText(canvas.width/2, canvas.height/2, "REWARD: +20% FOOD GROWTH!", "#00FF00", 30);
            }
            updateHUDXP();
            localStorage.setItem('bosnia_snake_stats_v2', JSON.stringify(userStats));
        }

        function updateHUDXP() {
            const pct = Math.min(100, (userStats.currentXP / userStats.xpToNext) * 100);
            document.getElementById('xp-fill').style.width = pct + "%";
            document.getElementById('xp-text').innerText = `${Math.floor(userStats.currentXP)} / ${userStats.xpToNext} XP`;
            document.getElementById('level-badge').firstElementChild.innerText = `LEVEL ${userStats.level}`;
            
            // Show Active Buffs on HUD
            let buffText = "";
            if (userStats.level >= 5) buffText += "+SIZE ";
            if (userStats.level >= 9) buffText += "+XP ";
            if (userStats.level >= 10) buffText += "+GROWTH";
            document.getElementById('active-buffs').innerText = buffText;
        }

        function addFloatingText(x, y, text, color, fontSize=20) {
            floatingTexts.push({
                x: x, y: y, text: text, color: color, size: fontSize,
                life: 1.0, dy: -1.0 - Math.random() // Float up
            });
        }

        function isSkinUnlocked(skin) {
            if (userStats.unlockedSecrets.includes("MASTER_UNLOCK")) return true;
            const req = UNLOCK_CRITERIA[skin]; if (!req) return true;
            
            // Check Level Requirements
            if (req.type === "level") return userStats.level >= req.val;
            
            if (skin === "soviet") return isSkinUnlocked("russia") && userStats.bestScale >= 500 && userStats.totalKills >= 50;
            if (skin === "golden_maple") return isSkinUnlocked("canada") && userStats.bestScale >= 250 && userStats.totalKills >= 150;
            if (skin === "bosnian_kingdom") return isSkinUnlocked("bosnia") && userStats.bestScale >= 271 && userStats.totalKills >= 40 && userStats.maxMinesInGame >= 20;
            if (req.type === "default") return true; if (req.type === "code") return userStats.unlockedSecrets.includes(skin);
            if (req.type === "kills") return userStats.totalKills >= req.val; if (req.type === "deaths") return userStats.totalDeaths >= req.val;
            if (req.type === "scale") return userStats.bestScale >= req.val; if (req.type === "length") return userStats.bestLength >= req.val;
            if (req.type === "games") return userStats.gamesPlayed >= req.val;
            return false;
        }

        function updateStats(updates) {
            let changed = false;
            if (updates.kill) { userStats.totalKills++; changed = true; }
            if (updates.death) { userStats.totalDeaths++; changed = true; }
            if (updates.game) { userStats.gamesPlayed++; changed = true; }
            if (updates.unlockSecret && !userStats.unlockedSecrets.includes(updates.unlockSecret)) { userStats.unlockedSecrets.push(updates.unlockSecret); changed = true; }
            if (updates.scale && updates.scale > userStats.bestScale) { userStats.bestScale = updates.scale; changed = true; }
            if (updates.length && updates.length > userStats.bestLength) { userStats.bestLength = updates.length; changed = true; }
            if (updates.minesExploded && updates.minesExploded > userStats.maxMinesInGame) { userStats.maxMinesInGame = updates.minesExploded; changed = true; }
            if (changed) { localStorage.setItem('bosnia_snake_stats_v2', JSON.stringify(userStats)); updateStatsUI(); renderSkinGrid(); }
        }

        function initSinglePlayer() {
            if (peer) peer.destroy(); peer = new Peer({ debug: 1 });
            peer.on('open', (id) => {
                currentState.myId = id; currentState.isHost = true; currentState.isDedicatedServer = false; currentState.isSpectating = false; currentState.isPlayingClient = false; currentState.myPlayerIndex = 0; currentState.menu = 'playing';
                if(authReady) {
                    const docRef = doc(db, "active_games", id);
                    const publish = () => setDoc(docRef, { host: currentState.playerName, lastBeat: serverTimestamp(), type: 'public' }).catch(e => console.warn("Presence err", e));
                    publish(); const hb = setInterval(publish, 5000); peer.on('disconnected', () => clearInterval(hb));
                }
                updateStats({ game: true });
                updateHUDXP(); // Initialize XP bar
                
                // LEVEL 5 REWARD CHECK
                let startScale = 18;
                if (userStats.level >= 5) startScale += 5;

                gameData.mode = "single";
                gameData.players = [{
                    id: 0, active: true, x: 0, y: 0, angle: -Math.PI / 2, body: [], length: 140, dead: false, country: currentState.selectedSkin, colorBody: SKIN_BODY_COLORS[currentState.selectedSkin], scale: startScale, kills: 0, deaths: 0, frozenUntil: 0, abilityActive: false, lastAbilityTime: 0, maplePhase: null, kingdomPhase: null, minesExplodedCurrentGame: 0, name: currentState.playerName
                }];
                resetWorld(true); toggleUI('playing'); addChatMessage("System", "Welcome to Single Player! Room ID: " + id, "lime");
                peer.on('connection', (conn) => {
                    connections.push(conn);
                    conn.on('data', (data) => { if (data.type === "CHAT") { const msg = { name: data.name, text: data.text, color: "#aaa" }; addChatMessage(msg.name, msg.text, msg.color); broadcastChat(msg); playSound("chat"); } });
                    conn.on('close', () => { connections = connections.filter(c => c !== conn); });
                });
            });
        }

        let nextPlayerId = 1;
        const playerInputs = {}; // Map id -> input state

        function initAdminServer() {
            if (peer) peer.destroy(); peer = new Peer({ debug: 1 });
            peer.on('open', (id) => {
                currentState.myId = id; 
                currentState.isHost = true; 
                currentState.isDedicatedServer = true; 
                currentState.isSpectating = true; 
                currentState.isPlayingClient = false; 
                currentState.myPlayerIndex = -1; // No local player to track
                currentState.menu = 'playing';
                
                cheats.godMode = true; document.getElementById('cheat-god').innerText = "God Mode: ON (SERVER)";
                if(authReady) {
                    const docRef = doc(db, "active_games", id);
                    const publish = () => setDoc(docRef, { host: "OFFICIAL SERVER", lastBeat: serverTimestamp(), type: 'official', players: connections.length }).catch(e => console.warn("Presence err", e));
                    publish(); const hb = setInterval(publish, 4000); peer.on('disconnected', () => clearInterval(hb));
                }
                gameData.mode = "server";
                gameData.players = []; // No Admin Snake
                
                resetWorld(true); 
                toggleUI('playing'); addChatMessage("System", "HOSTING OFFICIAL SERVER. ID: " + id, "gold");
                
                peer.on('connection', (conn) => {
                    connections.push(conn);
                    conn.on('data', (data) => {
                        if (data.type === "CHAT") { const msg = { name: data.name, text: data.text, color: "#aaa" }; broadcastChat(msg); }
                        if (data.type === "JOIN") {
                            const newId = nextPlayerId++;
                            // NOTE: Levels/Rewards not synced to dedicated server yet (simplified)
                            gameData.players.push({
                                id: newId, active: true, x: randPosCell(), y: randPosCell(), angle: Math.random() * Math.PI * 2, body: [], length: 140, dead: false, country: data.skin || "bosnia", colorBody: SKIN_BODY_COLORS[data.skin] || "#fff", scale: 18, kills: 0, deaths: 0, frozenUntil: 0, abilityActive: false, lastAbilityTime: 0, maplePhase: null, kingdomPhase: null, minesExplodedCurrentGame: 0, name: data.name || "Player"
                            });
                            conn.playerId = newId;
                            conn.send({ type: "WELCOME", id: newId });
                        }
                        if (data.type === "RESPAWN_REQ" && conn.playerId) {
                            const p = gameData.players.find(pl => pl.id === conn.playerId);
                            if (p && p.dead) {
                                p.dead = false; p.x = randPosCell(); p.y = randPosCell(); p.angle = Math.random() * Math.PI * 2; p.body = []; p.length = 140; p.scale = 18; p.kills = 0; p.deaths++; p.frozenUntil = Date.now() + 2000; p.abilityActive = false; p.lastAbilityTime = 0; p.maplePhase = null; p.kingdomPhase = null;
                            }
                        }
                        if (data.type === "INPUT" && conn.playerId) {
                            playerInputs[conn.playerId] = data.input;
                        }
                    });
                    conn.on('close', () => {
                        connections = connections.filter(c => c !== conn);
                        if(conn.playerId) {
                             const idx = gameData.players.findIndex(p => p.id === conn.playerId);
                             if(idx !== -1) gameData.players.splice(idx, 1);
                             delete playerInputs[conn.playerId];
                        }
                    });
                });
            });
        }

        function initSpectate(idToJoin) {
            if (!idToJoin) return; if (peer) peer.destroy(); peer = new Peer({ debug: 1 });
            peer.on('open', () => {
                const conn = peer.connect(idToJoin, { serialization: 'json', reliable: true }); hostConn = conn; currentState.isHost = false; currentState.isSpectating = true; currentState.isPlayingClient = false;
                conn.on('open', () => { currentState.menu = 'playing'; toggleUI('playing'); addChatMessage("System", "Connected as Spectator.", "cyan"); });
                conn.on('data', (data) => {
                    if (data.type === "STATE") { serverState = data.state; if (gameData.players.length === 0 && serverState) { gameData = JSON.parse(JSON.stringify(serverState)); gameData.players.forEach(p => p.body = p.body || []); gameData.enemies.forEach(e => e.body = e.body || []); } }
                    if (data.type === "CHAT_MSG") { addChatMessage(data.msg.name, data.msg.text, data.msg.color); playSound("chat"); }
                });
                conn.on('close', () => { alert("Server Disconnected"); location.reload(); });
            });
        }

        function initGameClient(idToJoin) {
             if (!idToJoin) return; if (peer) peer.destroy(); peer = new Peer({ debug: 1 });
             peer.on('open', () => {
                 const conn = peer.connect(idToJoin, { serialization: 'json', reliable: true }); hostConn = conn; currentState.isHost = false; currentState.isSpectating = false; currentState.isPlayingClient = true;
                 conn.on('open', () => { 
                     // Send Join Request
                     conn.send({ type: "JOIN", name: currentState.playerName, skin: currentState.selectedSkin });
                     currentState.menu = 'playing'; toggleUI('playing'); 
                     updateHUDXP(); // Init XP bar for client (persists locally)
                     addChatMessage("System", "Joining Server...", "cyan"); 
                 });
                 conn.on('data', (data) => {
                     if (data.type === "WELCOME") { currentState.myPlayerIndex = data.id; addChatMessage("System", "Spawned!", "lime"); }
                     if (data.type === "STATE") { serverState = data.state; if (gameData.players.length === 0 && serverState) { gameData = JSON.parse(JSON.stringify(serverState)); gameData.players.forEach(p => p.body = p.body || []); gameData.enemies.forEach(e => e.body = e.body || []); } }
                     if (data.type === "CHAT_MSG") { addChatMessage(data.msg.name, data.msg.text, data.msg.color); playSound("chat"); }
                 });
                 conn.on('close', () => { alert("Server Disconnected"); location.reload(); });
             });
        }

        function broadcastChat(msg) { connections.forEach(c => { if (c.open) c.send({ type: "CHAT_MSG", msg }); }); }

        function resetWorld(spawnBots) {
            const s = gameData; s.food = []; s.mines = []; s.explosions = []; s.syrupZones = []; s.shakeIntensity = 0; s.gameOver = false;
            for (let i = 0; i < 400; i++) { let level = 1; while (level < 100 && Math.random() < 0.5) level++; s.food.push({ x: randPosCell(), y: randPosCell(), level: level }); }
            for (let i = 0; i < 80; i++) { s.mines.push({ x: randPosCell(), y: randPosCell(), state: "idle", timer: 3.0, lastTick: Date.now() }); }
            s.players.forEach((p) => {
                p.x = randPosCell(); p.y = randPosCell(); p.body = []; p.length = 140; 
                // LEVEL 5 REWARD CHECK IN RESPAWN
                let startScale = 18;
                if (p.id === currentState.myPlayerIndex && userStats.level >= 5) startScale += 5;
                p.scale = startScale; 

                p.dead = false; p.frozenUntil = 0; p.abilityActive = false; p.lastAbilityTime = 0; p.maplePhase = null; p.kingdomPhase = null; p.minesExplodedCurrentGame = 0; p.barrageActive = false; p.barrageStartTime = 0; p.nextExplosionTime = 0; p.sovietBoost = false;
                if (currentState.isDedicatedServer && p.id === 0) { p.scale = 50; p.length = 500; }
            });
            s.enemies = []; 
            if (spawnBots && gameData.mode !== "server") { for (let i = 0; i < MAX_ENEMIES; i++) spawnOneEnemy(); }
        }

        function spawnOneEnemy() {
            const startLen = 140 + Math.random() * 100; const startWidth = 14;
            const player = gameData.players[0]; let isCroatia = false; if (player && player.scale > 100 && Math.random() < 0.08) { isCroatia = true; }
            const personality = isCroatia ? 'pure_aggro' : 'balanced';
            const speed = isCroatia ? 22.0 : (2.5 + Math.random()) * 1.1; 
            const turn = isCroatia ? 0.20 : 0.08;
            gameData.enemies.push({ x: randPosCell(), y: randPosCell(), angle: Math.random() * Math.PI * 2, body: [], length: startLen, width: startWidth, baseScale: startWidth, speed: speed, boostSpeed: speed, turnSpeed: turn, alive: true, color: isCroatia ? "#CC0000" : "#C6363C", country: isCroatia ? "croatia" : "serbia", frozenUntil: 0, personality: personality });
        }

        function getLocalInput() {
            if (currentState.isSpectating) return { targetAngle: null, sprint: false, triggerAbility: false, respawn: false };
            const sprint = keys['shift'] || keys['/']; const triggerAbility = keys['e']; const respawn = keys[' '];
            let targetAngle = null;
            if (currentState.controlMode === 'mouse') { const cx = window.innerWidth / 2; const cy = window.innerHeight / 2; targetAngle = Math.atan2(mouse.y - cy, mouse.x - cx); } 
            else { let dx = 0, dy = 0; if (keys['w'] || keys['arrowup']) dy -= 1; if (keys['s'] || keys['arrowdown']) dy += 1; if (keys['a'] || keys['arrowleft']) dx -= 1; if (keys['d'] || keys['arrowright']) dx += 1; if (dx !== 0 || dy !== 0) targetAngle = Math.atan2(dy, dx); }
            return { targetAngle, sprint, triggerAbility, respawn };
        }

        function updateHostLogic() {
            gameData.enemies = gameData.enemies.filter(e => e.alive);
            const isOfficialServer = gameData.mode === "server";
            if (!isOfficialServer && gameData.enemies.length < MAX_ENEMIES && Math.random() < 0.02) { spawnOneEnemy(); }
            if (currentState.isDedicatedServer && keys['r']) { resetWorld(true); }

            gameData.players.forEach(p => {
                if (p.dead) {
                    if (p.id === 0 && keys['r'] && !currentState.isDedicatedServer) { resetWorld(true); toggleUI('playing'); } 
                    return; 
                }
                let inp = { targetAngle: null, sprint: false, triggerAbility: false };
                if (p.id === 0) inp = getLocalInput(); 
                else { const remote = playerInputs[p.id]; if(remote) inp = remote; }
                handlePhysics(p, inp);
            });

            updateAI(); 
            updateEnvironment([...gameData.players.filter(p=>!p.dead), ...gameData.enemies]);
        }

        function handlePhysics(p, inp) {
            const now = Date.now(); if (p.frozenUntil > now) return;

            gameData.enemies.forEach(e => {
                if(e.alive) {
                    if (distSq(p, e) < (p.scale + e.width)**2) killPlayer(p, null);
                    for(let i=0; i<e.body.length; i+=3) { if(distSq(p, e.body[i]) < (p.scale + e.width - 5)**2) { killPlayer(p, null); return; } }
                }
            });

            gameData.players.forEach(other => {
                if(other.id !== p.id && !other.dead) {
                    if (distSq(p, other) < (p.scale + other.scale)**2) killPlayer(p, other);
                    for(let i=0; i<other.body.length; i+=3) { if(coll(p, other.body[i], p.scale + other.scale - 5)) { killPlayer(p, other); return; } }
                }
            });

            if (p.country === "soviet") {
                if (inp.sprint && !p.barrageActive && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000)) { p.barrageActive = true; p.barrageEndTime = now + 2000; p.nextExplosionTime = now; p.abilityActive = true; }
                if (p.barrageActive) {
                    if (now >= p.barrageEndTime) { p.barrageActive = false; p.abilityActive = false; p.sovietBoost = false; p.lastAbilityTime = now; } 
                    else { p.sovietBoost = true; if (now >= p.nextExplosionTime) { createExplosion(p.x, p.y, 3 * CELL); gameData.shakeIntensity = Math.min(60, gameData.shakeIntensity + 10); p.nextExplosionTime = now + 200; playSound("soviet_boom"); gameData.enemies.forEach(e => { if (e.alive && distSq(e, p) < (3 * CELL)**2) killEnemy(e, p); }); } }
                }
            } else if (p.country === "golden_maple") {
                if (inp.triggerAbility && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000) && !p.maplePhase) { p.maplePhase = "harvest"; p.phaseEndTime = now + 2500; p.lastAbilityTime = now; playSound("angelic"); }
                if (p.maplePhase === "harvest") { if (now > p.phaseEndTime) { p.maplePhase = "syrup"; p.phaseEndTime = now + 5000; gameData.syrupZones.push({ x: p.x, y: p.y, radius: 6 * CELL, expiresAt: now + 5000, ownerId: p.id }); } } else if (p.maplePhase === "syrup") { if (now > p.phaseEndTime) p.maplePhase = null; }
            } else if (p.country === "bosnian_kingdom") {
                const cooldown = 30000;
                if (inp.triggerAbility && (!p.lastAbilityTime || now - p.lastAbilityTime > cooldown)) {
                    p.kingdomPhase = "active"; p.phaseEndTime = now + 1500; p.lastAbilityTime = now; playSound("soviet_boom");
                    const radius = 300;
                    for (let i = gameData.food.length - 1; i >= 0; i--) { if (distSq(p, gameData.food[i]) < radius * radius) { gameData.food.splice(i, 1); gameData.mines.push({ x: p.x + (Math.random()-0.5)*50, y: p.y + (Math.random()-0.5)*50, state: "idle", type: "bosnian", ownerId: p.id, timer: 0.5, lastTick: now }); } }
                    gameData.mines.forEach(m => { if (distSq(p, m) < radius * radius && m.type !== "bosnian") { m.type = "bosnian"; m.ownerId = p.id; m.state = "idle"; } });
                    for(let i=0; i<8; i++) { const angle = (i / 8) * TWO_PI; gameData.mines.push({ x: p.x + Math.cos(angle) * 250, y: p.y + Math.sin(angle) * 250, state: "idle", type: "bosnian", ownerId: p.id, timer: 0.5, lastTick: now }); }
                }
                if (p.kingdomPhase === "active" && now > p.phaseEndTime) p.kingdomPhase = null;
            }

            let speedMult = 1.0; let turnMult = 1.0;
            gameData.syrupZones.forEach(zone => { if (distSq(p, zone) < zone.radius * zone.radius && zone.ownerId !== p.id) { speedMult = 0.4; turnMult = 0.33; } });
            if (inp.targetAngle !== null) { let d = normalizeAngle(inp.targetAngle - p.angle); const effectiveTurnSpeed = TURN_SPEED * turnMult; if (Math.abs(d) < effectiveTurnSpeed) p.angle = inp.targetAngle; else p.angle += d > 0 ? effectiveTurnSpeed : -effectiveTurnSpeed; p.angle = normalizeAngle(p.angle); }
            let s = BASE_SPEED * speedMult;
            if (p.id === 0 && cheats.speedHack) s = BASE_SPEED * 3; 

            const canSprint = inp.sprint && p.length > MIN_LENGTH && (!p.abilityActive || p.country === "soviet");
            if (canSprint) { s *= 1.8; if (p.sovietBoost) s *= 2.0; p.length -= SPRINT_COST; }
            p.x += Math.cos(p.angle) * s; p.y += Math.sin(p.angle) * s;
            if (Math.abs(p.x) > WORLD_SIZE / 2 || Math.abs(p.y) > WORLD_SIZE / 2) killPlayer(p, null);
            p.body.unshift({ x: p.x, y: p.y }); while (p.body.length > p.length) p.body.pop();
        }

        function updateAI() {
            const state = gameData; const now = Date.now(); const AGGRO_RADIUS = 900;
            state.enemies.forEach((enemy) => {
                if (!enemy.alive) return; if (enemy.frozenUntil && now < enemy.frozenUntil) return;
                if (!enemy.baseScale) enemy.baseScale = 12; const currentCalculatedWidth = 12 + Math.min(60, (enemy.length - 140) / 4); if (currentCalculatedWidth > enemy.baseScale) enemy.baseScale = currentCalculatedWidth; enemy.width = enemy.baseScale;
                let aiSpeedMult = 1.0; let aiTurnMult = 1.0; state.syrupZones.forEach((zone) => { if (distSq(enemy, zone) < zone.radius * zone.radius) { aiSpeedMult = 0.4; aiTurnMult = 0.33; } });
                let finalX = 0; let finalY = 0; let forceSprint = false;
                const distFromCenter = dist(enemy, {x:0, y:0}); const mapEdge = WORLD_SIZE / 2; const safetyMargin = 300;
                if (distFromCenter > mapEdge - safetyMargin) { const panicFactor = (distFromCenter - (mapEdge - safetyMargin)) / safetyMargin; const pullStrength = panicFactor * 5000; finalX -= enemy.x * pullStrength; finalY -= enemy.y * pullStrength; }
                const mySizeMultiplier = Math.max(1, enemy.width / 15); const detectionRange = 200 * mySizeMultiplier; 
                state.players.forEach(p => { 
                    if(!p.dead) { 
                        if (p.scale > enemy.width && enemy.country !== 'croatia') { const d = dist(enemy, p); if (d < detectionRange + p.scale) { const push = 10000 / (d + 1); finalX -= (p.x - enemy.x) * push; finalY -= (p.y - enemy.y) * push; } } 
                        for(let i=0; i < p.body.length; i+=2) { const b = p.body[i]; const d = dist(enemy, b); if(d < detectionRange) { const pushMult = (enemy.country === 'croatia') ? 35000 : 15000; const push = (pushMult * mySizeMultiplier) / (d + 1); finalX -= (b.x - enemy.x) * push; finalY -= (b.y - enemy.y) * push; } } 
                    } 
                });
                state.enemies.forEach(other => { if(other !== enemy && other.alive) { const d = dist(enemy, other); if(d < detectionRange) { const push = 5000 / (d + 1); finalX -= (other.x - enemy.x) * push; finalY -= (other.y - enemy.y) * push; } for (let i = 0; i < other.body.length; i += 4) { const b = other.body[i]; const bd = dist(enemy, b); if (bd < detectionRange) { const push = 8000 / (bd + 1); finalX -= (b.x - enemy.x) * push; finalY -= (b.y - enemy.y) * push; } } } });
                state.mines.forEach(m => { const d = dist(enemy, m); if(d < detectionRange + 100) { const push = 12000 / (d + 1); finalX -= (m.x - enemy.x) * push; finalY -= (m.y - enemy.y) * push; if(m.state === 'triggered') forceSprint = true; } });
                const isEvading = (Math.abs(finalX) > 2000 || Math.abs(finalY) > 2000);
                if (!isEvading) {
                    let targetPlayer = null; let distToPlayer = Infinity;
                    state.players.forEach((p) => { if (!p.dead && p.active) { const d = dist(enemy, p); if(d < distToPlayer) { distToPlayer = d; targetPlayer = p; } } });
                    if (enemy.country === 'croatia' && targetPlayer) { const dx = targetPlayer.x - enemy.x; const dy = targetPlayer.y - enemy.y; finalX += dx * 15.0; finalY += dy * 15.0; forceSprint = true; } 
                    else if (targetPlayer && distToPlayer < AGGRO_RADIUS && enemy.width > targetPlayer.scale) { finalX += (targetPlayer.x - enemy.x) * 2.0; finalY += (targetPlayer.y - enemy.y) * 2.0; if(Math.random() < 0.1) forceSprint = true; } 
                    else { let closestFood = null; let minFoodDist = Infinity; state.food.forEach((f) => { if (f.level < 2 && enemy.width > 50) return; const d = dist(enemy, f); if (d < minFoodDist && d < 800) { minFoodDist = d; closestFood = f; } }); if(closestFood) { finalX += (closestFood.x - enemy.x) * 1.5; finalY += (closestFood.y - enemy.y) * 1.5; } else { finalX += Math.cos(enemy.angle) * 200; finalY += Math.sin(enemy.angle) * 200; } }
                }
                const targetAngle = Math.atan2(finalY, finalX); let diff = normalizeAngle(targetAngle - enemy.angle);
                let dynamicTurnSpeed = enemy.turnSpeed; if (enemy.width > 30) dynamicTurnSpeed *= 0.8; if (enemy.width > 60) dynamicTurnSpeed *= 0.6; if (forceSprint) dynamicTurnSpeed *= 1.5;
                const turn = dynamicTurnSpeed * aiTurnMult;
                if (Math.abs(diff) < turn) enemy.angle = targetAngle; else if (diff > 0) enemy.angle += turn; else enemy.angle -= turn; enemy.angle = normalizeAngle(enemy.angle);
                let currentSpeed = enemy.speed; if (forceSprint && enemy.length > 145) { currentSpeed = enemy.boostSpeed; const cost = enemy.country === 'croatia' ? 0.1 : 0.3; enemy.length -= cost; }
                const spd = currentSpeed * aiSpeedMult; enemy.x += Math.cos(enemy.angle) * spd; enemy.y += Math.sin(enemy.angle) * spd;
                if(Math.abs(enemy.x) > WORLD_SIZE/2 || Math.abs(enemy.y) > WORLD_SIZE/2) { killEnemy(enemy, null); return; }
                enemy.body.unshift({ x: enemy.x, y: enemy.y }); while (enemy.body.length > enemy.length) enemy.body.pop();
                for (let i = state.food.length - 1; i >= 0; i--) { if (coll(enemy, state.food[i], enemy.width + 10)) { state.food.splice(i, 1); enemy.length += 5; enemy.baseScale = Math.min(200, enemy.baseScale + 0.15); } }
                state.enemies.forEach(other => { if(other !== enemy && other.alive) { for(let b of other.body) { if(coll(enemy, b, enemy.width + other.width - 5)) { killEnemy(enemy, other); } } } });
                state.players.forEach((p) => { if (!p.dead && p.active) { if (coll(p, enemy, p.scale + enemy.width)) killPlayer(p, null); for (let j = 0; j < p.body.length; j += 2) if (coll(enemy, p.body[j], enemy.width + p.scale)) killEnemy(enemy, p); } });
            });
        }

        function updateEnvironment(activeEntities) {
            const s = gameData; const now = Date.now();
            for (let i = s.syrupZones.length - 1; i >= 0; i--) { if (now > s.syrupZones[i].expiresAt) s.syrupZones.splice(i, 1); }
            for (let i = s.explosions.length - 1; i >= 0; i--) { s.explosions[i].radius += 15; s.explosions[i].alpha -= 0.1; if (s.explosions[i].alpha <= 0) s.explosions.splice(i, 1); }
            if (s.food.length < 400) { for (let k = 0; k < 10; k++) { let level = 1; while (level < 100 && Math.random() < 0.5) level++; s.food.push({ x: randPosCell(), y: randPosCell(), level: level }); } }
            activeEntities.forEach((p) => { if (p.country === "golden_maple" && p.maplePhase === "harvest") { s.food.forEach((f) => { if (distSq(p, f) < (5 * CELL)**2) f.isGolden = true; }); } });
            
            s.food.forEach((f, i) => { 
                const foodLevel = f.level || 1; const rad = FOOD_RADIUS_BASE + foodLevel * 1.5; 
                activeEntities.forEach((p) => { 
                    if (!p.dead && coll(p, f, p.scale + rad)) { 
                        if (p.id === currentState.myPlayerIndex) { 
                            playSound("eat"); 
                            gainXP(foodLevel * 2); 
                        } 
                        s.food.splice(i, 1); 
                        const multiplier = f.isGolden ? 3 : 1; 
                        
                        // LEVEL 10 REWARD: +20% Food Growth
                        let growthMult = 1.0;
                        if (p.id === currentState.myPlayerIndex && userStats.level >= 10) {
                            growthMult = 1.2;
                        }

                        p.length += LENGTH_GAIN * multiplier * growthMult; 
                        p.scale = Math.min(2000, p.scale + (foodLevel * SIZE_GAIN_PER_LEVEL * multiplier * growthMult)); 
                    } 
                }); 
            });

            for (let i = s.mines.length - 1; i >= 0; i--) {
                let m = s.mines[i]; const isBosnian = m.type === "bosnian"; const triggerRadius = 200; const explodeRadius = isBosnian ? 900 : 300; const delay = isBosnian ? 500 : 3000;
                if (m.state === "idle") { let triggered = false; let triggerer = null; activeEntities.forEach((p) => { if (!p.dead) { if (isBosnian && p.id === m.ownerId) return; if (distSq(p, m) < triggerRadius * triggerRadius) { triggered = true; triggerer = p; } } }); if (triggered) { m.state = "triggered"; m.lastTick = now; if (triggerer && triggerer.id === currentState.myPlayerIndex && !isBosnian) { triggerer.minesExplodedCurrentGame = (triggerer.minesExplodedCurrentGame || 0) + 1; updateStats({ minesExploded: triggerer.minesExplodedCurrentGame }); } } } 
                else if (m.state === "triggered") { if (now - m.lastTick > delay) { createExplosion(m.x, m.y, isBosnian ? 200 : 10); activeEntities.forEach((p) => { if (!p.dead) { if (isBosnian && p.id === m.ownerId) return; if (distSq(p, m) < explodeRadius * explodeRadius) { if(p.id !== undefined) killPlayer(p, null); else killEnemy(p, null); } } }); s.mines.splice(i, 1); } }
            }
        }

        function createExplosion(x, y, radius = 10) {
            gameData.explosions.push({ x, y, radius: radius, alpha: 1.0 });
            const p = gameData.players.find(p => p.id === currentState.myPlayerIndex);
            if (p && !p.dead && distSq(p, {x, y}) < 1500 * 1500) { gameData.shakeIntensity = Math.min(100, gameData.shakeIntensity + 30); }
        }

        function killPlayer(victim, killer) {
            if (victim.dead) return;
            if (victim.id === 0 && cheats.godMode) return; 
            
            victim.dead = true; victim.deaths++; victim.abilityActive = false; victim.maplePhase = null; victim.kingdomPhase = null;
            if (victim.id === currentState.myPlayerIndex) { updateStats({ death: true, scale: victim.scale, length: victim.length }); submitScoreToLeaderboard(victim.scale); toggleUI('death'); }
            if (killer) { 
                killer.kills++; 
                if (killer.id === currentState.myPlayerIndex) {
                    updateStats({ kill: true });
                    gainXP(100);
                    addFloatingText(killer.x, killer.y, "KILL! +100 XP", "#FF0000", 30);
                }
            }
            createExplosion(victim.x, victim.y);
            const totalValue = victim.length * 0.4; const foodCount = Math.max(3, Math.floor(totalValue / LENGTH_GAIN));
            for (let k = 0; k < foodCount; k++) { const index = Math.floor(Math.random() * victim.body.length); if (victim.body[index]) { gameData.food.push({ x: victim.body[index].x, y: victim.body[index].y, level: Math.floor(Math.random() * 3) + 1 }); } }
        }

        function killEnemy(e, killer) {
            if (!e.alive) return; e.alive = false;
            if (killer) { 
                killer.kills++; 
                if (killer.id === currentState.myPlayerIndex) {
                    updateStats({ kill: true }); 
                    gainXP(50);
                    addFloatingText(killer.x, killer.y, "BOT KILL! +50 XP", "#FFA500", 25);
                }
            }
            createExplosion(e.x, e.y);
            const totalValue = e.length * 0.4; const foodCount = Math.max(3, Math.floor(totalValue / LENGTH_GAIN)); const stepSize = Math.max(1, Math.floor(e.body.length / foodCount));
            for (let i = 0; i < e.body.length; i += stepSize) { const point = e.body[i]; if(point) gameData.food.push({ x: point.x + (Math.random() - 0.5) * 20, y: point.y + (Math.random() - 0.5) * 20, level: Math.floor(Math.random() * 3) + 1 }); }
        }

        function compressState(state) {
            return {
                mode: state.mode, shakeIntensity: Math.round(state.shakeIntensity),
                food: state.food.map((f) => ({ x: Math.round(f.x), y: Math.round(f.y), l: f.level, g: f.isGolden ? 1 : 0 })),
                mines: state.mines.map((m) => ({ x: Math.round(m.x), y: Math.round(m.y), state: m.state, type: m.type })),
                explosions: state.explosions.map((e) => ({ x: Math.round(e.x), y: Math.round(e.y), radius: Math.round(e.radius), alpha: Number(e.alpha.toFixed(2)) })),
                syrupZones: state.syrupZones.map((s) => ({ x: Math.round(s.x), y: Math.round(s.y), radius: s.radius, oid: s.ownerId })),
                players: state.players.map((p) => ({
                    id: p.id, active: p.active, dead: p.dead, x: Math.round(p.x), y: Math.round(p.y),
                    angle: Number(p.angle.toFixed(2)), scale: Number(p.scale.toFixed(2)), length: Math.round(p.length),
                    country: p.country, colorBody: p.colorBody, kills: p.kills, deaths: p.deaths,
                    frozenUntil: p.frozenUntil || 0, abilityActive: p.abilityActive || false, lat: p.lastAbilityTime, maplePhase: p.maplePhase, kingdomPhase: p.kingdomPhase, name: p.name
                })),
                enemies: state.enemies.map((e) => ({ alive: e.alive, color: e.color, width: Math.round(e.width), x: Math.round(e.x), y: Math.round(e.y), angle: Number(e.angle.toFixed(2)), frozenUntil: e.frozenUntil || 0 })),
            };
        }

        function loop(timestamp) {
            requestAnimationFrame(loop);
            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
            if (currentState.menu !== 'playing' && currentState.menu !== 'death') {
                ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "rgba(0, 47, 108, 0.2)"; ctx.lineWidth = 1; for (let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); } for (let j = 0; j < canvas.height; j += 50) { ctx.beginPath(); ctx.moveTo(0, j); ctx.lineTo(canvas.width, j); ctx.stroke(); }
                return;
            }

            if (currentState.isHost) {
                const me = gameData.players[0];
                if (timestamp % 1000 < 16 && me && !me.dead) updateStats({ scale: me.scale, length: me.length });
                updateHostLogic();
                if (timestamp - lastSentTime > BROADCAST_RATE) { const payload = { type: "STATE", state: compressState(gameData) }; connections.forEach(c => { if (c.open) c.send(payload); }); lastSentTime = timestamp; }
            } 
            else if ((currentState.isSpectating || currentState.isPlayingClient) && serverState) {
                const t = INTERPOLATION_SPEED; const cur = gameData; const tar = serverState;
                cur.food = tar.food.map(f => ({x:f.x, y:f.y, level:f.l, isGolden: f.g===1})); cur.mines = tar.mines; cur.explosions = tar.explosions; cur.syrupZones = (tar.syrupZones||[]).map(s => ({x:s.x, y:s.y, radius:s.radius, ownerId:s.oid})); cur.shakeIntensity = tar.shakeIntensity;
                cur.players = tar.players.map(tp => {
                    const existing = cur.players.find(p => p.id === tp.id);
                    if(existing) {
                        existing.x = lerp(existing.x, tp.x, t); existing.y = lerp(existing.y, tp.y, t); existing.angle = lerpAngle(existing.angle, tp.angle, t); existing.scale = tp.scale; existing.country = tp.country; existing.dead = tp.dead; existing.name = tp.name; existing.abilityActive = tp.abilityActive; existing.maplePhase = tp.maplePhase; existing.kingdomPhase = tp.kingdomPhase;
                        if(tp.lat) existing.lastAbilityTime = tp.lat;
                        if (!existing.body) existing.body = []; existing.body.unshift({ x: existing.x, y: existing.y }); while (existing.body.length > tp.length) existing.body.pop();
                        return existing;
                    }
                    return tp;
                });
                if (cur.enemies.length !== tar.enemies.length) cur.enemies = tar.enemies.map((e) => ({ ...e, body: [] }));
                cur.enemies.forEach((e, i) => { const te = tar.enemies[i]; if(te) { e.x = lerp(e.x, te.x, t); e.y = lerp(e.y, te.y, t); e.alive = te.alive; e.width = te.width; e.color = te.color; if (e.alive) { e.body.unshift({ x: e.x, y: e.y }); while (e.body.length > 140) e.body.pop(); } } });

                if (currentState.isPlayingClient && hostConn && hostConn.open) {
                    const inp = getLocalInput();
                    hostConn.send({ type: "INPUT", input: inp });
                    const me = cur.players.find(p => p.id === currentState.myPlayerIndex);
                    if (me && me.dead) {
                         if (currentState.menu !== 'death') toggleUI('death');
                         if (keys['r']) { hostConn.send({ type: "RESPAWN_REQ" }); }
                    }
                    if (me && !me.dead && currentState.menu === 'death') { toggleUI('playing'); }
                }
            }

            const me = gameData.players.find(p => p.id === currentState.myPlayerIndex) || {};
            if(!currentState.isSpectating) {
                document.getElementById('hud-size').innerText = "Size: " + (me.scale || 18).toFixed(1);
                document.getElementById('hud-kills').innerText = "Kills: " + (me.kills || 0);
            }

            const abInd = document.getElementById('ability-indicator'); const abTxt = document.getElementById('ability-text');
            if(me.country === 'soviet' || me.country === 'golden_maple' || me.country === 'bosnian_kingdom') {
                abInd.style.display = 'flex'; let cooldown = 60000; if (me.country === 'bosnian_kingdom') cooldown = 30000;
                const timeSince = Date.now() - (me.lastAbilityTime || 0); const isActive = me.barrageActive || !!me.maplePhase || (me.kingdomPhase === "active");
                if (isActive) { abTxt.innerText = "ACTIVE"; abInd.style.borderColor = (Math.floor(Date.now()/200)%2===0) ? "#fff" : "#0f0"; abTxt.style.color = "#0f0"; } else if (timeSince < cooldown) { const rem = Math.ceil((cooldown - timeSince)/1000); abTxt.innerText = rem + "s"; abInd.style.borderColor = "#555"; abTxt.style.color = "#aaa"; } else { abTxt.innerText = "READY"; abInd.style.borderColor = "#FFD700"; abTxt.style.color = "#FFD700"; }
            } else { abInd.style.display = 'none'; }

            ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "rgba(0, 47, 108, 0.2)"; ctx.lineWidth = 1; for (let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); } for (let j = 0; j < canvas.height; j += 50) { ctx.beginPath(); ctx.moveTo(0, j); ctx.lineTo(canvas.width, j); ctx.stroke(); }
            let sx = 0, sy = 0; if (gameData.shakeIntensity > 0) { sx = (Math.random() - 0.5) * gameData.shakeIntensity; sy = (Math.random() - 0.5) * gameData.shakeIntensity; gameData.shakeIntensity *= 0.9; }

            ctx.save(); ctx.translate(canvas.width / 2 + sx, canvas.height / 2 + sy);
            const focus = (currentState.isSpectating && gameData.players.length > 0) ? gameData.players[0] : (me.x !== undefined ? me : {x:0, y:0, scale:18});
            const startScale = 18; const zoom = Math.max(0.1, 0.6 * (30 / (30 + ((focus.scale || 18) - startScale) * 0.4)));
            ctx.scale(zoom, zoom); ctx.translate(-focus.x, -focus.y);
            
            const vw = canvas.width / zoom; const vh = canvas.height / zoom;
            const viewLeft = focus.x - vw/2 - 1000; const viewRight = focus.x + vw/2 + 1000;
            const viewTop = focus.y - vh/2 - 1000; const viewBottom = focus.y + vh/2 + 1000;

            ctx.lineWidth = 12; ctx.strokeStyle = "rgba(255,0,0,0.9)"; ctx.strokeRect(-WORLD_SIZE / 2, -WORLD_SIZE / 2, WORLD_SIZE, WORLD_SIZE);
            if (me.country === "ireland" && !me.dead) { ctx.save(); ctx.strokeStyle = "rgba(0, 255, 0, 0.5)"; ctx.lineWidth = 2; ctx.setLineDash([10, 10]); gameData.enemies.forEach(e => { if (e.alive) { ctx.beginPath(); ctx.moveTo(me.x, me.y); ctx.lineTo(e.x, e.y); ctx.stroke(); } }); ctx.restore(); }
            gameData.syrupZones.forEach((z) => { ctx.fillStyle = "rgba(184, 134, 11, 0.5)"; ctx.beginPath(); ctx.arc(z.x, z.y, z.radius, 0, TWO_PI); ctx.fill(); ctx.strokeStyle = "#DAA520"; ctx.lineWidth = 4; ctx.stroke(); });
            
            gameData.food.forEach((f) => { 
                if (f.x < viewLeft || f.x > viewRight || f.y < viewTop || f.y > viewBottom) return; 
                const level = f.level || 1; const size = FOOD_RADIUS_BASE + level * 1.5; 
                if (f.isGolden) { ctx.fillStyle = "rgba(255, 215, 0, 0.4)"; ctx.beginPath(); ctx.arc(f.x, f.y, size+5, 0, TWO_PI); ctx.fill(); ctx.fillStyle = "#FFD700"; } else { ctx.fillStyle = "orange"; } 
                ctx.beginPath(); ctx.arc(f.x, f.y, size, 0, TWO_PI); ctx.fill(); 
                if (level > 8) { ctx.globalAlpha = 0.3; ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(f.x, f.y, size + 3, 0, TWO_PI); ctx.fill(); ctx.globalAlpha = 1.0; } 
            });

            gameData.mines.forEach((m) => {
                if (m.x < viewLeft || m.x > viewRight || m.y < viewTop || m.y > viewBottom) return; 
                if (m.state === "triggered" && Math.floor(Date.now() / 100) % 2 === 0) { ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.beginPath(); ctx.arc(m.x, m.y, 200, 0, TWO_PI); ctx.fill(); }
                const r = 25; const d = r * 2;
                if (m.type === "bosnian") { ctx.save(); ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, TWO_PI); ctx.clip(); ctx.fillStyle = "#002395"; ctx.fillRect(m.x-r, m.y-r, r*2, r*2); ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(m.x, m.y, r/2, 0, TWO_PI); ctx.fill(); ctx.restore(); ctx.strokeStyle = m.state === "triggered" ? "red" : "#FFD700"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, TWO_PI); ctx.stroke(); return; }
                ctx.save(); ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, TWO_PI); ctx.clip(); ctx.fillStyle = "#C6363C"; ctx.fillRect(m.x - r, m.y - r, d, d / 3); ctx.fillStyle = "#0C4076"; ctx.fillRect(m.x - r, m.y - r + d / 3, d, d / 3); ctx.fillStyle = "#FFFFFF"; ctx.fillRect(m.x - r, m.y - r + (2 * d) / 3, d, d / 3); ctx.fillStyle = "white"; ctx.beginPath(); ctx.moveTo(m.x - 10, m.y - 10); ctx.lineTo(m.x, m.y - 10); ctx.lineTo(m.x, m.y + 5); ctx.lineTo(m.x - 5, m.y + 12); ctx.lineTo(m.x - 10, m.y + 5); ctx.fill(); ctx.restore(); ctx.strokeStyle = m.state === "triggered" ? "red" : "#333"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, TWO_PI); ctx.stroke();
            });

            const allEntities = [...gameData.players, ...gameData.enemies];
            allEntities.forEach((p) => {
                if (p.dead || p.alive === false) return;
                if (p.x < viewLeft - p.length && p.x > viewRight + p.length && p.y < viewTop - p.length && p.y > viewBottom + p.length) return; 

                if (p.frozenUntil && Date.now() < p.frozenUntil) { ctx.fillStyle="rgba(0, 255, 255, 0.4)"; ctx.beginPath(); ctx.arc(p.x, p.y, (p.scale||12)+10, 0, TWO_PI); ctx.fill(); } 
                else if (p.country === "soviet" && p.abilityActive) { ctx.fillStyle="rgba(255, 0, 0, 0.4)"; ctx.beginPath(); ctx.arc(p.x, p.y, (p.scale||12)+20, 0, TWO_PI); ctx.fill(); } 
                else if (p.country === "golden_maple" && p.maplePhase === "harvest") { ctx.strokeStyle = "rgba(218, 165, 32, 0.4)"; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(p.x, p.y, 5 * CELL, 0, TWO_PI); ctx.stroke(); }
                if (p.country === "bosnian_kingdom" && p.kingdomPhase === "active") { ctx.save(); ctx.beginPath(); ctx.arc(p.x, p.y, 300, 0, TWO_PI); ctx.strokeStyle = "rgba(0, 35, 149, 0.6)"; ctx.lineWidth = 10; ctx.stroke(); ctx.fillStyle = "rgba(0, 35, 149, 0.2)"; ctx.fill(); ctx.restore(); }
                
                const bodyW = p.scale || p.width || 12; ctx.lineWidth = bodyW * 1.2; ctx.strokeStyle = (p.frozenUntil && Date.now() < p.frozenUntil) ? "cyan" : (p.colorBody || p.color || "white"); ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.beginPath(); if (p.body.length) { ctx.moveTo(p.body[0].x, p.body[0].y); p.body.forEach(b => ctx.lineTo(b.x, b.y)); ctx.stroke(); } 
                const r = bodyW * 0.65; ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle + Math.PI / 2); ctx.beginPath(); ctx.arc(0, 0, r, 0, TWO_PI); ctx.clip();
                drawFlag(ctx, p.country, r, p.color); ctx.restore();
                if(p.name && zoom > 0.3) { ctx.fillStyle = "white"; ctx.font = `bold ${Math.max(12, r)}px Arial`; ctx.textAlign = "center"; ctx.fillText(p.name, p.x, p.y - r - 10); }
            });

            gameData.explosions.forEach((ex) => { ctx.fillStyle = `rgba(255,69,0,${ex.alpha})`; ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.radius, 0, TWO_PI); ctx.fill(); });
            
            for(let i = floatingTexts.length - 1; i >= 0; i--) {
                let ft = floatingTexts[i]; ft.y += ft.dy; ft.life -= 0.02;
                ctx.globalAlpha = Math.max(0, ft.life); ctx.fillStyle = ft.color; ctx.font = `bold ${ft.size}px Arial`; ctx.fillText(ft.text, ft.x, ft.y); ctx.globalAlpha = 1.0;
                if(ft.life <= 0) floatingTexts.splice(i, 1);
            }

            ctx.restore();
        }

        function drawFlag(ctx, country, r, fallbackColor) {
            const rect = (x, y, w, h, c) => { ctx.fillStyle = c; ctx.fillRect(x, y, w, h); };
            if (!country) { ctx.fillStyle = fallbackColor || "white"; ctx.fillRect(-r, -r, r * 2, r * 2); return; }
            if (country === 'bosnia') { rect(-r, -r, r * 2, r * 2, "#002F6C"); ctx.fillStyle = "#FECB00"; ctx.beginPath(); ctx.moveTo(r * 0.2, -r); ctx.lineTo(r * 0.2, r); ctx.lineTo(r, -r * 0.5); ctx.fill(); ctx.fillStyle = "white"; for (let i = 0; i < 5; i++) { ctx.beginPath(); ctx.arc(-r * 0.2, -r * 0.6 + i * r * 0.4, r * 0.1, 0, TWO_PI); ctx.fill(); } }
            else if (country === 'bosnian_kingdom') { rect(-r, -r, r * 2, r * 2, "#002395"); ctx.fillStyle = "white"; ctx.beginPath(); ctx.moveTo(-r, -r); ctx.lineTo(r, r); ctx.lineTo(r, r-r/2); ctx.lineTo(-r+r/2, -r); ctx.fill(); ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(-r/2, r/2, r/4, 0, TWO_PI); ctx.fill(); ctx.beginPath(); ctx.arc(r/2, -r/2, r/4, 0, TWO_PI); ctx.fill(); }
            else if (country === 'russia') { rect(-r, -r, r * 2, (r * 2) / 3, "white"); rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#0039A6"); rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "#D52B1E"); }
            else if (country === 'croatia') { rect(-r, -r, r*2, (r*2)/3, "red"); rect(-r, -r+(r*2)/3, r*2, (r*2)/3, "white"); rect(-r, -r+4*r/3, r*2, (r*2)/3, "blue"); ctx.fillStyle = "red"; ctx.fillRect(-r/2, -r/2, r, r); ctx.fillStyle = "white"; for(let y=0; y<2; y++) for(let x=0; x<2; x++) { if((x+y)%2===0) ctx.fillRect(-r/2 + x*(r/2), -r/2 + y*(r/2), r/2, r/2); } }
            else if (country === 'serbia') { rect(-r, -r, r * 2, (r * 2) / 3, "#C6363C"); rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#0C4076"); rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "white"); }
            else if (country === 'germany') { rect(-r, -r, r * 2, (r * 2) / 3, "black"); rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#DD0000"); rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "#FFCC00"); }
            else if (country === 'france') { rect(-r, -r, (r * 2) / 3, r * 2, "#0055A4"); rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "white"); rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#EF4135"); }
            else if (country === 'italy') { rect(-r, -r, (r * 2) / 3, r * 2, "#008C45"); rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "white"); rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#CD212A"); }
            else if (country === 'ireland') { rect(-r, -r, (r * 2) / 3, r * 2, "#169B62"); rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "#FFFFFF"); rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#FF883E"); }
            else if (country === 'ukraine') { rect(-r, -r, r * 2, r, "#0057B8"); rect(-r, 0, r * 2, r, "#FFD700"); }
            else if (country === 'poland') { rect(-r, -r, r * 2, r, "white"); rect(-r, 0, r * 2, r, "#DC143C"); }
            else if (country === 'canada') { rect(-r, -r, (r * 2) / 4, r * 2, "#FF0000"); rect(-r + (r * 2) / 4, -r, r, r * 2, "white"); rect(r / 2, -r, (r * 2) / 4, r * 2, "#FF0000"); ctx.fillStyle = "#FF0000"; ctx.beginPath(); ctx.moveTo(0, -r * 0.4); ctx.lineTo(r * 0.3, 0); ctx.lineTo(0, r * 0.4); ctx.lineTo(-r * 0.3, 0); ctx.fill(); }
            else if (country === 'usa') { rect(-r, -r, r * 2, r * 2, "white"); for (let i = 0; i < 7; i++) rect(-r, -r + (i * 2 * r / 7), r * 2, r / 7, "#B22234"); rect(-r, -r, r, r * 0.8, "#3C3B6E"); ctx.fillStyle = "white"; for (let py = 0; py < 3; py++) for (let px = 0; px < 4; px++) { ctx.beginPath(); ctx.arc(-r + 5 + px * (r / 4), -r + 5 + py * (r / 4), 2, 0, TWO_PI); ctx.fill(); } }
            else if (country === 'soviet') { rect(-r, -r, r * 2, r * 2, "#CC0000"); ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(-r * 0.4, -r * 0.4, r * 0.25, 0, TWO_PI); ctx.fill(); ctx.strokeStyle = "#FFD700"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-r * 0.4, -r * 0.2, r * 0.2, 0, Math.PI); ctx.stroke(); }
            else if (country === 'golden_maple') { rect(-r, -r, r*2, r*2, "white"); rect(-r, -r, (r*2)/4, r*2, "#FFFF00"); rect(r/2, -r, (r*2)/4, r*2, "#FFFF00"); ctx.fillStyle = "#FFFF00"; ctx.beginPath(); ctx.moveTo(0, -r * 0.4); ctx.lineTo(r * 0.3, 0); ctx.lineTo(0, r * 0.4); ctx.lineTo(-r * 0.3, 0); ctx.fill(); }
            else if (country === 'sweden') { rect(-r, -r, r * 2, r * 2, "#006AA7"); rect(-r, -r * 0.2, r * 2, r * 0.4, "#FECC00"); rect(-r * 0.2, -r, r * 0.4, r * 2, "#FECC00"); }
            else if (country === 'denmark') { rect(-r, -r, r * 2, r * 2, "#C60C30"); rect(-r, -r * 0.2, r * 2, r * 0.4, "white"); rect(-r * 0.2, -r, r * 0.4, r * 2, "white"); }
            else if (country === 'uk') { rect(-r, -r, r * 2, r * 2, "#012169"); rect(-r, -r * 0.3, r * 2, r * 0.6, "white"); rect(-r * 0.3, -r, r * 0.6, r * 2, "white"); rect(-r, -r * 0.15, r * 2, r * 0.3, "#C8102E"); rect(-r * 0.15, -r, r * 0.3, r * 2, "#C8102E"); }
            else if (country === 'spain') { rect(-r, -r, r * 2, r * 2, "#AA151B"); rect(-r, -r * 0.5, r * 2, r, "#F1BF00"); }
            else if (country === 'netherlands') { rect(-r, -r, r * 2, r * 2 / 3, "#AE1C28"); rect(-r, -r + r * 2 / 3, r * 2, r * 2 / 3, "white"); rect(-r, -r + 4 * r / 3, r * 2, r * 2 / 3, "#21468B"); }
            else if (country === 'greece') { rect(-r, -r, r * 2, r * 2, "#0D5EAF"); for (let i = 0; i < 9; i++) { if (i % 2 !== 0) rect(-r, -r + (i * 2 * r / 9), r * 2, 2 * r / 9, "white"); } rect(-r, -r, r, r, "#0D5EAF"); rect(-r, -r + r * 0.4, r, r * 0.2, "white"); rect(-r + r * 0.4, -r, r * 0.2, r, "white"); }
            else if (country === 'switzerland') { rect(-r, -r, r * 2, r * 2, "#FF0000"); rect(-r + r * 0.8, -r + r * 0.2, r * 0.4, r * 1.6, "white"); rect(-r + r * 0.2, -r + r * 0.8, r * 1.6, r * 0.4, "white"); }
            else if (country === 'norway') { rect(-r, -r, r * 2, r * 2, "#BA0C2F"); rect(-r, -r + r * 0.8, r * 2, r * 0.4, "white"); rect(-r + r * 0.6, -r, r * 0.4, r * 2, "white"); rect(-r, -r + r * 0.9, r * 2, r * 0.2, "#00205B"); rect(-r + r * 0.7, -r, r * 0.2, r * 2, "#00205B"); }
            else if (country === 'finland') { rect(-r, -r, r * 2, r * 2, "white"); rect(-r, -r + r * 0.8, r * 2, r * 0.4, "#003580"); rect(-r + r * 0.6, -r, r * 0.4, r * 2, "#003580"); }
            else if (country === 'portugal') { rect(-r, -r, r * 0.8, r * 2, "#046A38"); rect(-r + r * 0.8, -r, r * 1.2, r * 2, "#DA291C"); ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(-r * 0.2, 0, r * 0.4, 0, TWO_PI); ctx.fill(); }
            
            // --- NEW FLAGS: TURKEY (Lvl 4) & CHINA (Lvl 6) ---
            else if (country === 'turkey') {
                rect(-r, -r, r*2, r*2, "#E30A17");
                // White Circle
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(-r*0.2, 0, r*0.5, 0, TWO_PI); ctx.fill();
                // Red Circle to make crescent
                ctx.fillStyle = "#E30A17"; ctx.beginPath(); ctx.arc(-r*0.1, 0, r*0.4, 0, TWO_PI); ctx.fill();
                // Star
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(r*0.4, 0, r*0.15, 0, TWO_PI); ctx.fill();
            }
            else if (country === 'china') {
                rect(-r, -r, r*2, r*2, "#DE2910");
                ctx.fillStyle = "#FFDE00"; 
                // Big Star
                ctx.beginPath(); ctx.arc(-r*0.5, -r*0.5, r*0.3, 0, TWO_PI); ctx.fill();
                // 4 Small Stars
                ctx.beginPath(); ctx.arc(-r*0.1, -r*0.8, r*0.1, 0, TWO_PI); ctx.fill();
                ctx.beginPath(); ctx.arc(r*0.1, -r*0.6, r*0.1, 0, TWO_PI); ctx.fill();
                ctx.beginPath(); ctx.arc(r*0.1, -r*0.3, r*0.1, 0, TWO_PI); ctx.fill();
                ctx.beginPath(); ctx.arc(-r*0.1, -r*0.1, r*0.1, 0, TWO_PI); ctx.fill();
            }

            else { rect(-r, -r, r * 2, r * 2, fallbackColor || "#333"); }
        }

        function toggleUI(mode) {
            currentState.menu = mode;
            document.getElementById('menu-container').style.display = mode === 'start' ? 'flex' : 'none';
            document.getElementById('hud').style.display = mode === 'playing' && !currentState.isSpectating ? 'flex' : 'none';
            document.getElementById('chat-container').style.display = mode === 'playing' ? 'flex' : 'none';
            document.getElementById('death-screen').style.display = mode === 'death' ? 'block' : 'none';
            document.getElementById('spectator-label').style.display = currentState.isSpectating ? 'block' : 'none';
        }

        function renderSkinGrid() {
            const grid = document.getElementById('skin-grid'); grid.innerHTML = '';
            const list = currentState.skinCategory === 'normal' ? SKINS_NORMAL : SKINS_SPECIAL;
            list.forEach(skin => {
                const unlocked = isSkinUnlocked(skin); const req = UNLOCK_CRITERIA[skin] || { label: "Locked" };
                const div = document.createElement('div'); div.className = `skin-tile ${currentState.selectedSkin === skin ? 'selected' : ''} ${!unlocked ? 'locked' : ''}`;
                div.innerHTML = `<div class="skin-color-dot" style="background: ${SKIN_BODY_COLORS[skin]}"></div><div style="font-size: 11px; font-weight: bold; text-transform: uppercase; color: ${unlocked ? 'white' : '#888'}">${skin.replace('_', ' ')}</div>${!unlocked ? `<div class="lock-text"> ${req.label}</div>` : ''}`;
                div.onclick = () => { if (unlocked) { currentState.selectedSkin = skin; renderSkinGrid(); } };
                grid.appendChild(div);
            });
        }

        async function submitScoreToLeaderboard(scale) {
            const size = parseFloat(scale.toFixed(2)); if (size < 20 || !authReady) return;
            try { const lbRef = collection(db, "leaderboard"); const q = query(lbRef, where("name", "==", currentState.playerName)); const snap = await getDocs(q); if (snap.empty) { await addDoc(lbRef, { name: currentState.playerName, size: size, timestamp: serverTimestamp() }); } else { const d = snap.docs[0]; if (size > d.data().size) updateDoc(doc(db, "leaderboard", d.id), { size: size }); } } catch (e) { console.error("Leaderboard Error", e); }
        }

        async function startScanner() {
            const scan = async () => {
                if(!authReady) return;
                try {
                    const q = query(collection(db, "active_games"), orderBy("lastBeat", "desc"), limit(20));
                    const snap = await getDocs(q);
                    const list = document.getElementById('spectate-list'); list.innerHTML = ''; document.getElementById('scan-status').innerText = ""; let found = 0; const now = Date.now();
                    snap.docs.forEach(doc => {
                        const data = doc.data();
                        if (data.lastBeat && (now - data.lastBeat.toMillis() < 30000)) {
                            found++; const isOfficial = data.type === 'official';
                            const row = document.createElement('div'); row.className = 'spectate-row'; if (isOfficial) row.classList.add('server-official');
                            const nameHtml = isOfficial ? `<b style="color:#FFD700"> OFFICIAL SERVER</b>` : `<b>${data.host}</b>`;
                            const btnColor = isOfficial ? 'gold' : '#28a745'; const btnText = isOfficial ? 'JOIN NOW' : 'SPECTATE'; const txtColor = isOfficial ? 'black' : 'white';
                            row.innerHTML = `<div>${nameHtml}</div><div style="background:${btnColor}; padding:3px 6px; border-radius:3px; font-size:10px; color:${txtColor}; font-weight:bold;">${btnText}</div>`;
                            // Join Official as Player, or Spectate others
                            row.onclick = () => { if(isOfficial) initGameClient(doc.id); else initSpectate(doc.id); };
                            list.appendChild(row);
                        }
                    });
                    if (found === 0) list.innerHTML = '<div style="color:#666; font-size:12px; font-style:italic; padding:10px;">No active games found. Start one!</div>';
                } catch(e) { console.warn("Scanner error", e); }
            };
            scan(); setInterval(scan, 10000);
            try { onSnapshot(query(collection(db, "leaderboard"), orderBy("size", "desc"), limit(5)), (snap) => { const div = document.getElementById('leaderboard-content'); div.innerHTML = ''; snap.docs.forEach((d, i) => { const r = document.createElement('div'); r.className = 'row'; r.innerHTML = `<span style="color:${i === 0 ? '#FECB00' : 'white'}">${i + 1}. ${d.data().name}</span> <span style="color:#4caf50">${Math.round(d.data().size)}</span>`; div.appendChild(r); }); }); } catch(e) { console.log("LB pending"); }
        }

        function addChatMessage(name, text, color) { const container = document.getElementById('chat-messages'); const el = document.createElement('div'); el.className = 'chat-line'; el.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}: </span>${text}`; container.appendChild(el); if (container.children.length > 9) container.removeChild(container.firstChild); }

        window.addEventListener('keydown', e => { const k = e.key.toLowerCase(); keys[k] = true; if (audioCtx.state === 'suspended') audioCtx.resume(); if (document.activeElement === document.getElementById('chat-input') && k !== 'escape') return; if (e.key === '`' || e.key === '~') { e.preventDefault(); if (showOwnerPanel) { showOwnerPanel = false; document.getElementById('owner-control-panel').style.display = 'none'; } else { document.getElementById('btn-admin-open').click(); } } });
        window.addEventListener('keyup', e => { if (document.activeElement === document.getElementById('chat-input')) return; keys[e.key.toLowerCase()] = false; });
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        window.addEventListener('mousedown', (e) => { const chatContainer = document.getElementById('chat-container'); const chatInput = document.getElementById('chat-input'); if (chatContainer.contains(e.target) || e.target === chatInput) return; if (document.activeElement === chatInput) { chatInput.blur(); } });

        document.getElementById('btn-play').onclick = initSinglePlayer;
        document.getElementById('btn-mouse').onclick = () => { currentState.controlMode = 'mouse'; document.getElementById('btn-mouse').classList.add('active'); document.getElementById('btn-keyboard').classList.remove('active'); };
        document.getElementById('btn-keyboard').onclick = () => { currentState.controlMode = 'keyboard'; document.getElementById('btn-keyboard').classList.add('active'); document.getElementById('btn-mouse').classList.remove('active'); };
        document.getElementById('cat-normal').onclick = () => { currentState.skinCategory = 'normal'; document.getElementById('cat-normal').classList.add('active'); document.getElementById('cat-special').classList.remove('active'); renderSkinGrid(); };
        document.getElementById('cat-special').onclick = () => { currentState.skinCategory = 'special'; document.getElementById('cat-special').classList.add('active'); document.getElementById('cat-normal').classList.remove('active'); renderSkinGrid(); };
        document.getElementById('nickname-input').oninput = (e) => { currentState.playerName = e.target.value; localStorage.setItem('bosnia_snake_username', e.target.value); };
        document.getElementById('nickname-input').value = currentState.playerName;

        document.getElementById('btn-redeem').onclick = () => {
            const code = document.getElementById('redeem-input').value;
            if (code === "Ireland_isgreat") { if(!isSkinUnlocked('ireland')) { updateStats({ unlockSecret: "ireland" }); alert("SUCCESS: Ireland Skin Unlocked!"); renderSkinGrid(); } else alert("Already Unlocked"); } else alert("Invalid Code");
        };

        const chatInputEl = document.getElementById('chat-input');
        chatInputEl.addEventListener('keydown', (e) => {
            e.stopPropagation(); 
            if (e.key === 'Enter') {
                const text = e.target.value;
                if (text.trim()) {
                    if (currentState.isHost) { const msg = { name: currentState.playerName, text: text, color: "#FECB00" }; addChatMessage(msg.name, msg.text, msg.color); playSound("chat"); broadcastChat(msg); } 
                    else if (hostConn && hostConn.open) { hostConn.send({ type: "CHAT", name: currentState.playerName, text: text }); if(!currentState.isSpectating) addChatMessage(currentState.playerName, text, "#fff"); }
                }
                e.target.value = ''; document.getElementById('game-canvas').focus();
            }
            if (e.key === 'Escape') { e.target.blur(); }
        });

        document.getElementById('btn-admin-open').onclick = () => { showOwnerLogin = true; document.getElementById('owner-login-panel').style.display = 'block'; document.getElementById('owner-password').focus(); };
        document.getElementById('btn-owner-close').onclick = () => { showOwnerLogin = false; document.getElementById('owner-login-panel').style.display = 'none'; };
        document.getElementById('btn-owner-login').onclick = () => { const pass = document.getElementById('owner-password').value; if(pass === OWNER_PASSWORD) { showOwnerLogin = false; document.getElementById('owner-login-panel').style.display = 'none'; showOwnerPanel = true; document.getElementById('owner-control-panel').style.display = 'block'; document.getElementById('cheat-msg').innerText = "ACCESS GRANTED"; } else { alert("ACCESS DENIED"); } };
        
        const setCheatMsg = (txt) => { const el = document.getElementById('cheat-msg'); el.innerText = txt; setTimeout(() => el.innerText = '', 2000); };
        document.getElementById('cheat-host-server').onclick = () => { showOwnerPanel = false; document.getElementById('owner-control-panel').style.display = 'none'; initAdminServer(); };
        document.getElementById('cheat-god').onclick = () => { cheats.godMode = !cheats.godMode; document.getElementById('cheat-god').innerText = "God Mode: " + (cheats.godMode ? "ON" : "OFF"); setCheatMsg("God Mode " + (cheats.godMode ? "Enabled" : "Disabled")); };
        document.getElementById('cheat-speed').onclick = () => { cheats.speedHack = !cheats.speedHack; document.getElementById('cheat-speed').innerText = "Speed Hack: " + (cheats.speedHack ? "ON" : "OFF"); setCheatMsg("Speed " + (cheats.speedHack ? "Boosted" : "Normal")); };
        document.getElementById('cheat-size').onclick = () => { if(gameData.players[0]) { gameData.players[0].scale = 50; gameData.players[0].length = 500; setCheatMsg("Size Set to 50"); } };
        document.getElementById('cheat-killbots').onclick = () => { gameData.enemies.forEach(e => { if(e.alive) killEnemy(e, null); }); setCheatMsg("Bots Cleared"); };
        document.getElementById('cheat-reset').onclick = () => { resetWorld(true); setCheatMsg("World Reset"); };

        updateStatsUI();
        renderSkinGrid();
        requestAnimationFrame(loop);

        console.log("Bosnia Snake Ultimate Loaded. Admin Access Ready.");

    </script>
</body>
</html>
```
