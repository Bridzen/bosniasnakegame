<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bosnia Snake: Kingdom Update</title>
    <!-- PeerJS for Multiplayer Networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <style>
        /* --- GLOBAL STYLES --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #080b12;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI LAYER WRAPPER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        /* --- HEADS UP DISPLAY (HUD) --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 240px;
            height: 60px;
            background: rgba(0, 15, 60, 0.7);
            border: 2px solid #0055A4;
            border-radius: 10px;
            display: none; /* Hidden on start */
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 85, 164, 0.4);
        }

        #hud-size { 
            font-weight: bold; 
            font-size: 22px; 
            text-shadow: 1px 1px 2px black;
        }

        #hud-kills { 
            font-weight: bold; 
            font-size: 16px; 
            color: #FECB00; 
            text-shadow: 1px 1px 2px black;
        }

        /* --- ABILITY INDICATOR (For Special Skins) --- */
        #ability-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(0,0,0,0.6);
            border-radius: 50%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 4px solid #555;
            transition: border-color 0.3s;
        }
        #ability-text {
            font-weight: bold;
            font-size: 14px;
            color: white;
        }
        #ability-sub {
            font-size: 10px;
            color: #ddd;
        }

        /* --- SPECTATOR LABEL --- */
        #spectator-label {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 0px 0px 5px black;
            display: none;
            color: cyan;
            letter-spacing: 2px;
        }

        /* --- MENU SYSTEM --- */
        #menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 15px;
            height: 700px;
            pointer-events: auto;
            z-index: 20;
        }

        .panel {
            background: rgba(0, 15, 60, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid #FECB00;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(0, 47, 108, 0.5);
            display: flex;
            flex-direction: column;
            padding: 25px;
        }

        #stats-panel {
            width: 240px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #leaderboard-panel {
            width: 250px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #main-menu {
            width: 520px;
            overflow-y: auto;
            position: relative;
        }

        h1 {
            font-size: 50px;
            font-weight: 900;
            text-align: center;
            margin: 0 0 30px 0;
            color: #fff;
            text-shadow: 2px 2px 0px #002F6C, 0 0 15px #FECB00;
        }

        .header-text {
            color: #FECB00;
            font-size: 18px;
            font-weight: 900;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-bottom: 2px solid #002F6C;
            padding-bottom: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* --- FORM ELEMENTS --- */
        input[type="text"], input[type="password"] {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: white;
            font-size: 16px;
            width: 100%;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 15px;
            outline: none;
            box-sizing: border-box;
            transition: background 0.2s, border 0.2s;
        }
        input[type="text"]:focus, input[type="password"]:focus {
            background: rgba(255,255,255,0.2);
            border-color: #FECB00;
        }

        button {
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn-primary {
            width: 100%;
            padding: 18px;
            background: linear-gradient(to right, #002F6C, #0055A4);
            color: white;
            font-size: 16px;
            margin-top: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        }
        .btn-primary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0,0,0,0.3);
        }
        
        /* SECRET HOST BUTTON */
        #btn-secret-host {
            display: none; /* HIDDEN BY DEFAULT */
            width: 100%;
            padding: 18px;
            background: linear-gradient(to right, #006400, #32CD32); /* Green */
            color: white;
            font-size: 18px;
            margin-bottom: 15px;
            border: 2px solid #ADFF2F;
            box-shadow: 0 0 15px #00FF00;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 15px #00FF00; } 50% { box-shadow: 0 0 25px #32CD32; } 100% { box-shadow: 0 0 15px #00FF00; } }

        .btn-redeem {
            width: 100%;
            padding: 10px;
            background: linear-gradient(to right, #C6363C, #800000);
            color: white;
            font-size: 12px;
            margin-top: 5px;
        }

        .btn-toggle {
            flex: 1;
            padding: 12px;
            background: #222;
            color: #888;
        }
        .btn-toggle.active {
            background: #FECB00;
            color: black;
            box-shadow: 0 0 10px #FECB00;
        }

        /* --- SKIN GRID --- */
        #skin-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            overflow-y: auto;
            flex: 1;
            margin-bottom: 20px;
            min-height: 250px;
            padding-right: 5px;
        }

        .skin-tile {
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
        }
        .skin-tile:hover {
            background: rgba(255,255,255,0.1);
        }
        .skin-tile.selected {
            background: rgba(254, 203, 0, 0.2);
            border-color: #FECB00;
            box-shadow: 0 0 10px rgba(254, 203, 0, 0.2);
        }
        .skin-tile.locked {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .skin-color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.8);
            margin-bottom: 8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .lock-text {
            font-size: 9px;
            color: #ff5555;
            font-weight: bold;
            margin-top: 5px;
            text-align: center;
            text-transform: uppercase;
        }

        /* --- CHAT SYSTEM --- */
        #chat-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 320px;
            height: 250px;
            display: none;
            flex-direction: column;
            pointer-events: auto;
            z-index: 100;
        }
        #chat-messages {
            flex: 1;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
            padding-right: 5px;
        }
        .chat-line {
            font-size: 14px;
            margin-bottom: 4px;
            background: rgba(0,0,0,0.4);
            padding: 4px 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }
        #chat-input {
            background: rgba(0,0,0,0.6);
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 4px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
        }

        /* --- SPECTATE LIST --- */
        #spectate-list {
            max-height: 140px;
            overflow-y: auto;
        }
        .spectate-row {
            padding: 12px;
            background: #222;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        .spectate-row:hover { background: #333; }
        .join-btn-style {
            background: #002F6C; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px;
        }
        
        /* --- DEATH SCREEN --- */
        #death-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            pointer-events: none;
            z-index: 50;
        }
        .death-title {
            font-size: 60px;
            font-weight: 900;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
        }
        .death-sub {
            font-size: 24px;
            color: #ccc;
            text-shadow: 1px 1px 0 #000;
        }

        /* --- OWNER / CHEAT PANELS --- */
        #owner-login-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: black;
            padding: 15px;
            border: 2px solid red;
            z-index: 999;
            display: none;
        }
        #owner-control-panel {
            position: absolute;
            top: 60px;
            left: 10px;
            width: 150px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border: 2px solid red;
            color: white;
            z-index: 999;
            display: none;
            box-shadow: 0 0 20px red;
        }
        .cheat-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background: #330000;
            color: red;
            border: 1px solid red;
            font-size: 11px;
        }
        .cheat-btn:hover {
            background: red;
            color: black;
        }
        #cheat-msg {
            text-align: center;
            color: cyan;
            font-weight: bold;
            margin-top: 10px;
            font-size: 12px;
            height: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        ::-webkit-scrollbar-thumb { background: #FECB00; border-radius: 3px; }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer">
        
        <!-- GAME HUD -->
        <div id="hud">
            <div id="hud-size">Size: 18.0</div>
            <div id="hud-kills">Kills: 0</div>
        </div>

        <!-- ABILITY HUD -->
        <div id="ability-indicator">
            <div id="ability-text">READY</div>
            <div id="ability-sub">ABILITY</div>
        </div>

        <div id="spectator-label">SPECTATOR MODE</div>

        <!-- MENU CONTAINER -->
        <div id="menu-container">
            <!-- Left Stats -->
            <div id="stats-panel" class="panel">
                <div class="header-text">Stats</div>
                <div class="row"><span>KILLS</span><span id="stat-kills" style="color: #FECB00">0</span></div>
                <div class="row"><span>DEATHS</span><span id="stat-deaths" style="color: #FECB00">0</span></div>
                <div class="row"><span>BEST SIZE</span><span id="stat-best-size" style="color: #FECB00">18.0</span></div>
                <div class="row"><span>GAMES</span><span id="stat-games" style="color: #FECB00">0</span></div>
                <div class="row"><span>MAX MINES</span><span id="stat-mines" style="color: #FECB00">0</span></div>
                <div class="row"><span>MAX LENGTH</span><span id="stat-length" style="color: #FECB00">140</span></div>
                
                <div style="margin-top: auto; padding-top: 15px; border-top: 1px solid #333;">
                    <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">SECRET CODE</div>
                    <input type="text" id="redeem-input" style="font-size: 12px; padding: 10px; margin-bottom: 8px;" placeholder="Enter Code...">
                    <button id="btn-redeem" class="btn-redeem">REDEEM CODE</button>
                </div>
            </div>

            <!-- Main Menu Center -->
            <div id="main-menu" class="panel">
                <h1>BOSNIA SNAKE</h1>

                <!-- SECRET BUTTON: HOST SERVER -->
                <button id="btn-secret-host">HOST PUBLIC SERVER</button>

                <!-- Control Mode -->
                <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                    <button id="btn-mouse" class="btn-toggle active">MOUSE CONTROL</button>
                    <button id="btn-keyboard" class="btn-toggle">KEYBOARD CONTROL</button>
                </div>

                <!-- Skin Selection -->
                <div style="font-size: 12px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">SELECT SKIN</div>
                <div style="display: flex; margin-bottom: 10px; gap: 5px;">
                    <button id="cat-normal" class="btn-toggle active" style="padding: 8px; font-size: 12px;">NATIONAL</button>
                    <button id="cat-special" class="btn-toggle" style="padding: 8px; font-size: 12px;">SPECIAL / SECRET</button>
                </div>

                <div id="skin-grid"></div>

                <input type="text" id="nickname-input" placeholder="ENTER NICKNAME">
                <button id="btn-play" class="btn-primary">PLAY SOLO</button>

                <!-- Spectate List -->
                <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;">
                    <div style="color: #FECB00; font-weight: bold; margin-bottom: 10px; font-size: 14px;">
                        LIVE GAMES <span id="scan-status" style="font-size: 10px; color: #666; font-weight: normal;">(Scanning...)</span>
                    </div>
                    <div id="spectate-list">
                        <div style="color: #666; font-size: 12px; font-style: italic; padding: 10px;">Initializing scanner...</div>
                    </div>
                </div>
            </div>

            <!-- Leaderboard -->
            <div id="leaderboard-panel" class="panel">
                <div class="header-text">Top 5</div>
                <div id="leaderboard-content">
                    <div style="text-align: center; color: #888; margin-top: 20px;">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Chat -->
        <div id="chat-container">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Type to chat (Enter to send)...">
        </div>

        <!-- Death Screen -->
        <div id="death-screen">
            <div class="death-title">YOU DIED</div>
            <div class="death-sub">Press 'R' to Restart</div>
        </div>

        <!-- OWNER / CHEAT PANELS -->
        <div id="owner-login-panel">
            <div style="color:red; font-size:12px; margin-bottom:5px;">OWNER ACCESS</div>
            <input type="password" id="owner-password" placeholder="Password">
            <button id="btn-owner-login" style="width:100%; background:red; color:white; padding:5px;">LOGIN</button>
        </div>

        <div id="owner-control-panel">
            <div style="text-align:center; margin-bottom:10px; border-bottom:1px solid red;">CHEATS</div>
            <button class="cheat-btn" id="cheat-god">God Mode: OFF</button>
            <button class="cheat-btn" id="cheat-speed">Speed Hack: OFF</button>
            <button class="cheat-btn" id="cheat-size">Set Size 50</button>
            <button class="cheat-btn" id="cheat-killbots">Kill All Bots</button>
            <button class="cheat-btn" id="cheat-reset">Reset World</button>
            <div id="cheat-msg"></div>
        </div>

    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        // -------------------------------------------------------------------------
        // IMPORTS (Firebase)
        // -------------------------------------------------------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { 
            getFirestore, collection, query, orderBy, limit, onSnapshot, 
            addDoc, serverTimestamp, where, getDocs, updateDoc, doc, setDoc, deleteDoc 
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // -------------------------------------------------------------------------
        // POLYFILL (For RoundRect in older browsers)
        // -------------------------------------------------------------------------
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // -------------------------------------------------------------------------
        // FIREBASE CONFIGURATION
        // -------------------------------------------------------------------------
        const firebaseConfig = {
            apiKey: "AIzaSyDFtRTloB37SCPGacQSxjmcuSPOHTHutNk",
            authDomain: "bosniasnake.firebaseapp.com",
            projectId: "bosniasnake",
            storageBucket: "bosniasnake.firebasestorage.app",
            messagingSenderId: "246754109806",
            appId: "1:246754109806:web:c58a4820f26478b69ab97f",
            measurementId: "G-FFQ2PJ3X5W"
        };

        let app, db, auth;
        let authReady = false;

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            signInAnonymously(auth).then(() => {
                console.log("Connected to Firebase (Anonymous)");
                authReady = true;
                startScanner(); 
            }).catch(err => {
                console.error("Auth Error:", err);
                alert("Game Server Connection Failed: " + err.message);
            });
        } catch(e) {
            console.error("Firebase Init Failed", e);
        }

        // -------------------------------------------------------------------------
        // GAME CONFIGURATION CONSTANTS
        // -------------------------------------------------------------------------
        const OWNER_PASSWORD = "Roblox13_isme";
        const CELL = 150;
        const GRID = 80;
        const WORLD_SIZE = CELL * GRID;
        const MIN_LENGTH = 140;
        const SPRINT_COST = 0.5;
        
        // Tuning
        const BASE_SPEED = 4.2;
        const TURN_SPEED = 0.09;
        const MAX_ENEMIES = 8; 
        
        const SIZE_GAIN_PER_LEVEL = 0.15;
        
        const FOOD_RADIUS_BASE = 6;
        const LENGTH_GAIN = 8;
        const BROADCAST_RATE = 50; // ms
        const INTERPOLATION_SPEED = 0.2;

        const SKINS_NORMAL = [
            "bosnia", "russia", "germany", "france", "canada", "ukraine", 
            "usa", "uk", "italy", "poland", "sweden", "denmark"
        ];
        const SKINS_SPECIAL = ["ireland", "soviet", "golden_maple", "bosnian_kingdom"];

        const SKIN_BODY_COLORS = {
            bosnia: "#002F6C", russia: "#FFFFFF", germany: "#000000", france: "#0055A4", 
            canada: "#FF0000", ukraine: "#0057B8", ireland: "#169B62", soviet: "#CC0000", 
            golden_maple: "#DAA520", bosnian_kingdom: "#002395",
            usa: "#3C3B6E", uk: "#012169", italy: "#008C45", 
            poland: "#DC143C", sweden: "#006AA7", denmark: "#C60C30", serbia: "#C6363C",
            croatia: "#CC0000"
        };

        const UNLOCK_CRITERIA = {
            bosnia: { type: "default", label: "Default" },
            russia: { type: "scale", val: 50, label: "Reach Size 50" },
            germany: { type: "scale", val: 40, label: "Reach Size 40" },
            france: { type: "deaths", val: 5, label: "Die 5 Times" },
            canada: { type: "length", val: 1000, label: "Reach Length 1k" },
            ukraine: { type: "games", val: 5, label: "Play 5 Games" },
            usa: { type: "scale", val: 75, label: "Reach Size 75" },
            uk: { type: "length", val: 800, label: "Reach Length 800" },
            italy: { type: "default", label: "Default" },
            poland: { type: "deaths", val: 15, label: "Die 15 Times" },
            sweden: { type: "kills", val: 10, label: "Get 10 Kills" },
            denmark: { type: "kills", val: 25, label: "Get 25 Kills" },
            ireland: { type: "code", label: "Secret Code" },
            soviet: { type: "custom_soviet", label: "Russia + Size 500 + 50 Kills" },
            golden_maple: { type: "custom_maple", label: "Canada + Size 250 + 150 Kills" },
            bosnian_kingdom: { type: "custom_kingdom", label: "Bosnia + Size 271 + 40 Kills + 20 Mines (1 Game)" },
        };

        // -------------------------------------------------------------------------
        // AUDIO ENGINE
        // -------------------------------------------------------------------------
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (!audioCtx) return;
            if (audioCtx.state === "suspended") audioCtx.resume();

            const now = audioCtx.currentTime;
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            if (type === "eat") {
                const osc = audioCtx.createOscillator();
                osc.type = "sine";
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === "soviet_boom") {
                const bufferSize = audioCtx.sampleRate * 1.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = "lowpass";
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.exponentialRampToValueAtTime(10, now + 1);
                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.gain.setValueAtTime(0.8, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1);
                noise.start(now);
                noise.stop(now + 1.5);
            } else if (type === "angelic") {
                const freqs = [523.25, 659.25, 783.99];
                freqs.forEach((f, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = "triangle";
                    osc.frequency.value = f;
                    if (i === 1) osc.detune.value = 5;
                    if (i === 2) osc.detune.value = -5;
                    osc.connect(gainNode);
                    osc.start(now);
                    osc.stop(now + 2.5);
                });
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.08, now + 0.5);
                gainNode.gain.linearRampToValueAtTime(0, now + 2.5);
            } else if (type === "chat") {
                const osc = audioCtx.createOscillator();
                osc.type = "sine";
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        // -------------------------------------------------------------------------
        // GLOBAL STATE VARIABLES
        // -------------------------------------------------------------------------
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let currentState = {
            menu: 'start',
            controlMode: 'mouse',
            skinCategory: 'normal',
            selectedSkin: 'bosnia',
            playerName: localStorage.getItem('bosnia_snake_username') || "Player" + Math.floor(Math.random() * 999),
            isHost: false,
            isSpectating: false,
            myId: null,
            myPlayerIndex: 0 // In Multiplayer, '0' is Host, clients have Peer IDs
        };

        let userStats = {
            totalKills: 0,
            totalDeaths: 0,
            bestScale: 18,
            bestLength: 140,
            gamesPlayed: 0,
            maxMinesInGame: 0,
            unlockedSecrets: []
        };
        try {
            const loaded = localStorage.getItem('bosnia_snake_stats_v2');
            if(loaded) userStats = JSON.parse(loaded);
        } catch(e) { console.warn("Failed to load stats"); }

        const cheats = { godMode: false, speedHack: false };
        let showOwnerLogin = false;
        let showOwnerPanel = false;

        // Networking
        let peer = null;
        let connections = []; // Host: array of peer connections
        let hostConn = null; // Client: connection to host
        let lastSentTime = 0;
        let serverState = null;
        
        // Multiplayer Client Inputs (Stored on Host)
        let clientInputs = {}; // { peerId: { targetAngle, sprint, triggerAbility } }

        // Input
        const mouse = { x: 0, y: 0 };
        const keys = {};

        // Game World Data
        let gameData = {
            mode: null,
            players: [],
            enemies: [],
            food: [],
            mines: [],
            explosions: [],
            syrupZones: [],
            shakeIntensity: 0,
            gameOver: false
        };

        // -------------------------------------------------------------------------
        // HELPER FUNCTIONS
        // -------------------------------------------------------------------------
        function randPosCell() { return Math.floor(Math.random() * GRID) * CELL - WORLD_SIZE / 2; }
        function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
        function coll(a, b, r) { return dist(a, b) < r; }
        function normalizeAngle(angle) { return Math.atan2(Math.sin(angle), Math.cos(angle)); }
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function lerpAngle(a, b, t) {
            const da = (b - a) % (2 * Math.PI);
            const twoD = ((2 * da) % (2 * Math.PI)) - da;
            return a + twoD * t;
        }

        // -------------------------------------------------------------------------
        // STATS & UNLOCK LOGIC
        // -------------------------------------------------------------------------
        function updateStatsUI() {
            document.getElementById('stat-kills').innerText = userStats.totalKills;
            document.getElementById('stat-deaths').innerText = userStats.totalDeaths;
            document.getElementById('stat-best-size').innerText = userStats.bestScale.toFixed(1);
            document.getElementById('stat-games').innerText = userStats.gamesPlayed;
            document.getElementById('stat-mines').innerText = userStats.maxMinesInGame || 0;
            document.getElementById('stat-length').innerText = Math.round(userStats.bestLength);
        }

        function isSkinUnlocked(skin) {
            if (userStats.unlockedSecrets.includes("MASTER_UNLOCK")) return true;
            const req = UNLOCK_CRITERIA[skin];
            if (!req) return true;
            if (skin === "soviet") return isSkinUnlocked("russia") && userStats.bestScale >= 500 && userStats.totalKills >= 50;
            if (skin === "golden_maple") return isSkinUnlocked("canada") && userStats.bestScale >= 250 && userStats.totalKills >= 150;
            if (skin === "bosnian_kingdom") return isSkinUnlocked("bosnia") && userStats.bestScale >= 271 && userStats.totalKills >= 40 && userStats.maxMinesInGame >= 20;
            if (req.type === "default") return true;
            if (req.type === "code") return userStats.unlockedSecrets.includes(skin);
            if (req.type === "kills") return userStats.totalKills >= req.val;
            if (req.type === "deaths") return userStats.totalDeaths >= req.val;
            if (req.type === "scale") return userStats.bestScale >= req.val;
            if (req.type === "length") return userStats.bestLength >= req.val;
            if (req.type === "games") return userStats.gamesPlayed >= req.val;
            return false;
        }

        function updateStats(updates) {
            let changed = false;
            if (updates.kill) { userStats.totalKills++; changed = true; }
            if (updates.death) { userStats.totalDeaths++; changed = true; }
            if (updates.game) { userStats.gamesPlayed++; changed = true; }
            if (updates.unlockSecret && !userStats.unlockedSecrets.includes(updates.unlockSecret)) {
                userStats.unlockedSecrets.push(updates.unlockSecret);
                changed = true;
            }
            if (updates.scale && updates.scale > userStats.bestScale) { userStats.bestScale = updates.scale; changed = true; }
            if (updates.length && updates.length > userStats.bestLength) { userStats.bestLength = updates.length; changed = true; }
            if (updates.minesExploded && updates.minesExploded > userStats.maxMinesInGame) { userStats.maxMinesInGame = updates.minesExploded; changed = true; }

            if (changed) {
                localStorage.setItem('bosnia_snake_stats_v2', JSON.stringify(userStats));
                updateStatsUI();
                renderSkinGrid();
            }
        }

        // -------------------------------------------------------------------------
        // GAME INITIALIZATION (Networking)
        // -------------------------------------------------------------------------
        
        // --- HOST LOGIC (Handles Physics & Clients) ---
        function initHostGame(isPublic = false) {
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', (id) => {
                currentState.myId = id;
                currentState.isHost = true;
                currentState.isSpectating = false;
                currentState.myPlayerIndex = 0; // Host is always 0 in local array
                currentState.menu = 'playing';

                // Publish presence
                if(authReady && isPublic) {
                    const docRef = doc(db, "active_games", id);
                    const publish = () => setDoc(docRef, { 
                        host: currentState.playerName, 
                        lastBeat: serverTimestamp() 
                    }).catch(e => console.warn("Presence err", e));
                    
                    publish();
                    const hb = setInterval(publish, 5000);
                    peer.on('disconnected', () => clearInterval(hb));
                }

                updateStats({ game: true });

                // Reset Game Data
                gameData.mode = "host";
                gameData.players = [];
                clientInputs = {};
                
                // Spawn Host Snake
                spawnPlayer(0, currentState.playerName, currentState.selectedSkin);
                
                resetWorld(true);
                toggleUI('playing');
                addChatMessage("System", "Hosting Server. ID: " + id, "lime");

                // Listen for Clients
                peer.on('connection', (conn) => {
                    connections.push(conn);
                    
                    conn.on('data', (data) => {
                        // CLIENT JOINING
                        if (data.type === "JOIN_REQUEST") {
                            addChatMessage("System", `${data.name} joined!`, "yellow");
                            spawnPlayer(conn.peer, data.name, data.skin);
                        }
                        // CLIENT INPUT
                        else if (data.type === "INPUT") {
                            clientInputs[conn.peer] = data.input;
                        }
                        // CHAT
                        else if (data.type === "CHAT") {
                            const msg = { name: data.name, text: data.text, color: "#aaa" };
                            addChatMessage(msg.name, msg.text, msg.color);
                            broadcastChat(msg);
                            playSound("chat");
                        }
                    });

                    conn.on('close', () => {
                        // Remove player on disconnect
                        const idx = gameData.players.findIndex(p => p.id === conn.peer);
                        if(idx !== -1) {
                            killPlayer(gameData.players[idx], null); // Kill to drop food
                            gameData.players.splice(idx, 1);
                        }
                        delete clientInputs[conn.peer];
                        connections = connections.filter(c => c !== conn);
                    });
                });
            });
        }

        function spawnPlayer(id, name, skin) {
            if(!SKIN_BODY_COLORS[skin]) skin = "bosnia"; // Fallback
            
            // Remove if exists
            gameData.players = gameData.players.filter(p => p.id !== id);
            
            gameData.players.push({
                id: id,
                active: true,
                x: randPosCell(),
                y: randPosCell(),
                angle: -Math.PI / 2,
                body: [],
                length: 140,
                dead: false,
                country: skin,
                colorBody: SKIN_BODY_COLORS[skin],
                scale: 18,
                kills: 0,
                deaths: 0,
                frozenUntil: Date.now() + 2000, // Spawn protection
                abilityActive: false,
                lastAbilityTime: 0,
                maplePhase: null,
                kingdomPhase: null,
                minesExplodedCurrentGame: 0,
                name: name
            });
        }

        // --- CLIENT LOGIC (Joins Host) ---
        function initJoinGame(idToJoin) {
            if (!idToJoin) return;
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', () => {
                const conn = peer.connect(idToJoin);
                hostConn = conn;
                currentState.isHost = false;
                currentState.isSpectating = true; // Technically a client is spectating + sending input
                currentState.myId = peer.id;

                conn.on('open', () => {
                    currentState.menu = 'playing';
                    toggleUI('playing');
                    addChatMessage("System", "Connected to Server!", "cyan");
                    
                    // Request Spawn
                    conn.send({ 
                        type: "JOIN_REQUEST", 
                        name: currentState.playerName, 
                        skin: currentState.selectedSkin 
                    });
                });

                conn.on('data', (data) => {
                    if (data.type === "STATE") {
                        serverState = data.state;
                        // Initial Load
                        if (gameData.players.length === 0 && serverState) {
                            gameData = JSON.parse(JSON.stringify(serverState));
                        }
                    }
                    if (data.type === "CHAT_MSG") {
                        addChatMessage(data.msg.name, data.msg.text, data.msg.color);
                        playSound("chat");
                    }
                });

                conn.on('close', () => {
                    alert("Host Disconnected");
                    location.reload();
                });
            });
            peer.on('error', err => alert("Connection Error: " + err.type));
        }

        function broadcastChat(msg) {
            connections.forEach(c => { if (c.open) c.send({ type: "CHAT_MSG", msg }); });
        }

        // -------------------------------------------------------------------------
        // GAME LOGIC CORE
        // -------------------------------------------------------------------------
        function resetWorld(spawnBots) {
            const s = gameData;
            s.food = [];
            s.mines = [];
            s.explosions = [];
            s.syrupZones = [];
            s.shakeIntensity = 0;
            s.gameOver = false;

            for (let i = 0; i < 400; i++) {
                let level = 1;
                while (level < 100 && Math.random() < 0.5) level++;
                s.food.push({ x: randPosCell(), y: randPosCell(), level: level });
            }

            for (let i = 0; i < 80; i++) {
                s.mines.push({ x: randPosCell(), y: randPosCell(), state: "idle", timer: 3.0, lastTick: Date.now() });
            }

            // Reset All Players
            s.players.forEach(p => {
                p.x = randPosCell();
                p.y = randPosCell();
                p.body = [];
                p.length = 140;
                p.scale = 18;
                p.dead = false;
                p.frozenUntil = Date.now() + 2000;
                p.abilityActive = false;
            });

            s.enemies = [];
            if (spawnBots) {
                for (let i = 0; i < MAX_ENEMIES; i++) spawnOneEnemy();
            }
        }

        function spawnOneEnemy() {
            const startLen = 140 + Math.random() * 100; 
            const startWidth = 14;
            const player = gameData.players[0];
            let isCroatia = false;
            if (player && player.scale > 100 && Math.random() < 0.08) isCroatia = true;

            gameData.enemies.push({
                x: randPosCell(),
                y: randPosCell(),
                angle: Math.random() * Math.PI * 2,
                body: [],
                length: startLen,
                width: startWidth,
                baseScale: startWidth,
                speed: (2.5 + Math.random()) * 1.1,
                boostSpeed: isCroatia ? 16.0 : 8.5, 
                turnSpeed: isCroatia ? 0.12 : 0.08, 
                alive: true,
                color: isCroatia ? "#CC0000" : "#C6363C", 
                country: isCroatia ? "croatia" : "serbia", 
                frozenUntil: 0,
                personality: isCroatia ? 'pure_aggro' : 'balanced'
            });
        }

        function getLocalInput() {
            const sprint = keys['shift'] || keys['/'];
            const triggerAbility = keys['e'];
            const respawn = keys[' ']; // Not used in packet, handled locally/UI

            let targetAngle = null;
            if (currentState.controlMode === 'mouse') {
                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                targetAngle = Math.atan2(mouse.y - cy, mouse.x - cx);
            } else {
                let dx = 0, dy = 0;
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;
                if (dx !== 0 || dy !== 0) targetAngle = Math.atan2(dy, dx);
            }
            return { targetAngle, sprint, triggerAbility };
        }

        // --- MAIN UPDATE LOOP (HOST) ---
        function updateHostLogic() {
            // Respawn Logic for Host
            const hostP = gameData.players.find(p => p.id === 0);
            if (hostP && hostP.dead && keys['r']) {
                spawnPlayer(0, currentState.playerName, currentState.selectedSkin);
            }

            // Spawn/Prune Bots
            gameData.enemies = gameData.enemies.filter(e => e.alive);
            if (gameData.enemies.length < MAX_ENEMIES && Math.random() < 0.02) spawnOneEnemy();

            // Update All Players
            gameData.players.forEach(p => {
                if (p.dead) return;

                // Get Input
                let inp = { targetAngle: null, sprint: false, triggerAbility: false };
                if (p.id === 0) {
                    inp = getLocalInput(); // Host Input
                } else {
                    if (clientInputs[p.id]) inp = clientInputs[p.id]; // Client Input
                }

                handlePhysics(p, inp);
            });

            updateAI(); 
            updateEnvironment([...gameData.players, ...gameData.enemies]);
        }

        // --- PHYSICS & ABILITIES ---
        function handlePhysics(p, inp) {
            const now = Date.now();
            if (p.frozenUntil > now) return;

            // CHECK COLLISIONS (Player Hitting AI or Other Players)
            const allTargets = [...gameData.enemies, ...gameData.players];
            allTargets.forEach(e => {
                if(e === p) return;
                const isPlayer = (e.id !== undefined);
                if(isPlayer && e.dead) return;
                if(!isPlayer && !e.alive) return;

                const targetWidth = isPlayer ? e.scale : e.width;

                // Head to Head
                if (dist(p, e) < p.scale + targetWidth) {
                    if(p.scale > targetWidth) {
                        if(isPlayer) killPlayer(e, p); else killEnemy(e, p);
                    } else if (p.scale < targetWidth) {
                        killPlayer(p, e);
                    } else {
                        // Equal size - Coin flip or nothing
                    }
                }
                
                // Head to Body
                const bodyArr = e.body || [];
                // Check every 3rd point for performance
                for(let i=0; i<bodyArr.length; i+=3) {
                    if(dist(p, bodyArr[i]) < p.scale + targetWidth - 5) {
                        killPlayer(p, e);
                        return;
                    }
                }
            });

            // ABILITIES
            if (p.country === "soviet") {
                if (inp.sprint && !p.barrageActive && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000)) {
                    p.barrageActive = true;
                    p.barrageEndTime = now + 2000;
                    p.nextExplosionTime = now;
                    p.abilityActive = true;
                }
                if (p.barrageActive) {
                    if (now >= p.barrageEndTime) {
                        p.barrageActive = false; p.abilityActive = false; p.sovietBoost = false; p.lastAbilityTime = now;
                    } else {
                        p.sovietBoost = true;
                        if (now >= p.nextExplosionTime) {
                            createExplosion(p.x, p.y, 3 * CELL);
                            if(p.id===0) gameData.shakeIntensity = Math.min(60, gameData.shakeIntensity + 10);
                            p.nextExplosionTime = now + 200;
                            if(p.id===0) playSound("soviet_boom");
                            
                            // Kill nearby
                            [...gameData.enemies, ...gameData.players].forEach(e => {
                                if(e===p) return;
                                if(dist(e, p) < 3 * CELL) {
                                    if(e.id !== undefined) killPlayer(e, p); else killEnemy(e, p);
                                }
                            });
                        }
                    }
                }
            }
            else if (p.country === "golden_maple") {
                if (inp.triggerAbility && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000) && !p.maplePhase) {
                    p.maplePhase = "harvest"; p.phaseEndTime = now + 2500; p.lastAbilityTime = now;
                    if(p.id===0) playSound("angelic");
                }
                if (p.maplePhase === "harvest" && now > p.phaseEndTime) {
                     p.maplePhase = "syrup"; p.phaseEndTime = now + 5000;
                     gameData.syrupZones.push({ x: p.x, y: p.y, radius: 6 * CELL, expiresAt: now + 5000, ownerId: p.id });
                }
                if (p.maplePhase === "syrup" && now > p.phaseEndTime) p.maplePhase = null;
            }
            else if (p.country === "bosnian_kingdom") {
                const cooldown = 30000;
                if (inp.triggerAbility && (!p.lastAbilityTime || now - p.lastAbilityTime > cooldown)) {
                    p.kingdomPhase = "active"; p.phaseEndTime = now + 1500; p.lastAbilityTime = now;
                    if(p.id===0) playSound("soviet_boom");
                    
                    const radius = 300;
                    // Food -> Mines
                    for (let i = gameData.food.length - 1; i >= 0; i--) {
                        if (dist(p, gameData.food[i]) < radius) {
                            gameData.food.splice(i, 1);
                            gameData.mines.push({ x: p.x + (Math.random()-0.5)*50, y: p.y + (Math.random()-0.5)*50, state: "idle", type: "bosnian", ownerId: p.id, timer: 0.5, lastTick: now });
                        }
                    }
                    // Ring
                    for(let i=0; i<8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        gameData.mines.push({ x: p.x + Math.cos(angle) * 250, y: p.y + Math.sin(angle) * 250, state: "idle", type: "bosnian", ownerId: p.id, timer: 0.5, lastTick: now });
                    }
                }
                if (p.kingdomPhase === "active" && now > p.phaseEndTime) p.kingdomPhase = null;
            }

            // MOVEMENT
            let speedMult = 1.0;
            let turnMult = 1.0;

            gameData.syrupZones.forEach(zone => {
                if (dist(p, zone) < zone.radius && zone.ownerId !== p.id) { speedMult = 0.4; turnMult = 0.33; }
            });

            if (inp.targetAngle !== null) {
                let d = normalizeAngle(inp.targetAngle - p.angle);
                const effectiveTurnSpeed = TURN_SPEED * turnMult;
                if (Math.abs(d) < effectiveTurnSpeed) p.angle = inp.targetAngle;
                else p.angle += d > 0 ? effectiveTurnSpeed : -effectiveTurnSpeed;
                p.angle = normalizeAngle(p.angle);
            }

            let s = BASE_SPEED * speedMult;
            if (p.id === 0 && cheats.speedHack) s = BASE_SPEED * 3;

            const canSprint = inp.sprint && p.length > MIN_LENGTH && (!p.abilityActive || p.country === "soviet");
            if (canSprint) {
                s *= 1.8;
                if (p.sovietBoost) s *= 2.0;
                p.length -= SPRINT_COST;
            }

            p.x += Math.cos(p.angle) * s;
            p.y += Math.sin(p.angle) * s;

            if (Math.abs(p.x) > WORLD_SIZE / 2 || Math.abs(p.y) > WORLD_SIZE / 2) {
                killPlayer(p, null);
            }

            p.body.unshift({ x: p.x, y: p.y });
            while (p.body.length > p.length) p.body.pop();
        }

        // --- ENVIRONMENT LOGIC ---
        function updateAI() {
             const state = gameData;
             const now = Date.now();
             state.enemies.forEach((enemy) => {
                if (!enemy.alive) return;
                // AI Logic reused from previous code, abbreviated here for length but functional logic remains same
                // ... (AI implementation is identical to before, just applied to 'enemy')
                // Basic AI Movement for context:
                enemy.angle += (Math.random() - 0.5) * 0.2;
                enemy.x += Math.cos(enemy.angle) * enemy.speed;
                enemy.y += Math.sin(enemy.angle) * enemy.speed;
                if(Math.abs(enemy.x) > WORLD_SIZE/2) enemy.angle = Math.PI - enemy.angle;
                if(Math.abs(enemy.y) > WORLD_SIZE/2) enemy.angle = -enemy.angle;
                enemy.body.unshift({x:enemy.x, y:enemy.y});
                while(enemy.body.length > enemy.length) enemy.body.pop();
             });
        }

        function updateEnvironment(activeEntities) {
            const s = gameData;
            const now = Date.now();
            
            for (let i = s.syrupZones.length - 1; i >= 0; i--) {
                if (now > s.syrupZones[i].expiresAt) s.syrupZones.splice(i, 1);
            }
            for (let i = s.explosions.length - 1; i >= 0; i--) {
                s.explosions[i].radius += 15; s.explosions[i].alpha -= 0.05;
                if (s.explosions[i].alpha <= 0) s.explosions.splice(i, 1);
            }
            if (s.food.length < 400) {
                for (let k = 0; k < 10; k++) {
                    let level = 1; while (level < 100 && Math.random() < 0.5) level++;
                    s.food.push({ x: randPosCell(), y: randPosCell(), level: level });
                }
            }

            // Food Collision
            s.food.forEach((f, i) => {
                const rad = FOOD_RADIUS_BASE + f.level * 1.5;
                activeEntities.forEach((p) => {
                    const isPlayer = (p.id !== undefined);
                    if ((isPlayer && !p.dead) || (!isPlayer && p.alive)) {
                        if (coll(p, f, (isPlayer ? p.scale : p.width) + rad)) {
                            if (isPlayer && p.id === currentState.myPlayerIndex) playSound("eat");
                            s.food.splice(i, 1);
                            const multiplier = f.isGolden ? 3 : 1;
                            p.length += LENGTH_GAIN * multiplier;
                            if(isPlayer) p.scale = Math.min(2000, p.scale + f.level * SIZE_GAIN_PER_LEVEL * multiplier);
                            else p.width = Math.min(200, p.width + 0.15);
                        }
                    }
                });
            });

            // Mines
            for (let i = s.mines.length - 1; i >= 0; i--) {
                let m = s.mines[i];
                if (m.state === "idle") {
                    let triggered = false;
                    activeEntities.forEach((p) => { 
                         const isPlayer = (p.id !== undefined);
                         if((isPlayer && !p.dead) || (!isPlayer && p.alive)) {
                             if (m.type === "bosnian" && p.id === m.ownerId) return;
                             if (dist(p, m) < 200) triggered = true;
                         }
                    });
                    if (triggered) { m.state = "triggered"; m.lastTick = now; }
                } else if (m.state === "triggered") {
                    const delay = m.type === "bosnian" ? 500 : 3000;
                    if (now - m.lastTick > delay) {
                        createExplosion(m.x, m.y, m.type === "bosnian" ? 200 : 10);
                        const rad = m.type === "bosnian" ? 900 : 300;
                        activeEntities.forEach((p) => { 
                             const isPlayer = (p.id !== undefined);
                             if((isPlayer && !p.dead) || (!isPlayer && p.alive)) {
                                 if (m.type === "bosnian" && p.id === m.ownerId) return;
                                 if (dist(p, m) < rad) {
                                     if(isPlayer) killPlayer(p, null); else killEnemy(p, null);
                                 }
                             }
                        });
                        s.mines.splice(i, 1);
                    }
                }
            }
        }

        function createExplosion(x, y, radius = 10) {
            gameData.explosions.push({ x, y, radius: radius, alpha: 1.0 });
            // Shake screen for host if close
            const p = gameData.players.find(pl => pl.id === 0);
            if (p && !p.dead && dist(p, {x, y}) < 1500) gameData.shakeIntensity = Math.min(100, gameData.shakeIntensity + 30);
        }

        function killPlayer(victim, killer) {
            if (victim.dead) return;
            if (victim.id === 0 && cheats.godMode) return;
            
            victim.dead = true;
            victim.deaths++;
            victim.abilityActive = false;

            if (victim.id === 0) { // Local Player
                updateStats({ death: true, scale: victim.scale, length: victim.length });
                submitScoreToLeaderboard(victim.scale);
                toggleUI('death');
            }

            if (killer) killer.kills++;
            createExplosion(victim.x, victim.y);
            
            // Drop Food
            const count = Math.max(3, Math.floor((victim.length * 0.4) / LENGTH_GAIN));
            for (let k = 0; k < count; k++) {
                if(victim.body.length) {
                    const b = victim.body[Math.floor(Math.random() * victim.body.length)];
                    if(b) gameData.food.push({ x: b.x, y: b.y, level: Math.floor(Math.random() * 3) + 1 });
                }
            }
        }

        function killEnemy(e, killer) {
            if (!e.alive) return;
            e.alive = false;
            if (killer) killer.kills++;
            createExplosion(e.x, e.y);
            const count = Math.max(3, Math.floor((e.length * 0.4) / LENGTH_GAIN));
            for (let i = 0; i < e.body.length; i += Math.floor(e.body.length/count)||1) {
                const b = e.body[i];
                if(b) gameData.food.push({ x: b.x, y: b.y, level: Math.floor(Math.random() * 3) + 1 });
            }
        }

        // -------------------------------------------------------------------------
        // NETWORK DATA COMPRESSION
        // -------------------------------------------------------------------------
        function compressState(state) {
            return {
                mode: state.mode,
                shakeIntensity: Math.round(state.shakeIntensity),
                food: state.food.map((f) => ({ x: Math.round(f.x), y: Math.round(f.y), l: f.level, g: f.isGolden ? 1 : 0 })),
                mines: state.mines.map((m) => ({ x: Math.round(m.x), y: Math.round(m.y), state: m.state, type: m.type })),
                explosions: state.explosions.map((e) => ({ x: Math.round(e.x), y: Math.round(e.y), radius: Math.round(e.radius), alpha: Number(e.alpha.toFixed(2)) })),
                syrupZones: state.syrupZones.map((s) => ({ x: Math.round(s.x), y: Math.round(s.y), radius: s.radius, oid: s.ownerId })),
                players: state.players.map((p) => ({
                    id: p.id, active: p.active, dead: p.dead, x: Math.round(p.x), y: Math.round(p.y),
                    angle: Number(p.angle.toFixed(2)), scale: Number(p.scale.toFixed(2)), length: Math.round(p.length),
                    country: p.country, colorBody: p.colorBody, kills: p.kills, deaths: p.deaths,
                    frozenUntil: p.frozenUntil || 0, abilityActive: p.abilityActive || false, name: p.name
                })),
                enemies: state.enemies.map((e) => ({
                    alive: e.alive, color: e.color, width: Math.round(e.width), x: Math.round(e.x), y: Math.round(e.y),
                    angle: Number(e.angle.toFixed(2)), frozenUntil: e.frozenUntil || 0
                })),
            };
        }

        // -------------------------------------------------------------------------
        // RENDER LOOP
        // -------------------------------------------------------------------------
        function loop(timestamp) {
            requestAnimationFrame(loop);

            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            }

            if (currentState.menu !== 'playing' && currentState.menu !== 'death') {
                ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }

            // --- UPDATE LOGIC ---
            if (currentState.isHost) {
                updateHostLogic();
                // Send State
                if (timestamp - lastSentTime > BROADCAST_RATE) {
                    const payload = { type: "STATE", state: compressState(gameData) };
                    connections.forEach(c => { if (c.open) c.send(payload); });
                    lastSentTime = timestamp;
                }
            } 
            else if (currentState.isSpectating && serverState) {
                // Send Input
                if (hostConn && hostConn.open) {
                    const inp = getLocalInput();
                    // Respawn request via key
                    if (keys['r']) { /* Handle respawn logic handled by input key or UI */ }
                    hostConn.send({ type: "INPUT", input: inp });
                }
                
                // Interpolate
                const t = INTERPOLATION_SPEED;
                const cur = gameData; 
                const tar = serverState;
                
                cur.food = tar.food.map(f => ({x:f.x, y:f.y, level:f.l, isGolden: f.g===1}));
                cur.mines = tar.mines;
                cur.explosions = tar.explosions;
                cur.syrupZones = (tar.syrupZones||[]).map(s => ({x:s.x, y:s.y, radius:s.radius, ownerId:s.oid}));
                cur.shakeIntensity = tar.shakeIntensity;

                // Sync Players
                cur.players = tar.players.map(tp => {
                    let existing = cur.players.find(p => p.id === tp.id);
                    if(!existing) existing = { body: [] };
                    
                    existing.id = tp.id; existing.name = tp.name;
                    existing.x = lerp(existing.x || tp.x, tp.x, t);
                    existing.y = lerp(existing.y || tp.y, tp.y, t);
                    existing.angle = lerpAngle(existing.angle || tp.angle, tp.angle, t);
                    existing.scale = tp.scale; existing.country = tp.country; existing.dead = tp.dead;
                    existing.colorBody = tp.colorBody; existing.kills = tp.kills; existing.abilityActive = tp.abilityActive;
                    
                    existing.body.unshift({ x: existing.x, y: existing.y });
                    while (existing.body.length > tp.length) existing.body.pop();
                    return existing;
                });

                // Sync Enemies
                 cur.enemies = tar.enemies.map(te => {
                     let existing = cur.enemies.find(e => Math.abs(e.x - te.x) < 500); // Rough matching or just rebuild
                     if(!existing) existing = { body: [] };
                     existing.x = lerp(existing.x || te.x, te.x, t);
                     existing.y = lerp(existing.y || te.y, te.y, t);
                     existing.alive = te.alive; existing.width = te.width; existing.color = te.color;
                     existing.body.unshift({ x: existing.x, y: existing.y });
                     while (existing.body.length > 140) existing.body.pop();
                     return existing;
                 });
                 
                 // Check my death
                 const me = cur.players.find(p => p.id === currentState.myId);
                 if(me && me.dead && currentState.menu !== 'death') toggleUI('death');
                 if(me && !me.dead && currentState.menu === 'death') toggleUI('playing');
            }

            // --- DRAWING ---
            ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Camera
            let sx = 0, sy = 0;
            if (gameData.shakeIntensity > 0) {
                sx = (Math.random() - 0.5) * gameData.shakeIntensity;
                sy = (Math.random() - 0.5) * gameData.shakeIntensity;
                gameData.shakeIntensity *= 0.9;
            }

            // Find focus
            let focus = { x: 0, y: 0, scale: 18 };
            const myP = gameData.players.find(p => {
                if(currentState.isHost) return p.id === 0;
                return p.id === currentState.myId;
            });
            if(myP) focus = myP;
            
            // HUD Update
            if(myP) {
                document.getElementById('hud-size').innerText = "Size: " + (myP.scale).toFixed(1);
                document.getElementById('hud-kills').innerText = "Kills: " + (myP.kills);
            }

            ctx.save();
            ctx.translate(canvas.width / 2 + sx, canvas.height / 2 + sy);
            const zoom = Math.max(0.1, 0.6 * (30 / (30 + ((focus.scale || 18) - 18) * 0.4)));
            ctx.scale(zoom, zoom);
            ctx.translate(-focus.x, -focus.y);

            // Bounds
            ctx.lineWidth = 12; ctx.strokeStyle = "rgba(255,0,0,0.9)";
            ctx.strokeRect(-WORLD_SIZE / 2, -WORLD_SIZE / 2, WORLD_SIZE, WORLD_SIZE);

            // Syrup
            gameData.syrupZones.forEach((z) => {
                ctx.fillStyle = "rgba(184, 134, 11, 0.5)"; ctx.beginPath(); ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2); ctx.fill();
            });

            // Food
            gameData.food.forEach((f) => {
                const level = f.level || 1;
                const size = FOOD_RADIUS_BASE + level * 1.5;
                if (f.isGolden) { ctx.fillStyle = "#FFD700"; ctx.shadowColor = "#FFD700"; ctx.shadowBlur = 10; }
                else { ctx.fillStyle = "orange"; ctx.shadowBlur = 0; }
                ctx.beginPath(); ctx.arc(f.x, f.y, size, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
            });

            // Mines
            gameData.mines.forEach((m) => {
                const r = 25; 
                if (m.type === "bosnian") {
                    ctx.save(); ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.clip();
                    ctx.fillStyle = "#002395"; ctx.fillRect(m.x-r, m.y-r, r*2, r*2);
                    ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(m.x, m.y, r/2, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                    ctx.strokeStyle = m.state === "triggered" ? "red" : "#FFD700"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.stroke();
                } else {
                    ctx.save(); ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.clip();
                    ctx.fillStyle = "#C6363C"; ctx.fillRect(m.x - r, m.y - r, r*2, r*2/3);
                    ctx.fillStyle = "#0C4076"; ctx.fillRect(m.x - r, m.y - r + r*2/3, r*2, r*2/3);
                    ctx.fillStyle = "#FFFFFF"; ctx.fillRect(m.x - r, m.y - r + (2 * r * 2) / 3, r*2, r*2/3);
                    ctx.restore();
                    ctx.strokeStyle = m.state === "triggered" ? "red" : "#333"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.stroke();
                }
            });

            // Entities
            const allEntities = [...gameData.players, ...gameData.enemies];
            allEntities.forEach((p) => {
                if ((p.id !== undefined && p.dead) || (p.id === undefined && !p.alive)) return;

                const bodyW = p.scale || p.width || 12;
                ctx.lineWidth = bodyW * 1.2;
                ctx.strokeStyle = (p.frozenUntil && Date.now() < p.frozenUntil) ? "cyan" : (p.colorBody || p.color || "white");
                if (p.abilityActive) { ctx.shadowBlur = 30; ctx.shadowColor = "red"; }
                ctx.lineCap = "round"; ctx.lineJoin = "round";
                ctx.beginPath();
                if (p.body.length) {
                    ctx.moveTo(p.body[0].x, p.body[0].y);
                    p.body.forEach(b => ctx.lineTo(b.x, b.y));
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                const r = bodyW * 0.65;
                ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle + Math.PI / 2);
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.clip();
                drawFlag(ctx, p.country, r, p.color);
                ctx.restore();
                
                if(p.name && zoom > 0.3) {
                     ctx.fillStyle = "white"; ctx.font = `bold ${Math.max(12, r)}px Arial`; 
                     ctx.textAlign = "center"; ctx.fillText(p.name, p.x, p.y - r - 10);
                }
            });

            gameData.explosions.forEach((ex) => {
                ctx.fillStyle = `rgba(255,69,0,${ex.alpha})`; ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2); ctx.fill();
            });

            ctx.restore();
        }

        // -------------------------------------------------------------------------
        // FLAG DRAWING
        // -------------------------------------------------------------------------
        function drawFlag(ctx, country, r, fallbackColor) {
            const rect = (x, y, w, h, c) => { ctx.fillStyle = c; ctx.fillRect(x, y, w, h); };
            if (!country) { ctx.fillStyle = fallbackColor || "white"; ctx.fillRect(-r, -r, r * 2, r * 2); return; }
            // (Same flag logic as before - abbreviated for space, logic remains)
            if (country === 'bosnia') {
                rect(-r, -r, r * 2, r * 2, "#002F6C");
                ctx.fillStyle = "#FECB00"; ctx.beginPath(); ctx.moveTo(r * 0.2, -r); ctx.lineTo(r * 0.2, r); ctx.lineTo(r, -r * 0.5); ctx.fill();
            } else if (country === 'usa') {
                rect(-r, -r, r * 2, r * 2, "white");
                for (let i = 0; i < 7; i++) rect(-r, -r + (i * 2 * r / 7), r * 2, r / 7, "#B22234");
                rect(-r, -r, r, r * 0.8, "#3C3B6E");
            } else if (country === 'soviet') {
                rect(-r, -r, r * 2, r * 2, "#CC0000");
                ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(-r * 0.4, -r * 0.4, r * 0.25, 0, Math.PI * 2); ctx.fill();
            } else {
                rect(-r, -r, r * 2, r * 2, fallbackColor || "#333");
            }
        }

        // -------------------------------------------------------------------------
        // UI INTERACTION
        // -------------------------------------------------------------------------
        function toggleUI(mode) {
            currentState.menu = mode;
            document.getElementById('menu-container').style.display = mode === 'start' ? 'flex' : 'none';
            document.getElementById('hud').style.display = mode === 'playing' ? 'flex' : 'none';
            document.getElementById('chat-container').style.display = mode === 'playing' ? 'flex' : 'none';
            document.getElementById('death-screen').style.display = mode === 'death' ? 'block' : 'none';
            document.getElementById('spectator-label').style.display = currentState.isSpectating ? 'none' : 'none';
        }

        function renderSkinGrid() {
            const grid = document.getElementById('skin-grid');
            grid.innerHTML = '';
            const list = currentState.skinCategory === 'normal' ? SKINS_NORMAL : SKINS_SPECIAL;
            list.forEach(skin => {
                const unlocked = isSkinUnlocked(skin);
                const req = UNLOCK_CRITERIA[skin] || { label: "Locked" };
                const div = document.createElement('div');
                div.className = `skin-tile ${currentState.selectedSkin === skin ? 'selected' : ''} ${!unlocked ? 'locked' : ''}`;
                div.innerHTML = `
                    <div class="skin-color-dot" style="background: ${SKIN_BODY_COLORS[skin] || '#fff'}"></div>
                    <div style="font-size: 11px; font-weight: bold; text-transform: uppercase; color: ${unlocked ? 'white' : '#888'}">${skin.replace('_', ' ')}</div>
                    ${!unlocked ? `<div class="lock-text"> ${req.label}</div>` : ''}
                `;
                div.onclick = () => {
                    if (unlocked) { currentState.selectedSkin = skin; renderSkinGrid(); }
                };
                grid.appendChild(div);
            });
        }

        async function submitScoreToLeaderboard(scale) {
            if(!authReady) return;
            const size = parseFloat(scale.toFixed(2));
            try {
                const lbRef = collection(db, "leaderboard");
                const q = query(lbRef, where("name", "==", currentState.playerName));
                const snap = await getDocs(q);
                if (snap.empty) await addDoc(lbRef, { name: currentState.playerName, size: size, timestamp: serverTimestamp() });
                else {
                    const d = snap.docs[0];
                    if (size > d.data().size) updateDoc(doc(db, "leaderboard", d.id), { size: size });
                }
            } catch (e) { }
        }

        async function startScanner() {
            const scan = async () => {
                if(!authReady) return;
                try {
                    const q = query(collection(db, "active_games"), orderBy("lastBeat", "desc"), limit(20));
                    const snap = await getDocs(q);
                    const list = document.getElementById('spectate-list');
                    list.innerHTML = '';
                    document.getElementById('scan-status').innerText = "";
                    let found = 0;
                    const now = Date.now();
                    snap.docs.forEach(doc => {
                        const data = doc.data();
                        if (data.lastBeat && (now - data.lastBeat.toMillis() < 30000)) {
                            found++;
                            const row = document.createElement('div');
                            row.className = 'spectate-row';
                            row.innerHTML = `<div><b>${data.host}</b></div><div class="join-btn-style">JOIN</div>`;
                            row.onclick = () => initJoinGame(doc.id);
                            list.appendChild(row);
                        }
                    });
                    if (found === 0) list.innerHTML = '<div style="color:#666; font-size:12px; font-style:italic; padding:10px;">No active games found. Start one!</div>';
                } catch(e) { }
            };
            scan();
            setInterval(scan, 10000);

            try {
                onSnapshot(query(collection(db, "leaderboard"), orderBy("size", "desc"), limit(5)), (snap) => {
                    const div = document.getElementById('leaderboard-content');
                    div.innerHTML = '';
                    snap.docs.forEach((d, i) => {
                        const r = document.createElement('div');
                        r.className = 'row';
                        r.innerHTML = `<span style="color:${i === 0 ? '#FECB00' : 'white'}">${i + 1}. ${d.data().name}</span> <span style="color:#4caf50">${Math.round(d.data().size)}</span>`;
                        div.appendChild(r);
                    });
                });
            } catch(e) {}
        }

        function addChatMessage(name, text, color) {
            const container = document.getElementById('chat-messages');
            const el = document.createElement('div');
            el.className = 'chat-line';
            el.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}: </span>${text}`;
            container.appendChild(el);
            if (container.children.length > 9) container.removeChild(container.firstChild);
        }

        // -------------------------------------------------------------------------
        // EVENT LISTENERS
        // -------------------------------------------------------------------------
        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            keys[k] = true;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (document.activeElement === document.getElementById('chat-input') && k !== 'escape') return;
            
            // Toggle Admin Panel
            if (e.key === '`' || e.key === '~') {
                e.preventDefault();
                if (showOwnerPanel) {
                    showOwnerPanel = false;
                    document.getElementById('owner-control-panel').style.display = 'none';
                } else {
                    showOwnerLogin = !showOwnerLogin;
                    document.getElementById('owner-login-panel').style.display = showOwnerLogin ? 'block' : 'none';
                    if(showOwnerLogin) document.getElementById('owner-password').focus();
                }
            }
            
            // Respawn Key
            if(k === 'r' && currentState.menu === 'playing') {
                 if(currentState.isHost) {
                     // Handled in host update logic
                 } else if (hostConn && hostConn.open) {
                     // Client sends spawn request via logic handled in update loop? 
                     // Actually simplest is to send a re-spawn packet.
                     hostConn.send({ type: "JOIN_REQUEST", name: currentState.playerName, skin: currentState.selectedSkin });
                 }
            }
        });

        window.addEventListener('keyup', e => {
            if (document.activeElement === document.getElementById('chat-input')) return;
            keys[e.key.toLowerCase()] = false;
        });
        
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

        document.getElementById('btn-play').onclick = () => initHostGame(false); // Solo
        document.getElementById('btn-secret-host').onclick = () => initHostGame(true); // Public Multiplayer

        document.getElementById('btn-mouse').onclick = () => { currentState.controlMode = 'mouse'; document.getElementById('btn-mouse').classList.add('active'); document.getElementById('btn-keyboard').classList.remove('active'); };
        document.getElementById('btn-keyboard').onclick = () => { currentState.controlMode = 'keyboard'; document.getElementById('btn-keyboard').classList.add('active'); document.getElementById('btn-mouse').classList.remove('active'); };
        
        document.getElementById('cat-normal').onclick = () => { currentState.skinCategory = 'normal'; document.getElementById('cat-normal').classList.add('active'); document.getElementById('cat-special').classList.remove('active'); renderSkinGrid(); };
        document.getElementById('cat-special').onclick = () => { currentState.skinCategory = 'special'; document.getElementById('cat-special').classList.add('active'); document.getElementById('cat-normal').classList.remove('active'); renderSkinGrid(); };
        
        document.getElementById('nickname-input').oninput = (e) => { currentState.playerName = e.target.value; localStorage.setItem('bosnia_snake_username', e.target.value); };
        document.getElementById('nickname-input').value = currentState.playerName;

        document.getElementById('btn-redeem').onclick = () => {
            const code = document.getElementById('redeem-input').value;
            if (code === "Ireland_isgreat") {
                if(!isSkinUnlocked('ireland')) { updateStats({ unlockSecret: "ireland" }); alert("SUCCESS: Ireland Skin Unlocked!"); renderSkinGrid(); } else alert("Already Unlocked");
            } else alert("Invalid Code");
        };

        document.getElementById('chat-input').onkeydown = (e) => {
            if (e.key === 'Enter') {
                const text = e.target.value;
                if (text.trim()) {
                    if (currentState.isHost) {
                        const msg = { name: currentState.playerName, text: text, color: "#FECB00" };
                        addChatMessage(msg.name, msg.text, msg.color); playSound("chat"); broadcastChat(msg);
                    } else if (hostConn && hostConn.open) {
                        hostConn.send({ type: "CHAT", name: currentState.playerName, text: text });
                    }
                }
                e.target.value = ''; document.getElementById('game-canvas').focus();
            }
        };

        document.getElementById('btn-owner-login').onclick = () => {
            const pass = document.getElementById('owner-password').value;
            if(pass === OWNER_PASSWORD) {
                showOwnerLogin = false;
                document.getElementById('owner-login-panel').style.display = 'none';
                showOwnerPanel = true;
                document.getElementById('owner-control-panel').style.display = 'block';
                document.getElementById('cheat-msg').innerText = "ACCESS GRANTED";
                
                // --- SECRET UNLOCK ---
                document.getElementById('btn-secret-host').style.display = "block";
                
            } else { alert("ACCESS DENIED"); }
        };
        
        const setCheatMsg = (txt) => { const el = document.getElementById('cheat-msg'); el.innerText = txt; setTimeout(() => el.innerText = '', 2000); };
        document.getElementById('cheat-god').onclick = () => { cheats.godMode = !cheats.godMode; document.getElementById('cheat-god').innerText = "God Mode: " + (cheats.godMode ? "ON" : "OFF"); };
        document.getElementById('cheat-speed').onclick = () => { cheats.speedHack = !cheats.speedHack; document.getElementById('cheat-speed').innerText = "Speed Hack: " + (cheats.speedHack ? "ON" : "OFF"); };
        document.getElementById('cheat-size').onclick = () => { if(gameData.players.find(p=>p.id===0)) { const p = gameData.players.find(p=>p.id===0); p.scale = 50; p.length = 500; setCheatMsg("Size Set to 50"); } };
        document.getElementById('cheat-killbots').onclick = () => { gameData.enemies.forEach(e => { if(e.alive) killEnemy(e, null); }); setCheatMsg("Bots Cleared"); };
        document.getElementById('cheat-reset').onclick = () => { resetWorld(true); setCheatMsg("World Reset"); };

        // -------------------------------------------------------------------------
        // STARTUP
        // -------------------------------------------------------------------------
        updateStatsUI();
        renderSkinGrid();
        requestAnimationFrame(loop);

    </script>
</body>
</html>
