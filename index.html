<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Bosnia Snake - Ultimate Edition</title>
  <!-- PeerJS for Multiplayer/Spectating -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #080b12;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
      user-select: none;
      -webkit-user-select: none;
    }
    
    /* --- CANVAS --- */
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    /* --- UI OVERLAYS --- */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* Let clicks pass through to canvas */
    }

    /* --- MENUS (Enable pointer events for buttons) --- */
    .menu-container {
      pointer-events: auto;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      gap: 15px;
      height: 600px;
    }

    /* --- PANELS --- */
    .panel {
      background: rgba(0, 15, 60, 0.85);
      backdrop-filter: blur(20px);
      border: 2px solid #FECB00;
      border-radius: 10px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 0 40px rgba(0, 47, 108, 0.5);
    }

    /* --- START MENU SPECIFIC --- */
    #start-menu {
      width: 450px;
      align-items: center;
    }

    h1 {
      font-size: 40px;
      margin: 0 0 20px 0;
      color: #fff;
      text-shadow: 2px 2px 0px #002F6C, 0 0 15px #FECB00;
      text-align: center;
    }

    input[type="text"] {
      background: rgba(255,255,255,0.1);
      border: 1px solid #444;
      color: white;
      font-size: 16px;
      width: 90%;
      padding: 12px;
      text-align: center;
      border-radius: 5px;
      margin-bottom: 15px;
      outline: none;
    }

    button {
      width: 100%;
      padding: 15px;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      text-transform: uppercase;
      margin-top: 5px;
      transition: 0.2s;
    }

    .btn-blue {
      background: linear-gradient(to right, #002F6C, #0055A4);
      color: white;
    }
    .btn-blue:hover { filter: brightness(1.2); }

    /* --- SKIN GRID --- */
    #skin-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      width: 100%;
      height: 250px;
      overflow-y: auto;
      margin-bottom: 15px;
      padding-right: 5px;
    }

    .skin-item {
      background: rgba(255,255,255,0.05);
      border: 1px solid #333;
      border-radius: 5px;
      padding: 10px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      text-transform: capitalize;
    }
    .skin-item.selected {
      border-color: #FECB00;
      background: rgba(254, 203, 0, 0.2);
    }
    .skin-item.locked {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-bottom: 5px;
      border: 1px solid white;
    }

    /* --- HUD --- */
    #hud {
      display: none; /* Hidden on start */
      position: absolute;
      top: 20px;
      left: 20px;
      width: 220px;
      height: 50px;
      background: rgba(0, 15, 60, 0.7);
      border: 2px solid #0055A4;
      border-radius: 10px;
      color: white;
      font-weight: bold;
      font-size: 20px;
      align-items: center;
      justify-content: space-between;
      padding: 0 15px;
    }

    /* --- DEATH SCREEN --- */
    #death-screen {
      display: none;
      pointer-events: auto;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }
    .death-title {
      font-size: 60px;
      font-weight: 900;
      text-shadow: 2px 2px 0 black;
    }
    .respawn-btn {
      background: #FECB00;
      color: black;
      padding: 15px 30px;
      font-size: 20px;
      border-radius: 30px;
      margin-top: 20px;
      border: none;
      cursor: pointer;
    }

    /* --- CHAT --- */
    #chat-container {
      display: none;
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 300px;
      height: 200px;
      flex-direction: column;
      pointer-events: auto;
    }
    #chat-messages {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      margin-bottom: 5px;
      text-shadow: 1px 1px 1px black;
    }
    .chat-msg {
      background: rgba(0,0,0,0.4);
      padding: 2px 5px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 14px;
    }
    #chat-input {
      background: rgba(0,0,0,0.6);
      border: 1px solid #555;
      color: white;
      padding: 8px;
      border-radius: 5px;
    }
  </style>
</head>
<body>

  <canvas id="game-canvas"></canvas>

  <div id="ui-layer">
    
    <!-- MAIN MENU -->
    <div id="menu-overlay" class="menu-container">
      
      <!-- LEFT: STATS -->
      <div class="panel" style="width: 200px;">
        <h3 style="color:#FECB00; text-align:center; border-bottom:1px solid #333; padding-bottom:10px;">STATS</h3>
        <div id="stats-content" style="font-size: 14px; line-height: 2;">
          Loading...
        </div>
        <div style="margin-top: auto;">
          <input type="text" id="code-input" placeholder="Secret Code" style="width:85%; font-size:12px;">
          <button onclick="redeemCode()" style="background:#C6363C; color:white; padding:8px;">REDEEM</button>
        </div>
      </div>

      <!-- CENTER: PLAY -->
      <div id="start-menu" class="panel">
        <h1>BOSNIA SNAKE</h1>
        
        <div style="display:flex; width:100%; gap:10px; margin-bottom:15px;">
          <button id="btn-mouse" onclick="setControl('mouse')" class="btn-blue" style="background:#FECB00; color:black;">MOUSE</button>
          <button id="btn-keys" onclick="setControl('keys')" class="btn-blue" style="background:#222; color:#888;">KEYS</button>
        </div>

        <div style="width:100%; text-align:left; font-size:12px; color:#aaa; margin-bottom:5px;">SELECT SKIN</div>
        <div id="skin-grid"></div>

        <input type="text" id="nickname" placeholder="Nickname">
        <button onclick="startGame()" class="btn-blue">PLAY SOLO</button>
        
        <div style="margin-top:20px; width:100%; border-top:1px solid #333; padding-top:10px;">
          <div style="color:#FECB00; font-size:14px; font-weight:bold; margin-bottom:10px;">LIVE GAMES</div>
          <div id="spectate-list" style="height:100px; overflow-y:auto; font-size:12px;">
            <div style="color:#666; font-style:italic;">Scanning for games...</div>
          </div>
        </div>
      </div>

      <!-- RIGHT: LEADERBOARD -->
      <div class="panel" style="width: 200px;">
        <h3 style="color:#FECB00; text-align:center; border-bottom:1px solid #333; padding-bottom:10px;">TOP 5</h3>
        <div id="lb-content" style="font-size:14px;">Loading...</div>
      </div>
    </div>

    <!-- HUD -->
    <div id="hud">
      <span id="hud-size">Size: 18.0</span>
      <span id="hud-kills" style="color:#FECB00">Kills: 0</span>
    </div>

    <!-- CHAT -->
    <div id="chat-container">
      <div id="chat-messages"></div>
      <input type="text" id="chat-input" placeholder="Enter message..." onkeydown="handleChatKey(event)">
    </div>

    <!-- DEATH SCREEN -->
    <div id="death-screen">
      <div class="death-title">YOU DIED</div>
      <div style="font-size: 20px; margin-bottom: 20px;">Press R or Click below</div>
      <button class="respawn-btn" onclick="respawn()">RESPAWN</button>
    </div>

  </div>

  <!-- GAME LOGIC -->
  <script type="module">
    // --- FIREBASE IMPORTS ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
    import { getFirestore, collection, query, orderBy, limit, onSnapshot, addDoc, serverTimestamp, where, getDocs, updateDoc, doc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

    // --- CONFIG ---
    const firebaseConfig = {
      apiKey: "AIzaSyDfTRtLoB37SCPgAcQsxjmcuSPOHThuHNk",
      authDomain: "bosniasnake.firebaseapp.com",
      projectId: "bosniasnake",
      storageBucket: "bosniasnake.firebasestorage.app",
      messagingSenderId: "246754109806",
      appId: "1:246754109806:web:c58a4820f26478b69ab97f",
      measurementId: "G-FFQ2PJ3X5W"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // --- GLOBAL GAME VARIABLES ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // Constants
    const CELL = 150; 
    const GRID = 80;
    const WORLD_SIZE = CELL * GRID;
    const BASE_SPEED = 4.2;
    
    // State
    let myId = null;
    let myPlayerIndex = 0;
    let isHost = false;
    let isSpectating = false;
    let animationId;
    let peer = null;
    let connections = [];
    let hostConn = null;
    let lastSentTime = 0;
    
    // Inputs
    let mouseX = 0;
    let mouseY = 0;
    let keys = {};
    let controlMode = 'mouse';
    let selectedSkin = 'bosnia';
    let playerName = localStorage.getItem('bosnia_username') || "Player" + Math.floor(Math.random()*999);
    document.getElementById('nickname').value = playerName;

    // Stats
    let userStats = JSON.parse(localStorage.getItem('bosnia_stats_v2')) || {
      totalKills: 0, totalDeaths: 0, bestScale: 18, gamesPlayed: 0, unlockedSecrets: []
    };

    // Game World
    const gameState = {
      players: [],
      enemies: [],
      food: [],
      mines: [],
      explosions: [],
      syrupZones: [],
      shakeIntensity: 0
    };

    // Skin Config
    const SKINS = [
      { id: 'bosnia', color: '#002F6C', type: 'default' },
      { id: 'italy', color: '#008C45', type: 'default' },
      { id: 'germany', color: '#000000', label: 'Size 40', type: 'scale', val: 40 },
      { id: 'france', color: '#0055A4', label: '5 Deaths', type: 'deaths', val: 5 },
      { id: 'sweden', color: '#006AA7', label: '10 Kills', type: 'kills', val: 10 },
      { id: 'russia', color: '#FFFFFF', label: 'Size 50', type: 'scale', val: 50 },
      { id: 'usa', color: '#3C3B6E', label: 'Size 75', type: 'scale', val: 75 },
      { id: 'soviet', color: '#CC0000', label: 'Secret', type: 'custom_soviet' },
      { id: 'golden_maple', color: '#DAA520', label: 'Secret', type: 'custom_maple' },
      { id: 'ireland', color: '#169B62', label: 'Code', type: 'code' }
    ];

    // --- AUDIO ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const now = audioCtx.currentTime;
      const gainNode = audioCtx.createGain();
      gainNode.connect(audioCtx.destination);
      
      if (type === 'eat') {
        const osc = audioCtx.createOscillator();
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
        osc.connect(gainNode);
        gainNode.gain.setValueAtTime(0.05, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now); osc.stop(now+0.1);
      } else if (type === 'boom') {
        // Simple boom
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.connect(gainNode);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(now); osc.stop(now+0.5);
      }
    }

    // --- AUTH & INIT ---
    signInAnonymously(auth).then(() => {
      console.log("Logged in anonymously");
      scanGames();
      loadLeaderboard();
      updateStatsUI();
      renderSkinGrid();
    });

    // --- MENU LOGIC ---
    window.setControl = (mode) => {
      controlMode = mode;
      document.getElementById('btn-mouse').style.background = mode === 'mouse' ? '#FECB00' : '#222';
      document.getElementById('btn-mouse').style.color = mode === 'mouse' ? 'black' : '#888';
      document.getElementById('btn-keys').style.background = mode === 'keys' ? '#FECB00' : '#222';
      document.getElementById('btn-keys').style.color = mode === 'keys' ? 'black' : '#888';
    };

    window.redeemCode = () => {
      const code = document.getElementById('code-input').value;
      if(code === "Ireland_isgreat") {
        if(!userStats.unlockedSecrets.includes('ireland')) {
          userStats.unlockedSecrets.push('ireland');
          saveStats();
          alert("Unlocked: Ireland!");
          renderSkinGrid();
        }
      } else {
        alert("Invalid Code");
      }
    };

    function isUnlocked(skin) {
      if(skin.type === 'default') return true;
      if(skin.type === 'kills') return userStats.totalKills >= skin.val;
      if(skin.type === 'deaths') return userStats.totalDeaths >= skin.val;
      if(skin.type === 'scale') return userStats.bestScale >= skin.val;
      if(skin.type === 'code') return userStats.unlockedSecrets.includes(skin.id);
      if(skin.id === 'soviet') return userStats.bestScale >= 500 && userStats.totalKills >= 50;
      return false;
    }

    function renderSkinGrid() {
      const grid = document.getElementById('skin-grid');
      grid.innerHTML = '';
      SKINS.forEach(skin => {
        const unlocked = isUnlocked(skin);
        const div = document.createElement('div');
        div.className = `skin-item ${unlocked ? '' : 'locked'} ${selectedSkin === skin.id ? 'selected' : ''}`;
        div.innerHTML = `
          <div class="color-dot" style="background:${skin.color}"></div>
          <div>${skin.id}</div>
          ${!unlocked ? `<div style="color:#f55; margin-top:5px;">ðŸ”’ ${skin.label || 'Locked'}</div>` : ''}
        `;
        div.onclick = () => {
          if(unlocked) {
            selectedSkin = skin.id;
            renderSkinGrid();
          }
        };
        grid.appendChild(div);
      });
    }

    function updateStatsUI() {
      document.getElementById('stats-content').innerHTML = `
        Kills: <span style="color:#FECB00">${userStats.totalKills}</span><br>
        Deaths: <span style="color:#FECB00">${userStats.totalDeaths}</span><br>
        Best Size: <span style="color:#FECB00">${userStats.bestScale.toFixed(1)}</span><br>
        Games: <span style="color:#FECB00">${userStats.gamesPlayed}</span>
      `;
    }

    function saveStats() {
      localStorage.setItem('bosnia_stats_v2', JSON.stringify(userStats));
      updateStatsUI();
    }

    // --- GAME START ---
    window.startGame = () => {
      const nameIn = document.getElementById('nickname').value;
      if(nameIn) {
        playerName = nameIn;
        localStorage.setItem('bosnia_username', playerName);
      }

      document.getElementById('menu-overlay').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      document.getElementById('chat-container').style.display = 'flex';

      userStats.gamesPlayed++;
      saveStats();

      // Init PeerJS Host
      if(peer) peer.destroy();
      peer = new Peer();
      
      peer.on('open', (id) => {
        myId = id;
        isHost = true;
        isSpectating = false;
        
        // Publish to Firebase
        setDoc(doc(db, "active_games", id), {
          host: playerName,
          lastBeat: serverTimestamp()
        });
        setInterval(() => {
          setDoc(doc(db, "active_games", id), {
            host: playerName,
            lastBeat: serverTimestamp()
          });
        }, 5000);

        // Setup Player
        gameState.players = [{
          id: 0, active: true, dead: false,
          x: 0, y: 0, angle: -Math.PI/2,
          body: [], length: 140, scale: 18,
          country: selectedSkin,
          color: SKINS.find(s=>s.id===selectedSkin).color,
          kills: 0, deaths: 0,
          frozenUntil: 0, // WILL BE SET IN RESET
          name: playerName
        }];

        // Spawn world
        resetWorld(true);

        // Game Loop
        requestAnimationFrame(gameLoop);
        
        // Handle connections
        peer.on('connection', (conn) => {
          connections.push(conn);
          conn.on('data', (data) => {
            if(data.type === 'CHAT') {
              addChat(data.name, data.text, "#aaa");
              // Broadcast
              connections.forEach(c => { if(c.open) c.send({type:'CHAT_MSG', name:data.name, text:data.text, color:"#aaa"}); });
            }
          });
        });
      });
    };

    // --- RESPAWN & RESET ---
    window.respawn = () => {
      resetWorld(true);
      document.getElementById('death-screen').style.display = 'none';
    };

    function resetWorld(spawnBots) {
      gameState.food = [];
      gameState.mines = [];
      gameState.explosions = [];
      
      // Generate Food
      for(let i=0; i<400; i++) {
        let l = 1;
        if(Math.random() < 0.5) l++;
        gameState.food.push({ x: randPos(), y: randPos(), level: l });
      }

      // Generate Mines
      for(let i=0; i<80; i++) {
        gameState.mines.push({ x: randPos(), y: randPos(), state: 'idle', lastTick: 0 });
      }

      // Reset Player
      const p = gameState.players[0];
      p.x = randPos();
      p.y = randPos();
      p.body = [{x: p.x, y: p.y}]; // FIX VISUAL
      p.length = 140;
      p.scale = 18;
      p.dead = false;
      p.frozenUntil = Date.now() + 2000; // FIX: SPAWN PROTECTION
      p.abilityActive = false;

      // Spawn Bots
      if(spawnBots) {
        gameState.enemies = [];
        for(let i=0; i<8; i++) spawnBot();
      }
    }

    function spawnBot() {
      gameState.enemies.push({
        x: randPos(), y: randPos(),
        angle: Math.random() * 6.28,
        body: [],
        length: 140 + Math.random()*200,
        width: 12,
        alive: true,
        color: ['#8A2BE2', '#DC143C', '#228B22'][Math.floor(Math.random()*3)],
        baseScale: 12
      });
    }

    function randPos() {
      return (Math.random() * GRID * CELL) - (WORLD_SIZE/2);
    }

    // --- GAME LOGIC ---
    function gameLoop() {
      const now = Date.now();
      
      if(isHost && !gameState.players[0].dead) {
        updatePhysics();
        updateBots();
        updateEnvironment();

        // Broadcast State
        if(now - lastSentTime > 50) {
          const pack = {
            p: gameState.players.map(p => ({x:Math.round(p.x), y:Math.round(p.y), a:p.angle, s:p.scale, d:p.dead, n:p.name, f:p.frozenUntil})),
            e: gameState.enemies.map(e => ({x:Math.round(e.x), y:Math.round(e.y), w:e.width, c:e.color})),
            m: gameState.mines.map(m => ({x:m.x, y:m.y, s:m.state}))
            // Food is too heavy to send constantly, usually synced less often or seeded
          };
          connections.forEach(c => { if(c.open) c.send({type:'STATE', state:pack}); });
          lastSentTime = now;
        }
      }

      render();
      requestAnimationFrame(gameLoop);
    }

    function updatePhysics() {
      const p = gameState.players[0];
      const now = Date.now();

      // Ability Logic (Soviet)
      if(p.country === 'soviet' && keys['e']) {
         // (Simulated ability logic here for brevity)
         p.abilityActive = true; 
      }

      // Movement
      let targetAngle = p.angle;
      if(controlMode === 'mouse') {
        targetAngle = Math.atan2(mouseY - window.innerHeight/2, mouseX - window.innerWidth/2);
      } else {
        let dx=0, dy=0;
        if(keys['w']||keys['ArrowUp']) dy=-1;
        if(keys['s']||keys['ArrowDown']) dy=1;
        if(keys['a']||keys['ArrowLeft']) dx=-1;
        if(keys['d']||keys['ArrowRight']) dx=1;
        if(dx||dy) targetAngle = Math.atan2(dy, dx);
      }

      // Smooth Turn
      let diff = targetAngle - p.angle;
      while(diff <= -Math.PI) diff += Math.PI*2;
      while(diff > Math.PI) diff -= Math.PI*2;
      p.angle += diff * 0.1;

      // Sprint
      let speed = BASE_SPEED;
      if(keys[' '] || keys['Shift']) {
        if(p.length > 140) {
          speed *= 1.8;
          p.length -= 0.5;
        }
      }

      // Move (FIX: ALLOW MOVEMENT IF FROZEN)
      p.x += Math.cos(p.angle) * speed;
      p.y += Math.sin(p.angle) * speed;

      // Bounds
      if(Math.abs(p.x) > WORLD_SIZE/2 || Math.abs(p.y) > WORLD_SIZE/2) killPlayer(p);

      // Body Update
      p.body.unshift({x:p.x, y:p.y});
      while(p.body.length > p.length) p.body.pop();

      // UI Update
      if(now % 200 < 20) {
         document.getElementById('hud-size').innerText = "Size: " + p.scale.toFixed(1);
         document.getElementById('hud-kills').innerText = "Kills: " + p.kills;
      }
    }

    function updateBots() {
      const p = gameState.players[0];
      const now = Date.now();

      gameState.enemies.forEach(e => {
        if(!e.alive) return;
        
        // Simple AI: Move towards player if close, else wander
        let distToP = Math.hypot(p.x - e.x, p.y - e.y);
        let targetA = e.angle;
        
        if(distToP < 500 && !p.dead && !p.frozenUntil > now) {
          targetA = Math.atan2(p.y - e.y, p.x - e.x);
        } else {
           // Wander
           if(Math.random() < 0.05) targetA += (Math.random()-0.5);
        }

        // Smooth Turn
        let diff = targetA - e.angle;
        while(diff <= -Math.PI) diff += Math.PI*2;
        while(diff > Math.PI) diff -= Math.PI*2;
        e.angle += diff * 0.08;

        e.x += Math.cos(e.angle) * 3;
        e.y += Math.sin(e.angle) * 3;

        // Body
        e.body.unshift({x:e.x, y:e.y});
        if(e.length < 1000) e.length += 0.1; // Grow slowly
        while(e.body.length > e.length) e.body.pop();

        // Collisions with Player
        if(!p.dead) {
          // FIX: Invincibility Check
          const isSafe = p.frozenUntil && now < p.frozenUntil;
          
          // Bot hits Player Head
          if(!isSafe && Math.hypot(p.x - e.x, p.y - e.y) < p.scale + e.width) {
            killPlayer(p);
          }
          // Player hits Bot Body
          for(let i=0; i<e.body.length; i+=5) {
             if(!isSafe && Math.hypot(p.x - e.body[i].x, p.y - e.body[i].y) < p.scale + e.width) {
               killPlayer(p);
             }
          }
          // Bot hits Player Body
          for(let i=0; i<p.body.length; i+=5) {
             if(Math.hypot(e.x - p.body[i].x, e.y - p.body[i].y) < e.width + p.scale) {
               e.alive = false;
               createExplosion(e.x, e.y);
               p.kills++;
               userStats.totalKills++;
               saveStats();
             }
          }
        }
      });
    }

    function updateEnvironment() {
      const p = gameState.players[0];
      const now = Date.now();

      // Food
      for(let i=gameState.food.length-1; i>=0; i--) {
        const f = gameState.food[i];
        if(Math.hypot(p.x - f.x, p.y - f.y) < p.scale + 10) {
          gameState.food.splice(i, 1);
          p.length += 5 * f.level;
          p.scale += 0.1 * f.level;
          playSound('eat');
          // Replenish
          let l = 1; if(Math.random()<0.5)l++;
          gameState.food.push({x:randPos(), y:randPos(), level:l});
        }
      }

      // Mines
      gameState.mines.forEach(m => {
        if(m.state === 'idle') {
           if(Math.hypot(p.x - m.x, p.y - m.y) < 200) {
             m.state = 'triggered';
             m.lastTick = now;
           }
        } else if(m.state === 'triggered') {
           if(now - m.lastTick > 3000) {
             // Boom
             m.state = 'exploded'; // remove next frame
             createExplosion(m.x, m.y);
             playSound('boom');
             
             // FIX: CHECK INVINCIBILITY
             if(Math.hypot(p.x - m.x, p.y - m.y) < 300) {
               if(p.frozenUntil < now) killPlayer(p);
             }
           }
        }
      });
      gameState.mines = gameState.mines.filter(m => m.state !== 'exploded');

      // Explosions
      gameState.explosions.forEach(ex => { ex.r += 10; ex.a -= 0.05; });
      gameState.explosions = gameState.explosions.filter(ex => ex.a > 0);
    }

    function createExplosion(x, y) {
      gameState.explosions.push({x:x, y:y, r:10, a:1.0});
    }

    function killPlayer(p) {
      if(p.dead) return;
      p.dead = true;
      createExplosion(p.x, p.y);
      playSound('boom');
      
      // Update Stats
      userStats.totalDeaths++;
      if(p.scale > userStats.bestScale) userStats.bestScale = p.scale;
      saveStats();
      submitScore(p.scale);

      // Show Death Screen
      document.getElementById('death-screen').style.display = 'block';
    }

    // --- RENDER ---
    function render() {
      // Resize
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const p = isSpectating ? (gameState.players[0] || {x:0,y:0}) : gameState.players[0];
      if(!p) return;

      const camX = p.x;
      const camY = p.y;
      
      // Calculate Zoom based on size
      let zoom = Math.max(0.1, 0.6 * (30 / (30 + (p.scale || 18 - 18) * 0.4)));
      
      ctx.fillStyle = '#080b12';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.save();
      ctx.translate(canvas.width/2, canvas.height/2);
      ctx.scale(zoom, zoom);
      ctx.translate(-camX, -camY);

      // Grid
      ctx.lineWidth = 5;
      ctx.strokeStyle = '#1a1f2e';
      const startX = Math.floor((camX - canvas.width/zoom)/CELL)*CELL;
      const endX = Math.floor((camX + canvas.width/zoom)/CELL)*CELL;
      const startY = Math.floor((camY - canvas.height/zoom)/CELL)*CELL;
      const endY = Math.floor((camY + canvas.height/zoom)/CELL)*CELL;
      
      ctx.beginPath();
      for(let x=startX; x<=endX; x+=CELL) { ctx.moveTo(x, startY); ctx.lineTo(x, endY+CELL*10); }
      for(let y=startY; y<=endY; y+=CELL) { ctx.moveTo(startX, y); ctx.lineTo(endX+CELL*10, y); }
      ctx.stroke();

      // World Border
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 20;
      ctx.strokeRect(-WORLD_SIZE/2, -WORLD_SIZE/2, WORLD_SIZE, WORLD_SIZE);

      // Food
      gameState.food.forEach(f => {
        ctx.fillStyle = f.level > 1 ? '#FFD700' : 'orange';
        ctx.beginPath();
        ctx.arc(f.x, f.y, 10 + f.level*2, 0, Math.PI*2);
        ctx.fill();
      });

      // Mines
      gameState.mines.forEach(m => {
        ctx.fillStyle = '#222';
        ctx.strokeStyle = m.state === 'triggered' ? 'red' : '#444';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 35, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        
        // Serbia Flag Detail
        ctx.fillStyle = '#C6363C'; ctx.fillRect(m.x-20, m.y-20, 40, 13);
        ctx.fillStyle = '#0C4076'; ctx.fillRect(m.x-20, m.y-7, 40, 13);
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(m.x-20, m.y+6, 40, 13);
        
        if(m.state === 'triggered') {
          const timeLeft = (3000 - (Date.now() - m.lastTick)) / 1000;
          ctx.fillStyle = 'white';
          ctx.font = '20px Arial';
          ctx.fillText(timeLeft.toFixed(1), m.x-10, m.y);
          
          // Blast radius warning
          ctx.beginPath();
          ctx.arc(m.x, m.y, 300, 0, Math.PI*2);
          ctx.fillStyle = 'rgba(255,0,0,0.1)';
          ctx.fill();
        }
      });

      // Bots
      gameState.enemies.forEach(e => {
        if(!e.alive) return;
        ctx.strokeStyle = e.color;
        ctx.lineWidth = e.width * 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        if(e.body.length) {
          ctx.moveTo(e.body[0].x, e.body[0].y);
          for(let i=1; i<e.body.length; i++) ctx.lineTo(e.body[i].x, e.body[i].y);
        }
        ctx.stroke();
        // Head
        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.width, 0, Math.PI*2);
        ctx.fill();
      });

      // Player
      if(p && !p.dead) {
        // Invincibility Effect
        if(p.frozenUntil > Date.now()) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = 'cyan';
        }

        ctx.strokeStyle = p.color || 'white';
        ctx.lineWidth = p.scale * 1.2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.beginPath();
        if(p.body.length) {
          ctx.moveTo(p.body[0].x, p.body[0].y);
          for(let i=1; i<p.body.length; i++) ctx.lineTo(p.body[i].x, p.body[i].y);
        }
        ctx.stroke();
        
        // Remove shadow
        ctx.shadowBlur = 0;

        // Head (Flag)
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle + Math.PI/2);
        ctx.beginPath();
        ctx.arc(0, 0, p.scale*0.65, 0, Math.PI*2);
        ctx.clip();
        
        // Draw Flag based on ID (simplified for standard canvas)
        const r = p.scale * 0.65;
        if(p.country === 'bosnia') {
          ctx.fillStyle = '#002F6C'; ctx.fillRect(-r,-r,r*2,r*2);
          ctx.fillStyle = '#FECB00'; ctx.beginPath(); ctx.moveTo(r*0.2,-r); ctx.lineTo(r*0.2,r); ctx.lineTo(r,-r*0.5); ctx.fill();
        } else if (p.country === 'soviet') {
           ctx.fillStyle = '#CC0000'; ctx.fillRect(-r,-r,r*2,r*2);
           ctx.fillStyle = '#FFD700'; ctx.font=`${r}px Arial`; ctx.fillText('â˜…', -r/2, r/3);
        } else {
           ctx.fillStyle = p.color; ctx.fillRect(-r,-r,r*2,r*2);
        }
        
        ctx.restore();
      }

      // Explosions
      gameState.explosions.forEach(ex => {
        ctx.fillStyle = `rgba(255,100,0,${ex.a})`;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.r, 0, Math.PI*2);
        ctx.fill();
      });

      ctx.restore();
    }

    // --- LEADERBOARD ---
    async function loadLeaderboard() {
      const q = query(collection(db, "leaderboard"), orderBy("size", "desc"), limit(5));
      onSnapshot(q, (snap) => {
        const div = document.getElementById('lb-content');
        div.innerHTML = '';
        let i = 1;
        snap.forEach(doc => {
          const d = doc.data();
          div.innerHTML += `<div style="display:flex; justify-content:space-between; margin-bottom:5px;">
            <span>${i++}. ${d.name.substring(0,10)}</span>
            <span style="color:#4caf50">${Math.round(d.size)}</span>
          </div>`;
        });
      });
    }

    async function submitScore(size) {
      if(size < 20) return;
      const name = playerName || "Anon";
      const col = collection(db, "leaderboard");
      // Simplified: Just add, real app should update existing
      addDoc(col, { name: name, size: size, timestamp: serverTimestamp() });
    }

    // --- SPECTATING ---
    async function scanGames() {
      const q = query(collection(db, "active_games"), orderBy("lastBeat", "desc"), limit(10));
      onSnapshot(q, (snap) => {
        const list = document.getElementById('spectate-list');
        list.innerHTML = '';
        snap.forEach(doc => {
          const d = doc.data();
          // Check if active (within last 30s)
          // Note: Firestore timestamps need conversion, handled loosely here
          const btn = document.createElement('div');
          btn.style.cssText = "padding:5px; background:#222; margin-bottom:5px; cursor:pointer; display:flex; justify-content:space-between;";
          btn.innerHTML = `<span>${d.host}</span> <span style="color:#0f0">WATCH</span>`;
          btn.onclick = () => spectateGame(doc.id);
          list.appendChild(btn);
        });
      });
    }

    window.spectateGame = (hostId) => {
      if(peer) peer.destroy();
      peer = new Peer();
      peer.on('open', () => {
        const conn = peer.connect(hostId);
        conn.on('open', () => {
          isSpectating = true;
          isHost = false;
          document.getElementById('menu-overlay').style.display = 'none';
          document.getElementById('chat-container').style.display = 'flex';
          
          conn.on('data', (data) => {
             if(data.type === 'STATE') {
                // Apply State
                // Needs smoothing in real app, simply setting here
                gameState.players = data.state.p.map(p=>({
                  x:p.x, y:p.y, angle:p.a, scale:p.s, dead:p.d, name:p.n, frozenUntil:p.f,
                  color: 'white', body: [], length: 100 // Visual dummies
                }));
                gameState.enemies = data.state.e.map(e=>({
                  x:e.x, y:e.y, width:e.w, color:e.c, body:[], alive:true
                }));
                gameState.mines = data.state.m.map(m=>({x:m.x, y:m.y, state:m.s}));
             }
             if(data.type === 'CHAT_MSG') {
               addChat(data.name, data.text, data.color);
             }
          });
        });
      });
    };

    // --- CHAT ---
    window.handleChatKey = (e) => {
      if(e.key === 'Enter') {
        const txt = document.getElementById('chat-input').value;
        if(txt && isHost) {
          addChat(playerName, txt, "#FECB00");
          connections.forEach(c => c.send({type:'CHAT_MSG', name:playerName, text:txt, color:"#FECB00"}));
          document.getElementById('chat-input').value = '';
        }
      }
    };
    function addChat(name, text, color) {
      const box = document.getElementById('chat-messages');
      const div = document.createElement('div');
      div.className = 'chat-msg';
      div.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}:</span> ${text}`;
      box.appendChild(div);
      box.scrollTop = box.scrollHeight;
    }

    // --- EVENTS ---
    window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
    window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
    window.addEventListener('keydown', e => { 
      if(document.activeElement.tagName === 'INPUT') return;
      keys[e.key] = true; 
      if(e.key === 'r' && gameState.players[0]?.dead) respawn();
    });
    window.addEventListener('keyup', e => keys[e.key] = false);

  </script>
</body>
</html>
