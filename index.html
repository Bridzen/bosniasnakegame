<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bosnia Snake: Ultimate World Edition</title>
    <!-- PeerJS for Multiplayer Networking -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <style>
        /* --- GLOBAL STYLES --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #080b12;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI LAYER WRAPPER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        /* --- HEADS UP DISPLAY (HUD) --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 240px;
            height: 60px;
            background: rgba(0, 15, 60, 0.7);
            border: 2px solid #0055A4;
            border-radius: 10px;
            display: none; /* Hidden on start */
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 85, 164, 0.4);
        }

        #hud-size { 
            font-weight: bold; 
            font-size: 22px; 
            text-shadow: 1px 1px 2px black;
        }

        #hud-kills { 
            font-weight: bold; 
            font-size: 16px; 
            color: #FECB00; 
            text-shadow: 1px 1px 2px black;
        }

        /* --- ABILITY INDICATOR (For Special Skins) --- */
        #ability-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(0,0,0,0.6);
            border-radius: 50%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 4px solid #555;
            transition: border-color 0.3s;
        }
        #ability-text {
            font-weight: bold;
            font-size: 14px;
            color: white;
        }
        #ability-sub {
            font-size: 10px;
            color: #ddd;
        }

        /* --- SPECTATOR LABEL --- */
        #spectator-label {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 0px 0px 5px black;
            display: none;
            color: cyan;
            letter-spacing: 2px;
        }

        /* --- MENU SYSTEM --- */
        #menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 15px;
            height: 700px;
            pointer-events: auto;
            z-index: 20;
        }

        .panel {
            background: rgba(0, 15, 60, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid #FECB00;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(0, 47, 108, 0.5);
            display: flex;
            flex-direction: column;
            padding: 25px;
        }

        #stats-panel {
            width: 240px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #leaderboard-panel {
            width: 250px;
            background: rgba(0, 35, 149, 0.6);
            border: 1px solid rgba(254, 203, 0, 0.3);
        }

        #main-menu {
            width: 520px;
            overflow-y: auto;
            position: relative;
        }

        h1 {
            font-size: 50px;
            font-weight: 900;
            text-align: center;
            margin: 0 0 30px 0;
            color: #fff;
            text-shadow: 2px 2px 0px #002F6C, 0 0 15px #FECB00;
        }

        .header-text {
            color: #FECB00;
            font-size: 18px;
            font-weight: 900;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-bottom: 2px solid #002F6C;
            padding-bottom: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* --- FORM ELEMENTS --- */
        input[type="text"], input[type="password"] {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: white;
            font-size: 16px;
            width: 100%;
            padding: 15px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 15px;
            outline: none;
            box-sizing: border-box;
            transition: background 0.2s, border 0.2s;
        }
        input[type="text"]:focus, input[type="password"]:focus {
            background: rgba(255,255,255,0.2);
            border-color: #FECB00;
        }

        button {
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn-primary {
            width: 100%;
            padding: 18px;
            background: linear-gradient(to right, #002F6C, #0055A4);
            color: white;
            font-size: 16px;
            margin-top: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
        }
        .btn-primary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0,0,0,0.3);
        }

        .btn-redeem {
            width: 100%;
            padding: 10px;
            background: linear-gradient(to right, #C6363C, #800000);
            color: white;
            font-size: 12px;
            margin-top: 5px;
        }

        .btn-toggle {
            flex: 1;
            padding: 12px;
            background: #222;
            color: #888;
        }
        .btn-toggle.active {
            background: #FECB00;
            color: black;
            box-shadow: 0 0 10px #FECB00;
        }

        /* --- SKIN GRID --- */
        #skin-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            overflow-y: auto;
            flex: 1;
            margin-bottom: 20px;
            min-height: 250px;
            padding-right: 5px;
        }

        .skin-tile {
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
        }
        .skin-tile:hover {
            background: rgba(255,255,255,0.1);
        }
        .skin-tile.selected {
            background: rgba(254, 203, 0, 0.2);
            border-color: #FECB00;
            box-shadow: 0 0 10px rgba(254, 203, 0, 0.2);
        }
        .skin-tile.locked {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .skin-color-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.8);
            margin-bottom: 8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .lock-text {
            font-size: 9px;
            color: #ff5555;
            font-weight: bold;
            margin-top: 5px;
            text-align: center;
            text-transform: uppercase;
        }

        /* --- CHAT SYSTEM --- */
        #chat-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 320px;
            height: 250px;
            display: none;
            flex-direction: column;
            pointer-events: auto;
            z-index: 100;
        }
        #chat-messages {
            flex: 1;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
            padding-right: 5px;
        }
        .chat-line {
            font-size: 14px;
            margin-bottom: 4px;
            background: rgba(0,0,0,0.4);
            padding: 4px 8px;
            border-radius: 4px;
            word-wrap: break-word;
        }
        #chat-input {
            background: rgba(0,0,0,0.6);
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 4px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
        }

        /* --- SPECTATE LIST --- */
        #spectate-list {
            max-height: 140px;
            overflow-y: auto;
        }
        .spectate-row {
            padding: 12px;
            background: #222;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        .spectate-row:hover { background: #333; }
        
        /* --- DEATH SCREEN --- */
        #death-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            pointer-events: none;
            z-index: 50;
        }
        .death-title {
            font-size: 60px;
            font-weight: 900;
            color: #fff;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
        }
        .death-sub {
            font-size: 24px;
            color: #ccc;
            text-shadow: 1px 1px 0 #000;
        }

        /* --- OWNER / CHEAT PANELS --- */
        #owner-login-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: black;
            padding: 15px;
            border: 2px solid red;
            z-index: 999;
            display: none;
        }
        #owner-control-panel {
            position: absolute;
            top: 60px;
            left: 10px;
            width: 150px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border: 2px solid red;
            color: white;
            z-index: 999;
            display: none;
            box-shadow: 0 0 20px red;
        }
        .cheat-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            background: #330000;
            color: red;
            border: 1px solid red;
            font-size: 11px;
        }
        .cheat-btn:hover {
            background: red;
            color: black;
        }
        #cheat-msg {
            text-align: center;
            color: cyan;
            font-weight: bold;
            margin-top: 10px;
            font-size: 12px;
            height: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        ::-webkit-scrollbar-thumb { background: #FECB00; border-radius: 3px; }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-layer">
        
        <!-- GAME HUD -->
        <div id="hud">
            <div id="hud-size">Size: 18.0</div>
            <div id="hud-kills">Kills: 0</div>
        </div>

        <!-- ABILITY HUD -->
        <div id="ability-indicator">
            <div id="ability-text">READY</div>
            <div id="ability-sub">ABILITY</div>
        </div>

        <div id="spectator-label">SPECTATOR MODE</div>

        <!-- MENU CONTAINER -->
        <div id="menu-container">
            <!-- Left Stats -->
            <div id="stats-panel" class="panel">
                <div class="header-text">Stats</div>
                <div class="row"><span>KILLS</span><span id="stat-kills" style="color: #FECB00">0</span></div>
                <div class="row"><span>DEATHS</span><span id="stat-deaths" style="color: #FECB00">0</span></div>
                <div class="row"><span>BEST SIZE</span><span id="stat-best-size" style="color: #FECB00">18.0</span></div>
                <div class="row"><span>GAMES</span><span id="stat-games" style="color: #FECB00">0</span></div>
                <div class="row"><span>MAX LENGTH</span><span id="stat-length" style="color: #FECB00">140</span></div>
                
                <div style="margin-top: auto; padding-top: 15px; border-top: 1px solid #333;">
                    <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">SECRET CODE</div>
                    <input type="text" id="redeem-input" style="font-size: 12px; padding: 10px; margin-bottom: 8px;" placeholder="Enter Code...">
                    <button id="btn-redeem" class="btn-redeem">REDEEM CODE</button>
                </div>
            </div>

            <!-- Main Menu Center -->
            <div id="main-menu" class="panel">
                <h1>BOSNIA SNAKE</h1>

                <!-- Control Mode -->
                <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                    <button id="btn-mouse" class="btn-toggle active">MOUSE CONTROL</button>
                    <button id="btn-keyboard" class="btn-toggle">KEYBOARD CONTROL</button>
                </div>

                <!-- Skin Selection -->
                <div style="font-size: 12px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;">SELECT SKIN</div>
                <div style="display: flex; margin-bottom: 10px; gap: 5px;">
                    <button id="cat-normal" class="btn-toggle active" style="padding: 8px; font-size: 12px;">NATIONAL</button>
                    <button id="cat-special" class="btn-toggle" style="padding: 8px; font-size: 12px;">SPECIAL / SECRET</button>
                </div>

                <div id="skin-grid"></div>

                <input type="text" id="nickname-input" placeholder="ENTER NICKNAME">
                <button id="btn-play" class="btn-primary">PLAY SOLO</button>

                <!-- Spectate List -->
                <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;">
                    <div style="color: #FECB00; font-weight: bold; margin-bottom: 10px; font-size: 14px;">
                        LIVE GAMES <span id="scan-status" style="font-size: 10px; color: #666; font-weight: normal;">(Scanning...)</span>
                    </div>
                    <div id="spectate-list">
                        <div style="color: #666; font-size: 12px; font-style: italic; padding: 10px;">Initializing scanner...</div>
                    </div>
                </div>
            </div>

            <!-- Leaderboard -->
            <div id="leaderboard-panel" class="panel">
                <div class="header-text">Top 5</div>
                <div id="leaderboard-content">
                    <div style="text-align: center; color: #888; margin-top: 20px;">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Chat -->
        <div id="chat-container">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Type to chat (Enter to send)...">
        </div>

        <!-- Death Screen -->
        <div id="death-screen">
            <div class="death-title">YOU DIED</div>
            <div class="death-sub">Press 'R' to Restart</div>
        </div>

        <!-- OWNER / CHEAT PANELS -->
        <div id="owner-login-panel">
            <div style="color:red; font-size:12px; margin-bottom:5px;">OWNER ACCESS</div>
            <input type="password" id="owner-password" placeholder="Password">
            <button id="btn-owner-login" style="width:100%; background:red; color:white; padding:5px;">LOGIN</button>
        </div>

        <div id="owner-control-panel">
            <div style="text-align:center; margin-bottom:10px; border-bottom:1px solid red;">CHEATS</div>
            <button class="cheat-btn" id="cheat-god">God Mode: OFF</button>
            <button class="cheat-btn" id="cheat-speed">Speed Hack: OFF</button>
            <button class="cheat-btn" id="cheat-size">Set Size 50</button>
            <button class="cheat-btn" id="cheat-killbots">Kill All Bots</button>
            <button class="cheat-btn" id="cheat-reset">Reset World</button>
            <div id="cheat-msg"></div>
        </div>

    </div>

    <!-- MAIN LOGIC -->
    <script type="module">
        // -------------------------------------------------------------------------
        // IMPORTS (Firebase)
        // -------------------------------------------------------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { 
            getFirestore, collection, query, orderBy, limit, onSnapshot, 
            addDoc, serverTimestamp, where, getDocs, updateDoc, doc, setDoc, deleteDoc 
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // -------------------------------------------------------------------------
        // POLYFILL (For RoundRect in older browsers)
        // -------------------------------------------------------------------------
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // -------------------------------------------------------------------------
        // FIREBASE CONFIGURATION
        // -------------------------------------------------------------------------
        const firebaseConfig = {
            apiKey: "AIzaSyDFtRTloB37SCPGacQSxjmcuSPOHTHutNk",
            authDomain: "bosniasnake.firebaseapp.com",
            projectId: "bosniasnake",
            storageBucket: "bosniasnake.firebasestorage.app",
            messagingSenderId: "246754109806",
            appId: "1:246754109806:web:c58a4820f26478b69ab97f",
            measurementId: "G-FFQ2PJ3X5W"
        };

        let app, db, auth;
        let authReady = false;

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            signInAnonymously(auth).then(() => {
                console.log("Connected to Firebase (Anonymous)");
                authReady = true;
                startScanner(); // Start scanning for games once auth is ready
            }).catch(err => {
                console.error("Auth Error:", err);
                alert("Game Server Connection Failed: " + err.message);
            });
        } catch(e) {
            console.error("Firebase Init Failed", e);
        }

        // -------------------------------------------------------------------------
        // GAME CONFIGURATION CONSTANTS
        // -------------------------------------------------------------------------
        const OWNER_PASSWORD = "Roblox13_isme";
        const CELL = 150;
        const GRID = 80;
        const WORLD_SIZE = CELL * GRID;
        const MIN_LENGTH = 140;
        const SPRINT_COST = 0.5;
        
        // Tuning
        const BASE_SPEED = 4.2;
        const TURN_SPEED = 0.09;
        const MAX_ENEMIES = 8; // Number of AI
        
        // NERF: SIZE GAIN REDUCED
        const SIZE_GAIN_PER_LEVEL = 0.15; // Was 0.25
        
        const FOOD_RADIUS_BASE = 6;
        const LENGTH_GAIN = 8;
        const BROADCAST_RATE = 50; // ms
        const INTERPOLATION_SPEED = 0.2;

        // Skin Lists
        const SKINS_NORMAL = [
            "bosnia", "russia", "germany", "france", "canada", "ukraine", 
            "usa", "uk", "italy", "poland", "sweden", "denmark"
        ];
        const SKINS_SPECIAL = ["ireland", "soviet", "golden_maple"];

        const SKIN_BODY_COLORS = {
            bosnia: "#002F6C", russia: "#FFFFFF", germany: "#000000", france: "#0055A4", 
            canada: "#FF0000", ukraine: "#0057B8", ireland: "#169B62", soviet: "#CC0000", 
            golden_maple: "#DAA520", usa: "#3C3B6E", uk: "#012169", italy: "#008C45", 
            poland: "#DC143C", sweden: "#006AA7", denmark: "#C60C30", serbia: "#C6363C"
        };

        const UNLOCK_CRITERIA = {
            bosnia: { type: "default", label: "Default" },
            russia: { type: "scale", val: 50, label: "Reach Size 50" },
            germany: { type: "scale", val: 40, label: "Reach Size 40" },
            france: { type: "deaths", val: 5, label: "Die 5 Times" },
            canada: { type: "length", val: 1000, label: "Reach Length 1k" },
            ukraine: { type: "games", val: 5, label: "Play 5 Games" },
            usa: { type: "scale", val: 75, label: "Reach Size 75" },
            uk: { type: "length", val: 800, label: "Reach Length 800" },
            italy: { type: "default", label: "Default" },
            poland: { type: "deaths", val: 15, label: "Die 15 Times" },
            sweden: { type: "kills", val: 10, label: "Get 10 Kills" },
            denmark: { type: "kills", val: 25, label: "Get 25 Kills" },
            ireland: { type: "code", label: "Secret Code" },
            soviet: { type: "custom_soviet", label: "Russia + Size 500 + 50 Kills" },
            golden_maple: { type: "custom_maple", label: "Canada + Size 250 + 150 Kills" },
        };

        // -------------------------------------------------------------------------
        // AUDIO ENGINE
        // -------------------------------------------------------------------------
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (!audioCtx) return;
            if (audioCtx.state === "suspended") audioCtx.resume();

            const now = audioCtx.currentTime;
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            if (type === "eat") {
                const osc = audioCtx.createOscillator();
                osc.type = "sine";
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === "soviet_boom") {
                const bufferSize = audioCtx.sampleRate * 1.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = "lowpass";
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.exponentialRampToValueAtTime(10, now + 1);
                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.gain.setValueAtTime(0.8, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1);
                noise.start(now);
                noise.stop(now + 1.5);
            } else if (type === "angelic") { // Maple Ability
                const freqs = [523.25, 659.25, 783.99];
                freqs.forEach((f, i) => {
                    const osc = audioCtx.createOscillator();
                    osc.type = "triangle";
                    osc.frequency.value = f;
                    if (i === 1) osc.detune.value = 5;
                    if (i === 2) osc.detune.value = -5;
                    osc.connect(gainNode);
                    osc.start(now);
                    osc.stop(now + 2.5);
                });
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.08, now + 0.5);
                gainNode.gain.linearRampToValueAtTime(0, now + 2.5);
            } else if (type === "chat") {
                const osc = audioCtx.createOscillator();
                osc.type = "sine";
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        // -------------------------------------------------------------------------
        // GLOBAL STATE VARIABLES
        // -------------------------------------------------------------------------
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // User Settings & Stats
        let currentState = {
            menu: 'start', // start, playing, death
            controlMode: 'mouse', // mouse, keyboard
            skinCategory: 'normal',
            selectedSkin: 'bosnia',
            playerName: localStorage.getItem('bosnia_snake_username') || "Player" + Math.floor(Math.random() * 999),
            isHost: false,
            isSpectating: false,
            myId: null,
            myPlayerIndex: 0
        };

        // Persistent Stats
        let userStats = {
            totalKills: 0,
            totalDeaths: 0,
            bestScale: 18,
            bestLength: 140,
            gamesPlayed: 0,
            unlockedSecrets: []
        };
        try {
            const loaded = localStorage.getItem('bosnia_snake_stats_v2');
            if(loaded) userStats = JSON.parse(loaded);
        } catch(e) { console.warn("Failed to load stats"); }

        // Cheats
        const cheats = { godMode: false, speedHack: false };
        let showOwnerLogin = false;
        let showOwnerPanel = false;

        // Networking
        let peer = null;
        let connections = []; // Host: array of spectator connections
        let hostConn = null; // Client: connection to host
        let lastSentTime = 0;
        let serverState = null; // For interpolation

        // Input
        const mouse = { x: 0, y: 0 };
        const keys = {};

        // Game World Data (The Engine State)
        let gameData = {
            mode: null,
            players: [],
            enemies: [], // Bots
            food: [],
            mines: [],
            explosions: [],
            syrupZones: [], // Maple ability
            shakeIntensity: 0,
            gameOver: false
        };

        // -------------------------------------------------------------------------
        // HELPER FUNCTIONS (Math & Logic)
        // -------------------------------------------------------------------------
        function randPosCell() { return Math.floor(Math.random() * GRID) * CELL - WORLD_SIZE / 2; }
        function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
        function coll(a, b, r) { return dist(a, b) < r; }
        function normalizeAngle(angle) { return Math.atan2(Math.sin(angle), Math.cos(angle)); }
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function lerpAngle(a, b, t) {
            const da = (b - a) % (2 * Math.PI);
            const twoD = ((2 * da) % (2 * Math.PI)) - da;
            return a + twoD * t;
        }

        // -------------------------------------------------------------------------
        // STATS & UNLOCK LOGIC
        // -------------------------------------------------------------------------
        function updateStatsUI() {
            document.getElementById('stat-kills').innerText = userStats.totalKills;
            document.getElementById('stat-deaths').innerText = userStats.totalDeaths;
            document.getElementById('stat-best-size').innerText = userStats.bestScale.toFixed(1);
            document.getElementById('stat-games').innerText = userStats.gamesPlayed;
            document.getElementById('stat-length').innerText = Math.round(userStats.bestLength);
        }

        function isSkinUnlocked(skin) {
            // Master Unlock Check
            if (userStats.unlockedSecrets.includes("MASTER_UNLOCK")) return true;

            const req = UNLOCK_CRITERIA[skin];
            if (!req) return true;
            if (skin === "soviet") {
                return isSkinUnlocked("russia") && userStats.bestScale >= 500 && userStats.totalKills >= 50;
            }
            if (skin === "golden_maple") {
                return isSkinUnlocked("canada") && userStats.bestScale >= 250 && userStats.totalKills >= 150;
            }
            if (req.type === "default") return true;
            if (req.type === "code") return userStats.unlockedSecrets.includes(skin);
            if (req.type === "kills") return userStats.totalKills >= req.val;
            if (req.type === "deaths") return userStats.totalDeaths >= req.val;
            if (req.type === "scale") return userStats.bestScale >= req.val;
            if (req.type === "length") return userStats.bestLength >= req.val;
            if (req.type === "games") return userStats.gamesPlayed >= req.val;
            return false;
        }

        function updateStats(updates) {
            let changed = false;
            if (updates.kill) { userStats.totalKills++; changed = true; }
            if (updates.death) { userStats.totalDeaths++; changed = true; }
            if (updates.game) { userStats.gamesPlayed++; changed = true; }
            if (updates.unlockSecret && !userStats.unlockedSecrets.includes(updates.unlockSecret)) {
                userStats.unlockedSecrets.push(updates.unlockSecret);
                changed = true;
            }
            if (updates.scale && updates.scale > userStats.bestScale) {
                userStats.bestScale = updates.scale; changed = true;
            }
            if (updates.length && updates.length > userStats.bestLength) {
                userStats.bestLength = updates.length; changed = true;
            }
            if (changed) {
                localStorage.setItem('bosnia_snake_stats_v2', JSON.stringify(userStats));
                updateStatsUI();
                renderSkinGrid(); // Refresh locks
            }
        }

        // -------------------------------------------------------------------------
        // GAME INITIALIZATION (Networking)
        // -------------------------------------------------------------------------
        
        // --- HOST (Single Player) ---
        function initSinglePlayer() {
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', (id) => {
                currentState.myId = id;
                currentState.isHost = true;
                currentState.isSpectating = false;
                currentState.myPlayerIndex = 0;
                currentState.menu = 'playing';

                // Publish presence to Firestore
                if(authReady) {
                    const docRef = doc(db, "active_games", id);
                    const publish = () => setDoc(docRef, { 
                        host: currentState.playerName, 
                        lastBeat: serverTimestamp() 
                    }).catch(e => console.warn("Presence err", e));
                    
                    publish();
                    const hb = setInterval(publish, 5000);
                    peer.on('disconnected', () => clearInterval(hb));
                }

                updateStats({ game: true });

                // Initialize Game Objects
                gameData.mode = "single";
                gameData.players = [{
                    id: 0,
                    active: true,
                    x: 0,
                    y: 0,
                    angle: -Math.PI / 2,
                    body: [],
                    length: 140,
                    dead: false,
                    country: currentState.selectedSkin,
                    colorBody: SKIN_BODY_COLORS[currentState.selectedSkin],
                    scale: 18,
                    kills: 0,
                    deaths: 0,
                    frozenUntil: 0,
                    abilityActive: false,
                    lastAbilityTime: 0,
                    maplePhase: null,
                    name: currentState.playerName
                }];
                
                resetWorld(true);
                toggleUI('playing');
                addChatMessage("System", "Welcome to Single Player! Room ID: " + id, "lime");

                // Listen for Spectators
                peer.on('connection', (conn) => {
                    connections.push(conn);
                    conn.on('data', (data) => {
                        if (data.type === "CHAT") {
                            const msg = { name: data.name, text: data.text, color: "#aaa" };
                            addChatMessage(msg.name, msg.text, msg.color);
                            broadcastChat(msg);
                            playSound("chat");
                        }
                    });
                    conn.on('close', () => {
                        connections = connections.filter(c => c !== conn);
                    });
                });
            });
        }

        // --- CLIENT (Spectator) ---
        function initSpectate(idToJoin) {
            if (!idToJoin) return;
            if (peer) peer.destroy();
            peer = new Peer();

            peer.on('open', () => {
                const conn = peer.connect(idToJoin);
                hostConn = conn;
                currentState.isHost = false;
                currentState.isSpectating = true;

                conn.on('open', () => {
                    currentState.menu = 'playing';
                    toggleUI('playing');
                    addChatMessage("System", "Connected to Host.", "cyan");
                });

                conn.on('data', (data) => {
                    if (data.type === "STATE") {
                        serverState = data.state;
                        // Initial Load
                        if (gameData.players.length === 0 && serverState) {
                            gameData = JSON.parse(JSON.stringify(serverState));
                            gameData.players.forEach(p => p.body = p.body || []);
                            gameData.enemies.forEach(e => e.body = e.body || []);
                        }
                    }
                    if (data.type === "CHAT_MSG") {
                        addChatMessage(data.msg.name, data.msg.text, data.msg.color);
                        playSound("chat");
                    }
                });

                conn.on('close', () => {
                    alert("Host Disconnected");
                    location.reload();
                });
            });
            peer.on('error', err => alert("Spectate Error: " + err.type));
        }

        function broadcastChat(msg) {
            connections.forEach(c => { if (c.open) c.send({ type: "CHAT_MSG", msg }); });
        }

        // -------------------------------------------------------------------------
        // GAME LOGIC CORE
        // -------------------------------------------------------------------------
        function resetWorld(spawnBots) {
            const s = gameData;
            s.food = [];
            s.mines = [];
            s.explosions = [];
            s.syrupZones = [];
            s.shakeIntensity = 0;
            s.gameOver = false;

            // Generate Food
            for (let i = 0; i < 400; i++) {
                let level = 1;
                while (level < 100 && Math.random() < 0.5) level++;
                s.food.push({ x: randPosCell(), y: randPosCell(), level: level });
            }

            // Generate Mines
            for (let i = 0; i < 80; i++) {
                s.mines.push({
                    x: randPosCell(),
                    y: randPosCell(),
                    state: "idle",
                    timer: 3.0,
                    lastTick: Date.now()
                });
            }

            // Reset Players
            s.players.forEach((p) => {
                p.x = randPosCell();
                p.y = randPosCell();
                p.body = [];
                p.length = 140;
                p.scale = 18;
                p.dead = false;
                p.frozenUntil = 0;
                p.abilityActive = false;
                p.lastAbilityTime = 0;
                p.maplePhase = null;
                // Soviet Reset
                p.barrageActive = false;
                p.barrageStartTime = 0;
                p.nextExplosionTime = 0;
                p.sovietBoost = false;
            });

            // Enemies
            s.enemies = [];
            if (spawnBots) {
                for (let i = 0; i < MAX_ENEMIES; i++) spawnOneEnemy();
            }
        }

        function spawnOneEnemy() {
            // NERFED SPAWN LENGTH
            const startLen = 180 + Math.random() * 150; 
            const startWidth = 14;

            gameData.enemies.push({
                x: randPosCell(),
                y: randPosCell(),
                angle: Math.random() * Math.PI * 2,
                body: [],
                length: startLen,
                width: startWidth,
                baseScale: startWidth,
                speed: (2.5 + Math.random()) * 1.1,
                boostSpeed: 7.5 * 1.1,
                turnSpeed: 0.08,
                alive: true,
                // ALL AI ARE SERBIA
                color: "#C6363C", 
                country: "serbia",
                frozenUntil: 0,
                inZoneSince: null,
                outZoneSince: null,
                isEnraged: false
            });
        }

        function getLocalInput() {
            if (currentState.isSpectating) return { targetAngle: null, sprint: false, triggerAbility: false, respawn: false };

            const sprint = keys['shift'] || keys['/'];
            const triggerAbility = keys['e'];
            const respawn = keys[' '];

            let targetAngle = null;
            if (currentState.controlMode === 'mouse') {
                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                targetAngle = Math.atan2(mouse.y - cy, mouse.x - cx);
            } else {
                let dx = 0, dy = 0;
                if (keys['w'] || keys['arrowup']) dy -= 1;
                if (keys['s'] || keys['arrowdown']) dy += 1;
                if (keys['a'] || keys['arrowleft']) dx -= 1;
                if (keys['d'] || keys['arrowright']) dx += 1;
                if (dx !== 0 || dy !== 0) targetAngle = Math.atan2(dy, dx);
            }
            return { targetAngle, sprint, triggerAbility, respawn };
        }

        // --- MAIN UPDATE LOOP (HOST) ---
        function updateHostLogic() {
            const p = gameData.players[0];
            const inp = getLocalInput();

            if (p && p.dead) {
                if (keys['r']) {
                     resetWorld(true);
                     toggleUI('playing');
                }
                return;
            }

            // Spawn/Prune Bots
            gameData.enemies = gameData.enemies.filter(e => e.alive);
            if (gameData.enemies.length < MAX_ENEMIES && Math.random() < 0.02) spawnOneEnemy();

            // Logic
            if (p) handlePhysics(p, inp);
            updateAI(); 
            if (p) updateEnvironment([p]);
        }

        // --- PHYSICS & ABILITIES ---
        function handlePhysics(p, inp) {
            const now = Date.now();
            if (p.frozenUntil > now) return;

            // ABILITIES
            // 1. SOVIET
            if (p.country === "soviet") {
                // Trigger
                if (inp.sprint && !p.barrageActive && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000)) {
                    p.barrageActive = true;
                    p.barrageEndTime = now + 2000;
                    p.nextExplosionTime = now;
                    p.abilityActive = true;
                }
                // Active State
                if (p.barrageActive) {
                    if (now >= p.barrageEndTime) {
                        p.barrageActive = false;
                        p.abilityActive = false;
                        p.sovietBoost = false;
                        p.lastAbilityTime = now;
                    } else {
                        p.sovietBoost = true;
                        if (now >= p.nextExplosionTime) {
                            createExplosion(p.x, p.y, 3 * CELL);
                            gameData.shakeIntensity = Math.min(60, gameData.shakeIntensity + 10);
                            p.nextExplosionTime = now + 200;
                            playSound("soviet_boom");
                            // Kill nearby enemies
                            gameData.enemies.forEach(e => {
                                if (e.alive && dist(e, p) < 3 * CELL) killEnemy(e, p);
                            });
                        }
                    }
                }
            }
            // 2. GOLDEN MAPLE
            else if (p.country === "golden_maple") {
                if (inp.triggerAbility && (!p.lastAbilityTime || now - p.lastAbilityTime > 60000) && !p.maplePhase) {
                    p.maplePhase = "harvest";
                    p.phaseEndTime = now + 2500;
                    p.lastAbilityTime = now;
                    playSound("angelic");
                }
                if (p.maplePhase === "harvest") {
                    if (now > p.phaseEndTime) {
                        p.maplePhase = "syrup";
                        p.phaseEndTime = now + 5000;
                        gameData.syrupZones.push({ x: p.x, y: p.y, radius: 6 * CELL, expiresAt: now + 5000, ownerId: p.id });
                    }
                } else if (p.maplePhase === "syrup") {
                    if (now > p.phaseEndTime) p.maplePhase = null;
                }
            }

            // MOVEMENT
            let speedMult = 1.0;
            let turnMult = 1.0;

            // Syrup Slowdown
            gameData.syrupZones.forEach(zone => {
                if (dist(p, zone) < zone.radius && zone.ownerId !== p.id) {
                    speedMult = 0.4;
                    turnMult = 0.33;
                }
            });

            // Turning
            if (inp.targetAngle !== null) {
                let d = normalizeAngle(inp.targetAngle - p.angle);
                const effectiveTurnSpeed = TURN_SPEED * turnMult;
                if (Math.abs(d) < effectiveTurnSpeed) p.angle = inp.targetAngle;
                else p.angle += d > 0 ? effectiveTurnSpeed : -effectiveTurnSpeed;
                p.angle = normalizeAngle(p.angle);
            }

            // Speed
            let s = BASE_SPEED * speedMult;
            if (p.id === currentState.myPlayerIndex && cheats.speedHack) s = BASE_SPEED * 3;

            const canSprint = inp.sprint && p.length > MIN_LENGTH && (!p.abilityActive || p.country === "soviet");
            if (canSprint) {
                s *= 1.8;
                if (p.sovietBoost) s *= 2.0;
                p.length -= SPRINT_COST;
            }

            // Apply
            p.x += Math.cos(p.angle) * s;
            p.y += Math.sin(p.angle) * s;

            // World Bounds Death
            if (Math.abs(p.x) > WORLD_SIZE / 2 || Math.abs(p.y) > WORLD_SIZE / 2) {
                killPlayer(p, null);
            }

            // Body Trailing
            p.body.unshift({ x: p.x, y: p.y });
            while (p.body.length > p.length) p.body.pop();
        }

        // --- ADVANCED AI (Updated: Survival Focus) ---
        function updateAI() {
            const state = gameData;
            const viewDist = 500;
            const now = Date.now();
            
            // New Evasion Parameters
            const DETECTION_RADIUS = 300; 

            state.enemies.forEach((enemy) => {
                if (!enemy.alive) return;
                if (enemy.frozenUntil && now < enemy.frozenUntil) return;

                // Scale Logic (Normal scale growth now)
                if (!enemy.baseScale) enemy.baseScale = 12;
                const currentCalculatedWidth = 12 + Math.min(30, (enemy.length - 140) / 10); 
                if (currentCalculatedWidth > enemy.baseScale) enemy.baseScale = currentCalculatedWidth;
                enemy.width = enemy.baseScale;

                // Syrup Effect
                let aiSpeedMult = 1.0;
                let aiTurnMult = 1.0;
                state.syrupZones.forEach((zone) => {
                    if (dist(enemy, zone) < zone.radius) { aiSpeedMult = 0.4; aiTurnMult = 0.33; }
                });

                let forceSprint = false;
                let targetAngle = enemy.angle;
                
                // SURVIVAL CHECK (PRIORITY 1)
                // Check distance to player head AND body
                let dangerSource = null;
                let minDangerDist = Infinity;

                state.players.forEach((p) => {
                    if (!p.dead && p.active) {
                        // Check head
                        let d = dist(enemy, p);
                        if(d < DETECTION_RADIUS + p.scale) {
                             if(d < minDangerDist) { minDangerDist = d; dangerSource = p; }
                        }
                        // Check body segments
                        for(let i=0; i<p.body.length; i+=3) {
                             d = dist(enemy, p.body[i]);
                             if(d < DETECTION_RADIUS + p.scale) {
                                 if(d < minDangerDist) { minDangerDist = d; dangerSource = p.body[i]; }
                             }
                        }
                    }
                });

                if (dangerSource) {
                    // EVADE MODE: Run directly away from threat
                    targetAngle = Math.atan2(enemy.y - dangerSource.y, enemy.x - dangerSource.x);
                    forceSprint = true;
                } else {
                    // Normal Behavior: Hunt Food
                    let closestFood = null;
                    let minFoodDist = Infinity;
                    state.food.forEach((f) => {
                        const d = dist(enemy, f);
                        if (d < minFoodDist && d < 600) { minFoodDist = d; closestFood = f; }
                    });
                    if (closestFood) targetAngle = Math.atan2(closestFood.y - enemy.y, closestFood.x - enemy.x);
                    
                    // Simple Wall Avoidance
                    const lim = WORLD_SIZE/2 - 100;
                    if(enemy.x < -lim) targetAngle = 0;
                    else if(enemy.x > lim) targetAngle = Math.PI;
                    else if(enemy.y < -lim) targetAngle = Math.PI/2;
                    else if(enemy.y > lim) targetAngle = -Math.PI/2;
                }

                // Apply AI Movement
                let diff = normalizeAngle(targetAngle - enemy.angle);
                const turn = (forceSprint ? enemy.turnSpeed * 1.5 : enemy.turnSpeed) * aiTurnMult;

                if (Math.abs(diff) < turn) enemy.angle = targetAngle;
                else if (diff > 0) enemy.angle += turn;
                else enemy.angle -= turn;
                enemy.angle = normalizeAngle(enemy.angle);

                const spd = (forceSprint && enemy.length > 145 ? enemy.boostSpeed : enemy.speed) * aiSpeedMult;
                if (forceSprint && enemy.length > 145) enemy.length -= 0.3;

                enemy.x += Math.cos(enemy.angle) * spd;
                enemy.y += Math.sin(enemy.angle) * spd;
                enemy.body.unshift({ x: enemy.x, y: enemy.y });
                while (enemy.body.length > enemy.length) enemy.body.pop();

                // Eat
                for (let i = state.food.length - 1; i >= 0; i--) {
                    if (coll(enemy, state.food[i], enemy.width + 10)) {
                        state.food.splice(i, 1);
                        enemy.length += 12; // Normal growth
                    }
                }

                state.players.forEach((p) => {
                    if (!p.dead && p.active) {
                        if (coll(p, enemy, p.scale + enemy.width)) killPlayer(p, null);
                        // Check if Player hits AI body
                         for (let j = 0; j < p.body.length; j += 2)
                            if (coll(enemy, p.body[j], enemy.width + p.scale)) killEnemy(enemy, p);
                    }
                });
            });
        }

        // --- ENVIRONMENT LOGIC ---
        function updateEnvironment(activePlayers) {
            const s = gameData;
            const now = Date.now();
            
            // Syrup Expiry
            for (let i = s.syrupZones.length - 1; i >= 0; i--) {
                if (now > s.syrupZones[i].expiresAt) s.syrupZones.splice(i, 1);
            }
            // Explosion Fade
            for (let i = s.explosions.length - 1; i >= 0; i--) {
                s.explosions[i].radius += 15;
                s.explosions[i].alpha -= 0.05;
                if (s.explosions[i].alpha <= 0) s.explosions.splice(i, 1);
            }
            // Food Respawn
            if (s.food.length < 400) {
                for (let k = 0; k < 10; k++) {
                    let level = 1;
                    while (level < 100 && Math.random() < 0.5) level++;
                    s.food.push({ x: randPosCell(), y: randPosCell(), level: level });
                }
            }
            // Maple Harvest Effect (Turn food gold)
            activePlayers.forEach((p) => {
                if (p.country === "golden_maple" && p.maplePhase === "harvest") {
                    s.food.forEach((f) => { if (dist(p, f) < 5 * CELL) f.isGolden = true; });
                }
            });
            // Food Collision
            s.food.forEach((f, i) => {
                const foodLevel = f.level || 1;
                const rad = FOOD_RADIUS_BASE + foodLevel * 1.5;
                activePlayers.forEach((p) => {
                    if (!p.dead && coll(p, f, p.scale + rad)) {
                        if (p.id === currentState.myPlayerIndex) playSound("eat");
                        s.food.splice(i, 1);
                        const multiplier = f.isGolden ? 3 : 1;
                        p.length += LENGTH_GAIN * multiplier;
                        // NERFED SIZE GAIN, CAP 2000
                        p.scale = Math.min(2000, p.scale + foodLevel * SIZE_GAIN_PER_LEVEL * multiplier);
                    }
                });
            });
            // Mines Logic
            for (let i = s.mines.length - 1; i >= 0; i--) {
                let m = s.mines[i];
                if (m.state === "idle") {
                    let triggered = false;
                    activePlayers.forEach((p) => { if (!p.dead && dist(p, m) < 200) triggered = true; });
                    if (triggered) { m.state = "triggered"; m.lastTick = now; }
                } else if (m.state === "triggered") {
                    if (now - m.lastTick > m.timer * 1000) {
                        createExplosion(m.x, m.y);
                        activePlayers.forEach((p) => { if (!p.dead && dist(p, m) < 300) killPlayer(p, null); });
                        s.mines.splice(i, 1);
                    }
                }
            }
        }

        // --- DEATH & COMBAT HELPERS ---
        function createExplosion(x, y, radius = 10) {
            gameData.explosions.push({ x, y, radius: radius, alpha: 1.0 });
            gameData.shakeIntensity = Math.min(100, gameData.shakeIntensity + 30);
        }

        function killPlayer(victim, killer) {
            if (victim.dead) return;
            if (victim.id === currentState.myPlayerIndex && cheats.godMode) return;
            
            victim.dead = true;
            victim.deaths++;
            victim.abilityActive = false;
            victim.maplePhase = null;

            if (victim.id === currentState.myPlayerIndex) {
                updateStats({ death: true, scale: victim.scale, length: victim.length });
                submitScoreToLeaderboard(victim.scale);
                toggleUI('death');
            }

            if (killer) {
                killer.kills++;
                if (killer.id === currentState.myPlayerIndex) updateStats({ kill: true });
            }

            createExplosion(victim.x, victim.y);
            // Drop Body as Food
            const totalValue = victim.length * 0.4;
            const foodCount = Math.max(3, Math.floor(totalValue / LENGTH_GAIN));
            for (let k = 0; k < foodCount; k++) {
                const index = Math.floor(Math.random() * victim.body.length);
                if (victim.body[index]) {
                    gameData.food.push({ x: victim.body[index].x, y: victim.body[index].y, level: Math.floor(Math.random() * 3) + 1 });
                }
            }
        }

        function killEnemy(e, killer) {
            if (!e.alive) return;
            e.alive = false;
            if (killer) {
                killer.kills++;
                if (killer.id === currentState.myPlayerIndex) updateStats({ kill: true });
            }
            createExplosion(e.x, e.y);
            // Drop Body
            const totalValue = e.length * 0.4;
            const foodCount = Math.max(3, Math.floor(totalValue / LENGTH_GAIN));
            const stepSize = Math.max(1, Math.floor(e.body.length / foodCount));
            for (let i = 0; i < e.body.length; i += stepSize) {
                const point = e.body[i];
                if(point) gameData.food.push({ x: point.x + (Math.random() - 0.5) * 20, y: point.y + (Math.random() - 0.5) * 20, level: Math.floor(Math.random() * 3) + 1 });
            }
        }

        // --- NETWORK DATA COMPRESSION ---
        function compressState(state) {
            return {
                mode: state.mode,
                shakeIntensity: Math.round(state.shakeIntensity),
                food: state.food.map((f) => ({ x: Math.round(f.x), y: Math.round(f.y), l: f.level, g: f.isGolden ? 1 : 0 })),
                mines: state.mines.map((m) => ({ x: Math.round(m.x), y: Math.round(m.y), state: m.state })),
                explosions: state.explosions.map((e) => ({
                    x: Math.round(e.x), y: Math.round(e.y), radius: Math.round(e.radius), alpha: Number(e.alpha.toFixed(2))
                })),
                syrupZones: state.syrupZones.map((s) => ({ x: Math.round(s.x), y: Math.round(s.y), radius: s.radius, oid: s.ownerId })),
                players: state.players.map((p) => ({
                    id: p.id, active: p.active, dead: p.dead, x: Math.round(p.x), y: Math.round(p.y),
                    angle: Number(p.angle.toFixed(2)), scale: Number(p.scale.toFixed(2)), length: Math.round(p.length),
                    country: p.country, colorBody: p.colorBody, kills: p.kills, deaths: p.deaths,
                    frozenUntil: p.frozenUntil || 0, abilityActive: p.abilityActive || false, maplePhase: p.maplePhase, name: p.name
                })),
                enemies: state.enemies.map((e) => ({
                    alive: e.alive, color: e.color, width: Math.round(e.width), x: Math.round(e.x), y: Math.round(e.y),
                    angle: Number(e.angle.toFixed(2)), frozenUntil: e.frozenUntil || 0
                })),
            };
        }

        // -------------------------------------------------------------------------
        // RENDER LOOP
        // -------------------------------------------------------------------------
        function loop(timestamp) {
            requestAnimationFrame(loop);

            // Responsive Canvas
            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            // Draw Menu Background
            if (currentState.menu !== 'playing' && currentState.menu !== 'death') {
                ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "rgba(0, 47, 108, 0.2)"; ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
                for (let j = 0; j < canvas.height; j += 50) { ctx.beginPath(); ctx.moveTo(0, j); ctx.lineTo(canvas.width, j); ctx.stroke(); }
                return;
            }

            // Game Logic Updates
            if (currentState.isHost) {
                if (timestamp % 1000 < 16 && gameData.players[0] && !gameData.players[0].dead) {
                    updateStats({ scale: gameData.players[0].scale, length: gameData.players[0].length });
                }
                updateHostLogic();
                // Broadcast
                if (timestamp - lastSentTime > BROADCAST_RATE) {
                    const payload = { type: "STATE", state: compressState(gameData) };
                    connections.forEach(c => { if (c.open) c.send(payload); });
                    lastSentTime = timestamp;
                }
            } 
            else if (currentState.isSpectating && serverState) {
                // Interpolate
                const t = INTERPOLATION_SPEED;
                const cur = gameData; 
                const tar = serverState;
                
                // Sync global ents
                cur.food = tar.food.map(f => ({x:f.x, y:f.y, level:f.l, isGolden: f.g===1}));
                cur.mines = tar.mines;
                cur.explosions = tar.explosions;
                cur.syrupZones = (tar.syrupZones||[]).map(s => ({x:s.x, y:s.y, radius:s.radius, ownerId:s.oid}));
                cur.shakeIntensity = tar.shakeIntensity;

                // Sync Players
                cur.players.forEach((p, i) => {
                    const tp = tar.players[i];
                    if (tp) {
                        p.x = lerp(p.x, tp.x, t); p.y = lerp(p.y, tp.y, t);
                        p.angle = lerpAngle(p.angle, tp.angle, t);
                        p.scale = tp.scale; p.country = tp.country; p.dead = tp.dead;
                        p.name = tp.name; p.abilityActive = tp.abilityActive; p.maplePhase = tp.maplePhase;
                        if (!p.body) p.body = [];
                        p.body.unshift({ x: p.x, y: p.y });
                        while (p.body.length > tp.length) p.body.pop();
                    }
                });

                // Sync Enemies
                 if (cur.enemies.length !== tar.enemies.length) cur.enemies = tar.enemies.map((e) => ({ ...e, body: [] }));
                 cur.enemies.forEach((e, i) => {
                     const te = tar.enemies[i];
                     if(te) {
                         e.x = lerp(e.x, te.x, t); e.y = lerp(e.y, te.y, t);
                         e.alive = te.alive; e.width = te.width; e.color = te.color;
                         if (e.alive) {
                            e.body.unshift({ x: e.x, y: e.y });
                            while (e.body.length > 140) e.body.pop();
                         }
                     }
                 });
            }

            // HUD Update
            const me = gameData.players[0] || {};
            if(!currentState.isSpectating) {
                document.getElementById('hud-size').innerText = "Size: " + (me.scale || 18).toFixed(1);
                document.getElementById('hud-kills').innerText = "Kills: " + (me.kills || 0);
            }

            // Ability HUD
            const abInd = document.getElementById('ability-indicator');
            const abTxt = document.getElementById('ability-text');
            if(me.country === 'soviet' || me.country === 'golden_maple') {
                abInd.style.display = 'flex';
                const cooldown = 60000;
                const timeSince = Date.now() - (me.lastAbilityTime || 0);
                const isActive = me.barrageActive || !!me.maplePhase;
                
                if (isActive) {
                    abTxt.innerText = "ACTIVE";
                    abInd.style.borderColor = (Math.floor(Date.now()/200)%2===0) ? "#fff" : "#0f0";
                    abTxt.style.color = "#0f0";
                } else if (timeSince < cooldown) {
                    const rem = Math.ceil((cooldown - timeSince)/1000);
                    abTxt.innerText = rem + "s";
                    abInd.style.borderColor = "#555";
                    abTxt.style.color = "#aaa";
                } else {
                    abTxt.innerText = "READY";
                    abInd.style.borderColor = "#FFD700";
                    abTxt.style.color = "#FFD700";
                }
            } else {
                abInd.style.display = 'none';
            }

            // --- DRAWING ---
            ctx.fillStyle = "#080b12"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Grid
            ctx.strokeStyle = "rgba(0, 47, 108, 0.2)"; ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
            for (let j = 0; j < canvas.height; j += 50) { ctx.beginPath(); ctx.moveTo(0, j); ctx.lineTo(canvas.width, j); ctx.stroke(); }

            // Camera Transform
            let sx = 0, sy = 0;
            if (gameData.shakeIntensity > 0) {
                sx = (Math.random() - 0.5) * gameData.shakeIntensity;
                sy = (Math.random() - 0.5) * gameData.shakeIntensity;
                gameData.shakeIntensity *= 0.9;
            }

            ctx.save();
            ctx.translate(canvas.width / 2 + sx, canvas.height / 2 + sy);
            const focus = currentState.isSpectating ? (gameData.players[0] || {x:0, y:0, scale:18}) : me;
            const startScale = 18;
            const zoom = Math.max(0.1, 0.6 * (30 / (30 + ((focus.scale || 18) - startScale) * 0.4)));
            ctx.scale(zoom, zoom);
            ctx.translate(-focus.x, -focus.y);

            // World Border
            ctx.lineWidth = 12; ctx.strokeStyle = "rgba(255,0,0,0.9)";
            ctx.strokeRect(-WORLD_SIZE / 2, -WORLD_SIZE / 2, WORLD_SIZE, WORLD_SIZE);

            // IRELAND ESP (Restored)
            if (me.country === "ireland" && !me.dead) {
                 ctx.save();
                 ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
                 ctx.lineWidth = 2;
                 ctx.setLineDash([10, 10]);
                 gameData.enemies.forEach(e => {
                     if (e.alive) {
                         ctx.beginPath();
                         ctx.moveTo(me.x, me.y);
                         ctx.lineTo(e.x, e.y);
                         ctx.stroke();
                     }
                 });
                 ctx.restore();
            }

            // Syrup Zones
            gameData.syrupZones.forEach((z) => {
                ctx.fillStyle = "rgba(184, 134, 11, 0.5)"; ctx.beginPath(); ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = "#DAA520"; ctx.lineWidth = 4; ctx.stroke();
            });

            // Food
            gameData.food.forEach((f) => {
                const level = f.level || 1;
                const size = FOOD_RADIUS_BASE + level * 1.5;
                if (f.isGolden) { ctx.fillStyle = "#FFD700"; ctx.shadowColor = "#FFD700"; ctx.shadowBlur = 10; }
                else { ctx.fillStyle = "orange"; ctx.shadowBlur = 0; }
                ctx.beginPath(); ctx.arc(f.x, f.y, size, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                // Highlight high level food
                if (level > 8) {
                    ctx.globalAlpha = 0.3; ctx.fillStyle = "white"; ctx.beginPath();
                    ctx.arc(f.x, f.y, size + 3, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0;
                }
            });

            // Mines
            gameData.mines.forEach((m) => {
                if (m.state === "triggered" && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.beginPath(); ctx.arc(m.x, m.y, 200, 0, Math.PI * 2); ctx.fill();
                }
                const r = 25; const d = r * 2;
                ctx.save(); ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.clip();
                // Mine Art (Detailed Flag Style)
                ctx.fillStyle = "#C6363C"; ctx.fillRect(m.x - r, m.y - r, d, d / 3);
                ctx.fillStyle = "#0C4076"; ctx.fillRect(m.x - r, m.y - r + d / 3, d, d / 3);
                ctx.fillStyle = "#FFFFFF"; ctx.fillRect(m.x - r, m.y - r + (2 * d) / 3, d, d / 3);
                // Skull/Cross
                ctx.fillStyle = "white"; ctx.beginPath();
                ctx.moveTo(m.x - 10, m.y - 10); ctx.lineTo(m.x, m.y - 10); ctx.lineTo(m.x, m.y + 5);
                ctx.lineTo(m.x - 5, m.y + 12); ctx.lineTo(m.x - 10, m.y + 5); ctx.fill();
                ctx.restore();
                ctx.strokeStyle = m.state === "triggered" ? "red" : "#333"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(m.x, m.y, r, 0, Math.PI * 2); ctx.stroke();
            });

            // Render Entities (Players + Bots)
            const allEntities = [...gameData.players, ...gameData.enemies];
            allEntities.forEach((p) => {
                if (p.dead || p.alive === false) return;

                // Effects
                if (p.frozenUntil && Date.now() < p.frozenUntil) { ctx.shadowBlur = 15; ctx.shadowColor = "cyan"; }
                else if (p.country === "soviet" && p.abilityActive) { ctx.shadowBlur = 30; ctx.shadowColor = "#FF0000"; }
                else if (p.country === "golden_maple" && p.maplePhase === "harvest") {
                    ctx.shadowBlur = 40; ctx.shadowColor = "#DAA520";
                    ctx.strokeStyle = "rgba(218, 165, 32, 0.4)"; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(p.x, p.y, 5 * CELL, 0, Math.PI * 2); ctx.stroke();
                }

                // Body
                const bodyW = p.scale || p.width || 12;
                ctx.lineWidth = bodyW * 1.2;
                ctx.strokeStyle = (p.frozenUntil && Date.now() < p.frozenUntil) ? "cyan" : (p.colorBody || p.color || "white");
                ctx.lineCap = "round"; ctx.lineJoin = "round";
                ctx.beginPath();
                if (p.body.length) {
                    ctx.moveTo(p.body[0].x, p.body[0].y);
                    p.body.forEach(b => ctx.lineTo(b.x, b.y));
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                // Head
                const r = bodyW * 0.65;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle + Math.PI / 2);
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.clip();

                drawFlag(ctx, p.country, r, p.color);

                ctx.restore();
                
                // Name Tag
                if(p.name && zoom > 0.3) {
                     ctx.fillStyle = "white"; 
                     ctx.font = `bold ${Math.max(12, r)}px Arial`; 
                     ctx.textAlign = "center";
                     ctx.fillText(p.name, p.x, p.y - r - 10);
                }
            });

            // Explosions
            gameData.explosions.forEach((ex) => {
                ctx.fillStyle = `rgba(255,69,0,${ex.alpha})`; ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2); ctx.fill();
            });

            ctx.restore();
        }

        // -------------------------------------------------------------------------
        // FLAG DRAWING RENDERER (Updated Ireland + Golden Maple)
        // -------------------------------------------------------------------------
        function drawFlag(ctx, country, r, fallbackColor) {
            const rect = (x, y, w, h, c) => { ctx.fillStyle = c; ctx.fillRect(x, y, w, h); };

            if (!country) { ctx.fillStyle = fallbackColor || "white"; ctx.fillRect(-r, -r, r * 2, r * 2); return; }

            if (country === 'bosnia') {
                rect(-r, -r, r * 2, r * 2, "#002F6C");
                ctx.fillStyle = "#FECB00"; ctx.beginPath(); ctx.moveTo(r * 0.2, -r); ctx.lineTo(r * 0.2, r); ctx.lineTo(r, -r * 0.5); ctx.fill();
                ctx.fillStyle = "white";
                for (let i = 0; i < 5; i++) { ctx.beginPath(); ctx.arc(-r * 0.2, -r * 0.6 + i * r * 0.4, r * 0.1, 0, Math.PI * 2); ctx.fill(); }
            }
            else if (country === 'russia') {
                rect(-r, -r, r * 2, (r * 2) / 3, "white");
                rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#0039A6");
                rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "#D52B1E");
            }
            // SERBIA (AI SKIN)
            else if (country === 'serbia') {
                rect(-r, -r, r * 2, (r * 2) / 3, "#C6363C"); // Red top
                rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#0C4076"); // Blue middle
                rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "white"); // White bottom
            }
            else if (country === 'germany') {
                rect(-r, -r, r * 2, (r * 2) / 3, "black");
                rect(-r, -r + (r * 2) / 3, r * 2, (r * 2) / 3, "#DD0000");
                rect(-r, -r + (2 * r * 2) / 3, r * 2, (r * 2) / 3, "#FFCC00");
            }
            else if (country === 'france') {
                rect(-r, -r, (r * 2) / 3, r * 2, "#0055A4");
                rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "white");
                rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#EF4135");
            }
            else if (country === 'italy') {
                rect(-r, -r, (r * 2) / 3, r * 2, "#008C45");
                rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "white");
                rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#CD212A");
            }
            else if (country === 'ireland') {
                // FIXED IRELAND SKIN
                rect(-r, -r, (r * 2) / 3, r * 2, "#169B62"); // Green
                rect(-r + (r * 2) / 3, -r, (r * 2) / 3, r * 2, "#FFFFFF"); // White
                rect(-r + (2 * r * 2) / 3, -r, (r * 2) / 3, r * 2, "#FF883E"); // Orange
            }
            else if (country === 'ukraine') {
                rect(-r, -r, r * 2, r, "#0057B8");
                rect(-r, 0, r * 2, r, "#FFD700");
            }
            else if (country === 'poland') {
                rect(-r, -r, r * 2, r, "white");
                rect(-r, 0, r * 2, r, "#DC143C");
            }
            else if (country === 'canada') {
                rect(-r, -r, (r * 2) / 4, r * 2, "#FF0000");
                rect(-r + (r * 2) / 4, -r, r, r * 2, "white");
                rect(r / 2, -r, (r * 2) / 4, r * 2, "#FF0000");
                ctx.fillStyle = "#FF0000"; ctx.beginPath(); ctx.moveTo(0, -r * 0.4); ctx.lineTo(r * 0.3, 0); ctx.lineTo(0, r * 0.4); ctx.lineTo(-r * 0.3, 0); ctx.fill();
            }
            else if (country === 'usa') {
                rect(-r, -r, r * 2, r * 2, "white");
                for (let i = 0; i < 7; i++) rect(-r, -r + (i * 2 * r / 7), r * 2, r / 7, "#B22234");
                rect(-r, -r, r, r * 0.8, "#3C3B6E");
                ctx.fillStyle = "white";
                for (let py = 0; py < 3; py++) for (let px = 0; px < 4; px++) {
                    ctx.beginPath(); ctx.arc(-r + 5 + px * (r / 4), -r + 5 + py * (r / 4), 2, 0, Math.PI * 2); ctx.fill();
                }
            }
            else if (country === 'soviet') {
                rect(-r, -r, r * 2, r * 2, "#CC0000");
                ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(-r * 0.4, -r * 0.4, r * 0.25, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = "#FFD700"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-r * 0.4, -r * 0.2, r * 0.2, 0, Math.PI); ctx.stroke();
            }
            else if (country === 'golden_maple') {
                // FIXED GOLDEN MAPLE SKIN (Based on image)
                rect(-r, -r, r*2, r*2, "white"); // White Background
                rect(-r, -r, (r*2)/4, r*2, "#FFFF00"); // Yellow Left Band (approx 1/4)
                rect(r/2, -r, (r*2)/4, r*2, "#FFFF00"); // Yellow Right Band
                // Yellow Leaf
                ctx.fillStyle = "#FFFF00"; 
                ctx.beginPath(); ctx.moveTo(0, -r * 0.4); ctx.lineTo(r * 0.3, 0); ctx.lineTo(0, r * 0.4); ctx.lineTo(-r * 0.3, 0); ctx.fill();
            }
            else if (country === 'sweden') {
                rect(-r, -r, r * 2, r * 2, "#006AA7");
                rect(-r, -r * 0.2, r * 2, r * 0.4, "#FECC00");
                rect(-r * 0.2, -r, r * 0.4, r * 2, "#FECC00");
            }
            else if (country === 'denmark') {
                rect(-r, -r, r * 2, r * 2, "#C60C30");
                rect(-r, -r * 0.2, r * 2, r * 0.4, "white");
                rect(-r * 0.2, -r, r * 0.4, r * 2, "white");
            }
            else if (country === 'uk') {
                rect(-r, -r, r * 2, r * 2, "#012169");
                rect(-r, -r * 0.3, r * 2, r * 0.6, "white");
                rect(-r * 0.3, -r, r * 0.6, r * 2, "white");
                rect(-r, -r * 0.15, r * 2, r * 0.3, "#C8102E");
                rect(-r * 0.15, -r, r * 0.3, r * 2, "#C8102E");
            }
            else {
                rect(-r, -r, r * 2, r * 2, fallbackColor || "#333");
            }
        }

        // -------------------------------------------------------------------------
        // UI INTERACTION
        // -------------------------------------------------------------------------
        
        function toggleUI(mode) {
            currentState.menu = mode;
            document.getElementById('menu-container').style.display = mode === 'start' ? 'flex' : 'none';
            document.getElementById('hud').style.display = mode === 'playing' && !currentState.isSpectating ? 'flex' : 'none';
            document.getElementById('chat-container').style.display = mode === 'playing' ? 'flex' : 'none';
            document.getElementById('death-screen').style.display = mode === 'death' ? 'block' : 'none';
            document.getElementById('spectator-label').style.display = currentState.isSpectating ? 'block' : 'none';
        }

        function renderSkinGrid() {
            const grid = document.getElementById('skin-grid');
            grid.innerHTML = '';
            const list = currentState.skinCategory === 'normal' ? SKINS_NORMAL : SKINS_SPECIAL;

            list.forEach(skin => {
                const unlocked = isSkinUnlocked(skin);
                const req = UNLOCK_CRITERIA[skin] || { label: "Locked" };
                const div = document.createElement('div');
                div.className = `skin-tile ${currentState.selectedSkin === skin ? 'selected' : ''} ${!unlocked ? 'locked' : ''}`;
                div.innerHTML = `
                    <div class="skin-color-dot" style="background: ${SKIN_BODY_COLORS[skin]}"></div>
                    <div style="font-size: 11px; font-weight: bold; text-transform: uppercase; color: ${unlocked ? 'white' : '#888'}">${skin.replace('_', ' ')}</div>
                    ${!unlocked ? `<div class="lock-text"> ${req.label}</div>` : ''}
                `;
                div.onclick = () => {
                    if (unlocked) {
                        currentState.selectedSkin = skin;
                        renderSkinGrid();
                    }
                };
                grid.appendChild(div);
            });
        }

        async function submitScoreToLeaderboard(scale) {
            const size = parseFloat(scale.toFixed(2));
            if (size < 20 || !authReady) return;
            try {
                const lbRef = collection(db, "leaderboard");
                const q = query(lbRef, where("name", "==", currentState.playerName));
                const snap = await getDocs(q);
                if (snap.empty) {
                    await addDoc(lbRef, { name: currentState.playerName, size: size, timestamp: serverTimestamp() });
                } else {
                    const d = snap.docs[0];
                    if (size > d.data().size) updateDoc(doc(db, "leaderboard", d.id), { size: size });
                }
            } catch (e) { console.error("Leaderboard Error", e); }
        }

        async function startScanner() {
            // Live Games Scanner
            const scan = async () => {
                if(!authReady) return;
                try {
                    const q = query(collection(db, "active_games"), orderBy("lastBeat", "desc"), limit(20));
                    const snap = await getDocs(q);
                    const list = document.getElementById('spectate-list');
                    list.innerHTML = '';
                    document.getElementById('scan-status').innerText = "";
                    let found = 0;
                    const now = Date.now();

                    snap.docs.forEach(doc => {
                        const data = doc.data();
                        if (data.lastBeat && (now - data.lastBeat.toMillis() < 30000)) {
                            found++;
                            const row = document.createElement('div');
                            row.className = 'spectate-row';
                            row.innerHTML = `<div><b>${data.host}</b></div><div style="background:#28a745; padding:3px 6px; border-radius:3px; font-size:10px; color:white;">SPECTATE</div>`;
                            row.onclick = () => initSpectate(doc.id);
                            list.appendChild(row);
                        }
                    });
                    if (found === 0) list.innerHTML = '<div style="color:#666; font-size:12px; font-style:italic; padding:10px;">No active games found. Start one!</div>';
                } catch(e) { console.warn("Scanner error", e); }
            };
            scan();
            setInterval(scan, 10000);

            // Leaderboard Listener
            try {
                onSnapshot(query(collection(db, "leaderboard"), orderBy("size", "desc"), limit(5)), (snap) => {
                    const div = document.getElementById('leaderboard-content');
                    div.innerHTML = '';
                    snap.docs.forEach((d, i) => {
                        const r = document.createElement('div');
                        r.className = 'row';
                        r.innerHTML = `<span style="color:${i === 0 ? '#FECB00' : 'white'}">${i + 1}. ${d.data().name}</span> <span style="color:#4caf50">${Math.round(d.data().size)}</span>`;
                        div.appendChild(r);
                    });
                });
            } catch(e) { console.log("LB pending"); }
        }

        function addChatMessage(name, text, color) {
            const container = document.getElementById('chat-messages');
            const el = document.createElement('div');
            el.className = 'chat-line';
            el.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}: </span>${text}`;
            container.appendChild(el);
            if (container.children.length > 9) container.removeChild(container.firstChild);
        }

        // -------------------------------------------------------------------------
        // EVENT LISTENERS
        // -------------------------------------------------------------------------
        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            keys[k] = true;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            // Chat Focus Check
            if (document.activeElement === document.getElementById('chat-input') && k !== 'escape') return;

            // Cheat Panel Toggle
            if (e.key === '`' || e.key === '~') {
                e.preventDefault();
                if (showOwnerPanel) {
                    showOwnerPanel = false;
                    document.getElementById('owner-control-panel').style.display = 'none';
                } else {
                    showOwnerLogin = !showOwnerLogin;
                    document.getElementById('owner-login-panel').style.display = showOwnerLogin ? 'block' : 'none';
                    if(showOwnerLogin) document.getElementById('owner-password').focus();
                }
            }
        });

        window.addEventListener('keyup', e => {
            if (document.activeElement === document.getElementById('chat-input')) return;
            keys[e.key.toLowerCase()] = false;
        });
        
        window.addEventListener('mousemove', e => { 
            mouse.x = e.clientX; 
            mouse.y = e.clientY; 
        });

        window.addEventListener('resize', () => {
             canvas.width = window.innerWidth;
             canvas.height = window.innerHeight;
        });

        // Button Listeners
        document.getElementById('btn-play').onclick = initSinglePlayer;
        document.getElementById('btn-mouse').onclick = () => {
            currentState.controlMode = 'mouse';
            document.getElementById('btn-mouse').classList.add('active');
            document.getElementById('btn-keyboard').classList.remove('active');
        };
        document.getElementById('btn-keyboard').onclick = () => {
            currentState.controlMode = 'keyboard';
            document.getElementById('btn-keyboard').classList.add('active');
            document.getElementById('btn-mouse').classList.remove('active');
        };
        document.getElementById('cat-normal').onclick = () => {
            currentState.skinCategory = 'normal';
            document.getElementById('cat-normal').classList.add('active');
            document.getElementById('cat-special').classList.remove('active');
            renderSkinGrid();
        };
        document.getElementById('cat-special').onclick = () => {
            currentState.skinCategory = 'special';
            document.getElementById('cat-special').classList.add('active');
            document.getElementById('cat-normal').classList.remove('active');
            renderSkinGrid();
        };
        document.getElementById('nickname-input').oninput = (e) => {
            currentState.playerName = e.target.value;
            localStorage.setItem('bosnia_snake_username', e.target.value);
        };
        document.getElementById('nickname-input').value = currentState.playerName;

        document.getElementById('btn-redeem').onclick = () => {
            const code = document.getElementById('redeem-input').value;
            
            // --- SECRET CODES ---
            if (code === "Roblox13_isme") {
                updateStats({ unlockSecret: "MASTER_UNLOCK" });
                alert("GOD MODE: All Skins Unlocked!");
                renderSkinGrid();
            }
            else if (code === "Ireland_isgreat") {
                if(!isSkinUnlocked('ireland')) {
                    updateStats({ unlockSecret: "ireland" });
                    alert("SUCCESS: Ireland Skin Unlocked!");
                    renderSkinGrid();
                } else alert("Already Unlocked");
            } 
            else alert("Invalid Code");
        };

        // Chat
        document.getElementById('chat-input').onkeydown = (e) => {
            if (e.key === 'Enter') {
                const text = e.target.value;
                if (text.trim()) {
                    if (currentState.isHost) {
                        const msg = { name: currentState.playerName, text: text, color: "#FECB00" };
                        addChatMessage(msg.name, msg.text, msg.color);
                        playSound("chat");
                        broadcastChat(msg);
                    } else if (hostConn && hostConn.open) {
                        hostConn.send({ type: "CHAT", name: currentState.playerName, text: text });
                        addChatMessage(currentState.playerName, text, "#fff");
                    }
                }
                e.target.value = '';
                document.getElementById('game-canvas').focus();
            }
        };

        // Owner / Cheats
        document.getElementById('btn-owner-login').onclick = () => {
            const pass = document.getElementById('owner-password').value;
            if(pass === OWNER_PASSWORD) {
                showOwnerLogin = false;
                document.getElementById('owner-login-panel').style.display = 'none';
                showOwnerPanel = true;
                document.getElementById('owner-control-panel').style.display = 'block';
                document.getElementById('cheat-msg').innerText = "ACCESS GRANTED";
            } else {
                alert("ACCESS DENIED");
            }
        };
        
        // Cheat Buttons
        const setCheatMsg = (txt) => {
            const el = document.getElementById('cheat-msg');
            el.innerText = txt;
            setTimeout(() => el.innerText = '', 2000);
        };

        document.getElementById('cheat-god').onclick = () => {
            cheats.godMode = !cheats.godMode;
            document.getElementById('cheat-god').innerText = "God Mode: " + (cheats.godMode ? "ON" : "OFF");
            setCheatMsg("God Mode " + (cheats.godMode ? "Enabled" : "Disabled"));
        };
        document.getElementById('cheat-speed').onclick = () => {
            cheats.speedHack = !cheats.speedHack;
            document.getElementById('cheat-speed').innerText = "Speed Hack: " + (cheats.speedHack ? "ON" : "OFF");
            setCheatMsg("Speed " + (cheats.speedHack ? "Boosted" : "Normal"));
        };
        document.getElementById('cheat-size').onclick = () => {
            if(gameData.players[0]) {
                gameData.players[0].scale = 50;
                gameData.players[0].length = 500;
                setCheatMsg("Size Set to 50");
            }
        };
        document.getElementById('cheat-killbots').onclick = () => {
            gameData.enemies.forEach(e => { if(e.alive) killEnemy(e, null); });
            setCheatMsg("Bots Cleared");
        };
        document.getElementById('cheat-reset').onclick = () => {
            resetWorld(true);
            setCheatMsg("World Reset");
        };

        // -------------------------------------------------------------------------
        // STARTUP
        // -------------------------------------------------------------------------
        updateStatsUI();
        renderSkinGrid();
        requestAnimationFrame(loop);

        console.log("Bosnia Snake Ultimate Loaded. Press ` (Backtick) for Admin Login.");

    </script>
</body>
</html>
